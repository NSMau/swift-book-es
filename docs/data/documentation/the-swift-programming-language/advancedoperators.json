{"hierarchy":{"paths":[["doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language"]]},"sections":[],"kind":"article","primaryContentSections":[{"kind":"content","content":[{"type":"paragraph","inlineContent":[{"text":"In addition to the operators described in ","type":"text"},{"type":"reference","isActive":true,"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/BasicOperators"},{"text":",","type":"text"},{"type":"text","text":" "},{"text":"Swift provides several advanced operators that perform more complex value manipulation.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"These include all of the bitwise and bit shifting operators you will be familiar with"},{"type":"text","text":" "},{"type":"text","text":"from C and Objective-C."}]},{"inlineContent":[{"type":"text","text":"Unlike arithmetic operators in C,"},{"type":"text","text":" "},{"type":"text","text":"arithmetic operators in Swift don’t overflow by default."},{"type":"text","text":" "},{"text":"Overflow behavior is trapped and reported as an error.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"To opt in to overflow behavior,"},{"type":"text","text":" "},{"text":"use Swift’s second set of arithmetic operators that overflow by default,","type":"text"},{"text":" ","type":"text"},{"text":"such as the overflow addition operator (","type":"text"},{"code":"&+","type":"codeVoice"},{"text":").","type":"text"},{"text":" ","type":"text"},{"text":"All of these overflow operators begin with an ampersand (","type":"text"},{"code":"&","type":"codeVoice"},{"type":"text","text":")."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"text":"When you define your own structures, classes, and enumerations,","type":"text"},{"type":"text","text":" "},{"text":"it can be useful to provide your own implementations of","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"the standard Swift operators for these custom types."},{"text":" ","type":"text"},{"type":"text","text":"Swift makes it easy to provide tailored implementations of these operators"},{"text":" ","type":"text"},{"type":"text","text":"and to determine exactly what their behavior should be for each type you create."}]},{"type":"paragraph","inlineContent":[{"text":"You’re not limited to the predefined operators.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"Swift gives you the freedom to define your own custom"},{"text":" ","type":"text"},{"type":"text","text":"infix, prefix, postfix, and assignment operators,"},{"type":"text","text":" "},{"text":"with custom precedence and associativity values.","type":"text"},{"type":"text","text":" "},{"text":"These operators can be used and adopted in your code like any of the predefined operators,","type":"text"},{"type":"text","text":" "},{"type":"text","text":"and you can even extend existing types to support the custom operators you define."}]},{"text":"Operadores Bit a Bit","type":"heading","level":2,"anchor":"Operadores-Bit-a-Bit"},{"type":"paragraph","inlineContent":[{"type":"emphasis","inlineContent":[{"text":"Bitwise operators","type":"text"}]},{"type":"text","text":" enable you to manipulate"},{"type":"text","text":" "},{"text":"the individual raw data bits within a data structure.","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"They’re often used in low-level programming,"},{"text":" ","type":"text"},{"type":"text","text":"such as graphics programming and device driver creation."},{"text":" ","type":"text"},{"text":"Bitwise operators can also be useful when you work with raw data from external sources,","type":"text"},{"type":"text","text":" "},{"type":"text","text":"such as encoding and decoding data for communication over a custom protocol."}]},{"inlineContent":[{"type":"text","text":"Swift supports all of the bitwise operators found in C, as described below."}],"type":"paragraph"},{"text":"Operador NOT Bit a Bit","anchor":"Operador-NOT-Bit-a-Bit","type":"heading","level":3},{"type":"paragraph","inlineContent":[{"text":"The ","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"bitwise NOT operator"}]},{"text":" (","type":"text"},{"code":"~","type":"codeVoice"},{"type":"text","text":") inverts all bits in a number:"}]},{"inlineContent":[{"type":"image","identifier":"bitwiseNOT"}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"The bitwise NOT operator is a prefix operator,"},{"text":" ","type":"text"},{"type":"text","text":"and appears immediately before the value it operates on,"},{"type":"text","text":" "},{"text":"without any white space:","type":"text"}]},{"type":"codeListing","syntax":"swift","code":["let initialBits: UInt8 = 0b00001111","let invertedBits = ~initialBits  \/\/ equals 11110000"]},{"type":"paragraph","inlineContent":[{"code":"UInt8","type":"codeVoice"},{"type":"text","text":" integers have eight bits"},{"type":"text","text":" "},{"text":"and can store any value between ","type":"text"},{"code":"0","type":"codeVoice"},{"text":" and ","type":"text"},{"type":"codeVoice","code":"255"},{"type":"text","text":"."},{"type":"text","text":" "},{"text":"This example initializes a ","type":"text"},{"type":"codeVoice","code":"UInt8"},{"type":"text","text":" integer with the binary value "},{"code":"00001111","type":"codeVoice"},{"text":",","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"which has its first four bits set to "},{"type":"codeVoice","code":"0"},{"text":",","type":"text"},{"type":"text","text":" "},{"type":"text","text":"and its second four bits set to "},{"code":"1","type":"codeVoice"},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"This is equivalent to a decimal value of "},{"type":"codeVoice","code":"15"},{"type":"text","text":"."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The bitwise NOT operator is then used to create a new constant called "},{"code":"invertedBits","type":"codeVoice"},{"text":",","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"which is equal to "},{"code":"initialBits","type":"codeVoice"},{"type":"text","text":","},{"text":" ","type":"text"},{"type":"text","text":"but with all of the bits inverted."},{"type":"text","text":" "},{"type":"text","text":"Zeros become ones, and ones become zeros."},{"type":"text","text":" "},{"type":"text","text":"The value of "},{"type":"codeVoice","code":"invertedBits"},{"type":"text","text":" is "},{"type":"codeVoice","code":"11110000"},{"type":"text","text":","},{"text":" ","type":"text"},{"type":"text","text":"which is equal to an unsigned decimal value of "},{"type":"codeVoice","code":"240"},{"text":".","type":"text"}]},{"level":3,"anchor":"Operador-AND-Bit-a-Bit","text":"Operador AND Bit a Bit","type":"heading"},{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"inlineContent":[{"type":"text","text":"bitwise AND operator"}],"type":"emphasis"},{"text":" (","type":"text"},{"code":"&","type":"codeVoice"},{"text":") combines the bits of two numbers.","type":"text"},{"text":" ","type":"text"},{"text":"It returns a new number whose bits are set to ","type":"text"},{"code":"1","type":"codeVoice"},{"type":"text","text":" "},{"type":"text","text":"only if the bits were equal to "},{"type":"codeVoice","code":"1"},{"type":"text","text":" in "},{"inlineContent":[{"type":"text","text":"both"}],"type":"emphasis"},{"type":"text","text":" input numbers:"}]},{"type":"paragraph","inlineContent":[{"type":"image","identifier":"bitwiseAND"}]},{"type":"paragraph","inlineContent":[{"text":"In the example below,","type":"text"},{"type":"text","text":" "},{"type":"text","text":"the values of "},{"type":"codeVoice","code":"firstSixBits"},{"text":" and ","type":"text"},{"code":"lastSixBits","type":"codeVoice"},{"type":"text","text":" "},{"text":"both have four middle bits equal to ","type":"text"},{"code":"1","type":"codeVoice"},{"text":".","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"The bitwise AND operator combines them to make the number "},{"code":"00111100","type":"codeVoice"},{"text":",","type":"text"},{"type":"text","text":" "},{"type":"text","text":"which is equal to an unsigned decimal value of "},{"type":"codeVoice","code":"60"},{"type":"text","text":":"}]},{"type":"codeListing","syntax":"swift","code":["let firstSixBits: UInt8 = 0b11111100","let lastSixBits: UInt8  = 0b00111111","let middleFourBits = firstSixBits & lastSixBits  \/\/ equals 00111100"]},{"anchor":"Operador-OR-Bit-a-Bit","text":"Operador OR Bit a Bit","level":3,"type":"heading"},{"type":"paragraph","inlineContent":[{"text":"The ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"bitwise OR operator","type":"text"}]},{"type":"text","text":" ("},{"code":"|","type":"codeVoice"},{"text":") compares the bits of two numbers.","type":"text"},{"type":"text","text":" "},{"text":"The operator returns a new number whose bits are set to ","type":"text"},{"code":"1","type":"codeVoice"},{"text":" ","type":"text"},{"type":"text","text":"if the bits are equal to "},{"code":"1","type":"codeVoice"},{"type":"text","text":" in "},{"inlineContent":[{"text":"either","type":"text"}],"type":"emphasis"},{"type":"text","text":" input number:"}]},{"inlineContent":[{"type":"image","identifier":"bitwiseOR"}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"text":"In the example below,","type":"text"},{"type":"text","text":" "},{"text":"the values of ","type":"text"},{"type":"codeVoice","code":"someBits"},{"type":"text","text":" and "},{"code":"moreBits","type":"codeVoice"},{"text":" have different bits set to ","type":"text"},{"type":"codeVoice","code":"1"},{"text":".","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"The bitwise OR operator combines them to make the number "},{"code":"11111110","type":"codeVoice"},{"text":",","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"which equals an unsigned decimal of "},{"type":"codeVoice","code":"254"},{"type":"text","text":":"}]},{"type":"codeListing","syntax":"swift","code":["let someBits: UInt8 = 0b10110010","let moreBits: UInt8 = 0b01011110","let combinedbits = someBits | moreBits  \/\/ equals 11111110"]},{"anchor":"Operador-XOR-Bit-a-Bit","type":"heading","text":"Operador XOR Bit a Bit","level":3},{"inlineContent":[{"type":"text","text":"The "},{"inlineContent":[{"type":"text","text":"bitwise XOR operator"}],"type":"emphasis"},{"type":"text","text":", or “exclusive OR operator” ("},{"code":"^","type":"codeVoice"},{"type":"text","text":"),"},{"text":" ","type":"text"},{"text":"compares the bits of two numbers.","type":"text"},{"text":" ","type":"text"},{"text":"The operator returns a new number whose bits are set to ","type":"text"},{"type":"codeVoice","code":"1"},{"type":"text","text":" "},{"type":"text","text":"where the input bits are different"},{"text":" ","type":"text"},{"type":"text","text":"and are set to "},{"type":"codeVoice","code":"0"},{"type":"text","text":" where the input bits are the same:"}],"type":"paragraph"},{"inlineContent":[{"identifier":"bitwiseXOR","type":"image"}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"text":"In the example below,","type":"text"},{"text":" ","type":"text"},{"text":"the values of ","type":"text"},{"type":"codeVoice","code":"firstBits"},{"type":"text","text":" and "},{"code":"otherBits","type":"codeVoice"},{"text":" each have a bit set to ","type":"text"},{"code":"1","type":"codeVoice"},{"type":"text","text":" "},{"type":"text","text":"in a location that the other does not."},{"type":"text","text":" "},{"text":"The bitwise XOR operator sets both of these bits to ","type":"text"},{"code":"1","type":"codeVoice"},{"text":" in its output value.","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"All of the other bits in "},{"type":"codeVoice","code":"firstBits"},{"type":"text","text":" and "},{"code":"otherBits","type":"codeVoice"},{"text":" match","type":"text"},{"type":"text","text":" "},{"text":"and are set to ","type":"text"},{"code":"0","type":"codeVoice"},{"type":"text","text":" in the output value:"}]},{"type":"codeListing","syntax":"swift","code":["let firstBits: UInt8 = 0b00010100","let otherBits: UInt8 = 0b00000101","let outputBits = firstBits ^ otherBits  \/\/ equals 00010001"]},{"text":"Operadores Bit a Bit de desplazamiento a la izquierda y a la derecha","type":"heading","level":3,"anchor":"Operadores-Bit-a-Bit-de-desplazamiento-a-la-izquierda-y-a-la-derecha"},{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"type":"emphasis","inlineContent":[{"text":"bitwise left shift operator","type":"text"}]},{"text":" (","type":"text"},{"type":"codeVoice","code":"<<"},{"type":"text","text":")"},{"text":" ","type":"text"},{"type":"text","text":"and "},{"type":"emphasis","inlineContent":[{"text":"bitwise right shift operator","type":"text"}]},{"text":" (","type":"text"},{"type":"codeVoice","code":">>"},{"type":"text","text":")"},{"text":" ","type":"text"},{"type":"text","text":"move all bits in a number to the left or the right by a certain number of places,"},{"type":"text","text":" "},{"text":"according to the rules defined below.","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"Bitwise left and right shifts have the effect of","type":"text"},{"text":" ","type":"text"},{"text":"multiplying or dividing an integer by a factor of two.","type":"text"},{"type":"text","text":" "},{"text":"Shifting an integer’s bits to the left by one position doubles its value,","type":"text"},{"text":" ","type":"text"},{"text":"whereas shifting it to the right by one position halves its value.","type":"text"}]},{"type":"heading","level":4,"anchor":"Comportamiento-de-desplazamiento-para-enteros-sin-signo","text":"Comportamiento de desplazamiento para enteros sin signo"},{"type":"paragraph","inlineContent":[{"type":"text","text":"The bit-shifting behavior for unsigned integers is as follows:"}]},{"items":[{"content":[{"inlineContent":[{"type":"text","text":"Existing bits are moved to the left or right by the requested number of places."}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"Any bits that are moved beyond the bounds of the integer’s storage are discarded.","type":"text"}]}]},{"content":[{"inlineContent":[{"text":"Zeros are inserted in the spaces left behind","type":"text"},{"type":"text","text":" "},{"type":"text","text":"after the original bits are moved to the left or right."}],"type":"paragraph"}]}],"type":"orderedList"},{"type":"paragraph","inlineContent":[{"text":"This approach is known as a ","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"logical shift"}]},{"text":".","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"The illustration below shows the results of ","type":"text"},{"type":"codeVoice","code":"11111111 << 1"},{"text":" ","type":"text"},{"type":"text","text":"(which is "},{"code":"11111111","type":"codeVoice"},{"type":"text","text":" shifted to the left by "},{"code":"1","type":"codeVoice"},{"text":" place),","type":"text"},{"type":"text","text":" "},{"text":"and ","type":"text"},{"code":"11111111 >> 1","type":"codeVoice"},{"text":" ","type":"text"},{"text":"(which is ","type":"text"},{"code":"11111111","type":"codeVoice"},{"text":" shifted to the right by ","type":"text"},{"type":"codeVoice","code":"1"},{"type":"text","text":" place)."},{"text":" ","type":"text"},{"type":"text","text":"Green numbers are shifted,"},{"type":"text","text":" "},{"type":"text","text":"gray numbers are discarded,"},{"type":"text","text":" "},{"text":"and pink zeros are inserted:","type":"text"}]},{"type":"paragraph","inlineContent":[{"identifier":"bitshiftUnsigned","type":"image"}]},{"inlineContent":[{"text":"Here’s how bit shifting looks in Swift code:","type":"text"}],"type":"paragraph"},{"type":"codeListing","code":["let shiftBits: UInt8 = 4   \/\/ 00000100 in binary","shiftBits << 1             \/\/ 00001000","shiftBits << 2             \/\/ 00010000","shiftBits << 5             \/\/ 10000000","shiftBits << 6             \/\/ 00000000","shiftBits >> 2             \/\/ 00000001"],"syntax":"swift"},{"inlineContent":[{"text":"You can use bit shifting to encode and decode values within other data types:","type":"text"}],"type":"paragraph"},{"type":"codeListing","code":["let pink: UInt32 = 0xCC6699","let redComponent = (pink & 0xFF0000) >> 16    \/\/ redComponent is 0xCC, or 204","let greenComponent = (pink & 0x00FF00) >> 8   \/\/ greenComponent is 0x66, or 102","let blueComponent = pink & 0x0000FF           \/\/ blueComponent is 0x99, or 153"],"syntax":"swift"},{"inlineContent":[{"type":"text","text":"This example uses a "},{"type":"codeVoice","code":"UInt32"},{"type":"text","text":" constant called "},{"type":"codeVoice","code":"pink"},{"text":" to store a","type":"text"},{"type":"text","text":" "},{"text":"Cascading Style Sheets color value for the color pink.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"The CSS color value "},{"code":"#CC6699","type":"codeVoice"},{"type":"text","text":" is written as"},{"type":"text","text":" "},{"type":"codeVoice","code":"0xCC6699"},{"type":"text","text":" in Swift’s hexadecimal number representation."},{"type":"text","text":" "},{"type":"text","text":"This color is then decomposed into its"},{"text":" ","type":"text"},{"text":"red (","type":"text"},{"type":"codeVoice","code":"CC"},{"text":"), green (","type":"text"},{"code":"66","type":"codeVoice"},{"text":"), and blue (","type":"text"},{"type":"codeVoice","code":"99"},{"type":"text","text":") components"},{"type":"text","text":" "},{"type":"text","text":"by the bitwise AND operator ("},{"type":"codeVoice","code":"&"},{"type":"text","text":") and the bitwise right shift operator ("},{"type":"codeVoice","code":">>"},{"type":"text","text":")."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"The red component is obtained by performing a bitwise AND"},{"text":" ","type":"text"},{"text":"between the numbers ","type":"text"},{"type":"codeVoice","code":"0xCC6699"},{"type":"text","text":" and "},{"code":"0xFF0000","type":"codeVoice"},{"text":".","type":"text"},{"type":"text","text":" "},{"type":"text","text":"The zeros in "},{"code":"0xFF0000","type":"codeVoice"},{"text":" effectively “mask” the second and third bytes of ","type":"text"},{"type":"codeVoice","code":"0xCC6699"},{"type":"text","text":","},{"type":"text","text":" "},{"text":"causing the ","type":"text"},{"type":"codeVoice","code":"6699"},{"type":"text","text":" to be ignored and leaving "},{"type":"codeVoice","code":"0xCC0000"},{"text":" as the result.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"This number is then shifted 16 places to the right ("},{"code":">> 16","type":"codeVoice"},{"type":"text","text":")."},{"type":"text","text":" "},{"type":"text","text":"Each pair of characters in a hexadecimal number uses 8 bits,"},{"type":"text","text":" "},{"text":"so a move 16 places to the right will convert ","type":"text"},{"code":"0xCC0000","type":"codeVoice"},{"text":" into ","type":"text"},{"type":"codeVoice","code":"0x0000CC"},{"type":"text","text":"."},{"text":" ","type":"text"},{"text":"This is the same as ","type":"text"},{"code":"0xCC","type":"codeVoice"},{"type":"text","text":", which has a decimal value of "},{"code":"204","type":"codeVoice"},{"text":".","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"Similarly, the green component is obtained by performing a bitwise AND"},{"text":" ","type":"text"},{"text":"between the numbers ","type":"text"},{"type":"codeVoice","code":"0xCC6699"},{"type":"text","text":" and "},{"code":"0x00FF00","type":"codeVoice"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"which gives an output value of "},{"code":"0x006600","type":"codeVoice"},{"text":".","type":"text"},{"type":"text","text":" "},{"text":"This output value is then shifted eight places to the right,","type":"text"},{"type":"text","text":" "},{"type":"text","text":"giving a value of "},{"code":"0x66","type":"codeVoice"},{"text":", which has a decimal value of ","type":"text"},{"code":"102","type":"codeVoice"},{"text":".","type":"text"}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"text":"Finally, the blue component is obtained by performing a bitwise AND","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"between the numbers "},{"type":"codeVoice","code":"0xCC6699"},{"text":" and ","type":"text"},{"type":"codeVoice","code":"0x0000FF"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"which gives an output value of "},{"code":"0x000099","type":"codeVoice"},{"text":".","type":"text"},{"type":"text","text":" "},{"type":"text","text":"Because "},{"code":"0x000099","type":"codeVoice"},{"type":"text","text":" already equals "},{"code":"0x99","type":"codeVoice"},{"text":",","type":"text"},{"type":"text","text":" "},{"text":"which has a decimal value of ","type":"text"},{"type":"codeVoice","code":"153"},{"text":",","type":"text"},{"type":"text","text":" "},{"text":"this value is used without shifting it to the right,","type":"text"}]},{"type":"heading","level":4,"text":"Comportamiento de desplazamiento para enteros con signo","anchor":"Comportamiento-de-desplazamiento-para-enteros-con-signo"},{"inlineContent":[{"type":"text","text":"The shifting behavior is more complex for signed integers than for unsigned integers,"},{"text":" ","type":"text"},{"text":"because of the way signed integers are represented in binary.","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"(The examples below are based on 8-bit signed integers for simplicity,"},{"text":" ","type":"text"},{"type":"text","text":"but the same principles apply for signed integers of any size.)"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"Signed integers use their first bit (known as the "},{"type":"emphasis","inlineContent":[{"type":"text","text":"sign bit"}]},{"type":"text","text":")"},{"type":"text","text":" "},{"text":"to indicate whether the integer is positive or negative.","type":"text"},{"type":"text","text":" "},{"text":"A sign bit of ","type":"text"},{"code":"0","type":"codeVoice"},{"type":"text","text":" means positive, and a sign bit of "},{"code":"1","type":"codeVoice"},{"text":" means negative.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"The remaining bits (known as the "},{"inlineContent":[{"type":"text","text":"value bits"}],"type":"emphasis"},{"type":"text","text":") store the actual value."},{"type":"text","text":" "},{"text":"Positive numbers are stored in exactly the same way as for unsigned integers,","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"counting upwards from "},{"type":"codeVoice","code":"0"},{"type":"text","text":"."},{"text":" ","type":"text"},{"type":"text","text":"Here’s how the bits inside an "},{"code":"Int8","type":"codeVoice"},{"text":" look for the number ","type":"text"},{"code":"4","type":"codeVoice"},{"type":"text","text":":"}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"image","identifier":"bitshiftSignedFour"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The sign bit is "},{"type":"codeVoice","code":"0"},{"type":"text","text":" (meaning “positive”),"},{"text":" ","type":"text"},{"text":"and the seven value bits are just the number ","type":"text"},{"type":"codeVoice","code":"4"},{"type":"text","text":","},{"type":"text","text":" "},{"text":"written in binary notation.","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"Negative numbers, however, are stored differently.","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"They’re stored by subtracting their absolute value from "},{"code":"2","type":"codeVoice"},{"type":"text","text":" to the power of "},{"type":"codeVoice","code":"n"},{"text":",","type":"text"},{"type":"text","text":" "},{"text":"where ","type":"text"},{"type":"codeVoice","code":"n"},{"type":"text","text":" is the number of value bits."},{"type":"text","text":" "},{"text":"An eight-bit number has seven value bits,","type":"text"},{"type":"text","text":" "},{"text":"so this means ","type":"text"},{"code":"2","type":"codeVoice"},{"text":" to the power of ","type":"text"},{"code":"7","type":"codeVoice"},{"text":", or ","type":"text"},{"code":"128","type":"codeVoice"},{"type":"text","text":"."}]},{"type":"paragraph","inlineContent":[{"text":"Here’s how the bits inside an ","type":"text"},{"type":"codeVoice","code":"Int8"},{"type":"text","text":" look for the number "},{"type":"codeVoice","code":"-4"},{"text":":","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"image","identifier":"bitshiftSignedMinusFour"}]},{"inlineContent":[{"type":"text","text":"This time, the sign bit is "},{"type":"codeVoice","code":"1"},{"type":"text","text":" (meaning “negative”),"},{"text":" ","type":"text"},{"text":"and the seven value bits have a binary value of ","type":"text"},{"type":"codeVoice","code":"124"},{"text":" (which is ","type":"text"},{"type":"codeVoice","code":"128 - 4"},{"type":"text","text":"):"}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"identifier":"bitshiftSignedMinusFourValue","type":"image"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"This encoding for negative numbers is known as a "},{"type":"emphasis","inlineContent":[{"text":"two’s complement","type":"text"}]},{"type":"text","text":" representation."},{"text":" ","type":"text"},{"type":"text","text":"It may seem an unusual way to represent negative numbers,"},{"text":" ","type":"text"},{"text":"but it has several advantages.","type":"text"}]},{"inlineContent":[{"text":"First, you can add ","type":"text"},{"type":"codeVoice","code":"-1"},{"type":"text","text":" to "},{"code":"-4","type":"codeVoice"},{"text":",","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"simply by performing a standard binary addition of all eight bits"},{"type":"text","text":" "},{"text":"(including the sign bit),","type":"text"},{"type":"text","text":" "},{"text":"and discarding anything that doesn’t fit in the eight bits once you’re done:","type":"text"}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"identifier":"bitshiftSignedAddition","type":"image"}]},{"inlineContent":[{"text":"Second, the two’s complement representation also lets you","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"shift the bits of negative numbers to the left and right like positive numbers,"},{"text":" ","type":"text"},{"text":"and still end up doubling them for every shift you make to the left,","type":"text"},{"type":"text","text":" "},{"type":"text","text":"or halving them for every shift you make to the right."},{"text":" ","type":"text"},{"type":"text","text":"To achieve this, an extra rule is used when signed integers are shifted to the right:"},{"type":"text","text":" "},{"type":"text","text":"When you shift signed integers to the right,"},{"type":"text","text":" "},{"text":"apply the same rules as for unsigned integers,","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"but fill any empty bits on the left with the "},{"inlineContent":[{"text":"sign bit","type":"text"}],"type":"emphasis"},{"text":",","type":"text"},{"type":"text","text":" "},{"type":"text","text":"rather than with a zero."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"identifier":"bitshiftSigned","type":"image"}]},{"inlineContent":[{"text":"This action ensures that signed integers have the same sign after they’re shifted to the right,","type":"text"},{"text":" ","type":"text"},{"text":"and is known as an ","type":"text"},{"inlineContent":[{"type":"text","text":"arithmetic shift"}],"type":"emphasis"},{"type":"text","text":"."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Because of the special way that positive and negative numbers are stored,"},{"text":" ","type":"text"},{"type":"text","text":"shifting either of them to the right moves them closer to zero."},{"text":" ","type":"text"},{"text":"Keeping the sign bit the same during this shift means that","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"negative integers remain negative as their value moves closer to zero."}]},{"type":"heading","level":2,"anchor":"Operadores-de-desbordamiento","text":"Operadores de desbordamiento"},{"type":"paragraph","inlineContent":[{"text":"If you try to insert a number into an integer constant or variable","type":"text"},{"type":"text","text":" "},{"type":"text","text":"that can’t hold that value,"},{"text":" ","type":"text"},{"type":"text","text":"by default Swift reports an error rather than allowing an invalid value to be created."},{"type":"text","text":" "},{"text":"This behavior gives extra safety when you work with numbers that are too large or too small.","type":"text"}]},{"inlineContent":[{"text":"For example, the ","type":"text"},{"type":"codeVoice","code":"Int16"},{"type":"text","text":" integer type can hold"},{"text":" ","type":"text"},{"text":"any signed integer between ","type":"text"},{"code":"-32768","type":"codeVoice"},{"text":" and ","type":"text"},{"type":"codeVoice","code":"32767"},{"type":"text","text":"."},{"text":" ","type":"text"},{"text":"Trying to set an ","type":"text"},{"type":"codeVoice","code":"Int16"},{"text":" constant or variable to a number outside of this range","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"causes an error:"}],"type":"paragraph"},{"code":["var potentialOverflow = Int16.max","\/\/ potentialOverflow equals 32767, which is the maximum value an Int16 can hold","potentialOverflow += 1","\/\/ this causes an error"],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"type":"text","text":"Providing error handling when values get too large or too small"},{"type":"text","text":" "},{"text":"gives you much more flexibility when coding for boundary value conditions.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"However, when you specifically want an overflow condition"},{"type":"text","text":" "},{"type":"text","text":"to truncate the number of available bits,"},{"type":"text","text":" "},{"type":"text","text":"you can opt in to this behavior rather than triggering an error."},{"text":" ","type":"text"},{"type":"text","text":"Swift provides three arithmetic "},{"inlineContent":[{"type":"text","text":"overflow operators"}],"type":"emphasis"},{"type":"text","text":" that opt in to"},{"type":"text","text":" "},{"type":"text","text":"the overflow behavior for integer calculations."},{"type":"text","text":" "},{"type":"text","text":"These operators all begin with an ampersand ("},{"code":"&","type":"codeVoice"},{"text":"):","type":"text"}],"type":"paragraph"},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"Overflow addition (","type":"text"},{"type":"codeVoice","code":"&+"},{"type":"text","text":")"}]}]},{"content":[{"inlineContent":[{"type":"text","text":"Overflow subtraction ("},{"type":"codeVoice","code":"&-"},{"type":"text","text":")"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"text","text":"Overflow multiplication ("},{"type":"codeVoice","code":"&*"},{"type":"text","text":")"}],"type":"paragraph"}]}]},{"level":3,"anchor":"Desbordamiento-de-valores","text":"Desbordamiento de valores","type":"heading"},{"type":"paragraph","inlineContent":[{"text":"Numbers can overflow in both the positive and negative direction.","type":"text"}]},{"inlineContent":[{"type":"text","text":"Here’s an example of what happens when"},{"type":"text","text":" "},{"text":"an unsigned integer is allowed to overflow in the positive direction,","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"using the overflow addition operator ("},{"type":"codeVoice","code":"&+"},{"type":"text","text":"):"}],"type":"paragraph"},{"type":"codeListing","code":["var unsignedOverflow = UInt8.max","\/\/ unsignedOverflow equals 255, which is the maximum value a UInt8 can hold","unsignedOverflow = unsignedOverflow &+ 1","\/\/ unsignedOverflow is now equal to 0"],"syntax":"swift"},{"type":"paragraph","inlineContent":[{"type":"text","text":"The variable "},{"code":"unsignedOverflow","type":"codeVoice"},{"text":" is initialized with the maximum value a ","type":"text"},{"code":"UInt8","type":"codeVoice"},{"type":"text","text":" can hold"},{"type":"text","text":" "},{"type":"text","text":"("},{"code":"255","type":"codeVoice"},{"type":"text","text":", or "},{"type":"codeVoice","code":"11111111"},{"type":"text","text":" in binary)."},{"type":"text","text":" "},{"type":"text","text":"It’s then incremented by "},{"code":"1","type":"codeVoice"},{"text":" using the overflow addition operator (","type":"text"},{"code":"&+","type":"codeVoice"},{"text":").","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"This pushes its binary representation just over the size that a "},{"code":"UInt8","type":"codeVoice"},{"text":" can hold,","type":"text"},{"type":"text","text":" "},{"text":"causing it to overflow beyond its bounds,","type":"text"},{"type":"text","text":" "},{"type":"text","text":"as shown in the diagram below."},{"text":" ","type":"text"},{"text":"The value that remains within the bounds of the ","type":"text"},{"code":"UInt8","type":"codeVoice"},{"text":" ","type":"text"},{"type":"text","text":"after the overflow addition is "},{"type":"codeVoice","code":"00000000"},{"type":"text","text":", or zero."}]},{"type":"paragraph","inlineContent":[{"identifier":"overflowAddition","type":"image"}]},{"inlineContent":[{"type":"text","text":"Something similar happens when"},{"text":" ","type":"text"},{"text":"an unsigned integer is allowed to overflow in the negative direction.","type":"text"},{"text":" ","type":"text"},{"text":"Here’s an example using the overflow subtraction operator (","type":"text"},{"code":"&-","type":"codeVoice"},{"text":"):","type":"text"}],"type":"paragraph"},{"type":"codeListing","code":["var unsignedOverflow = UInt8.min","\/\/ unsignedOverflow equals 0, which is the minimum value a UInt8 can hold","unsignedOverflow = unsignedOverflow &- 1","\/\/ unsignedOverflow is now equal to 255"],"syntax":"swift"},{"inlineContent":[{"type":"text","text":"The minimum value that a "},{"type":"codeVoice","code":"UInt8"},{"text":" can hold is zero,","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"or "},{"type":"codeVoice","code":"00000000"},{"type":"text","text":" in binary."},{"type":"text","text":" "},{"type":"text","text":"If you subtract "},{"type":"codeVoice","code":"1"},{"type":"text","text":" from "},{"type":"codeVoice","code":"00000000"},{"type":"text","text":" using the overflow subtraction operator ("},{"type":"codeVoice","code":"&-"},{"type":"text","text":"),"},{"type":"text","text":" "},{"type":"text","text":"the number will overflow and wrap around to "},{"code":"11111111","type":"codeVoice"},{"text":",","type":"text"},{"type":"text","text":" "},{"type":"text","text":"or "},{"type":"codeVoice","code":"255"},{"type":"text","text":" in decimal."}],"type":"paragraph"},{"inlineContent":[{"type":"image","identifier":"overflowUnsignedSubtraction"}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"text":"Overflow also occurs for signed integers.","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"All addition and subtraction for signed integers is performed in bitwise fashion,"},{"type":"text","text":" "},{"type":"text","text":"with the sign bit included as part of the numbers being added or subtracted,"},{"type":"text","text":" "},{"type":"text","text":"as described in "},{"type":"reference","identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/AdvancedOperators#Operadores-Bit-a-Bit-de-desplazamiento-a-la-izquierda-y-a-la-derecha","isActive":true},{"text":".","type":"text"}]},{"code":["var signedOverflow = Int8.min","\/\/ signedOverflow equals -128, which is the minimum value an Int8 can hold","signedOverflow = signedOverflow &- 1","\/\/ signedOverflow is now equal to 127"],"syntax":"swift","type":"codeListing"},{"type":"paragraph","inlineContent":[{"text":"The minimum value that an ","type":"text"},{"type":"codeVoice","code":"Int8"},{"type":"text","text":" can hold is "},{"type":"codeVoice","code":"-128"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"or "},{"code":"10000000","type":"codeVoice"},{"type":"text","text":" in binary."},{"type":"text","text":" "},{"type":"text","text":"Subtracting "},{"code":"1","type":"codeVoice"},{"type":"text","text":" from this binary number with the overflow operator"},{"type":"text","text":" "},{"text":"gives a binary value of ","type":"text"},{"type":"codeVoice","code":"01111111"},{"type":"text","text":","},{"text":" ","type":"text"},{"text":"which toggles the sign bit and gives positive ","type":"text"},{"code":"127","type":"codeVoice"},{"type":"text","text":","},{"text":" ","type":"text"},{"type":"text","text":"the maximum positive value that an "},{"code":"Int8","type":"codeVoice"},{"text":" can hold.","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"image","identifier":"overflowSignedSubtraction"}]},{"inlineContent":[{"type":"text","text":"For both signed and unsigned integers,"},{"type":"text","text":" "},{"type":"text","text":"overflow in the positive direction"},{"type":"text","text":" "},{"type":"text","text":"wraps around from the maximum valid integer value back to the minimum,"},{"type":"text","text":" "},{"type":"text","text":"and overflow in the negative direction"},{"type":"text","text":" "},{"type":"text","text":"wraps around from the minimum value to the maximum."}],"type":"paragraph"},{"text":"Precedencia y asociatividad","level":2,"anchor":"Precedencia-y-asociatividad","type":"heading"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Operator "},{"inlineContent":[{"type":"text","text":"precedence"}],"type":"emphasis"},{"type":"text","text":" gives some operators higher priority than others;"},{"text":" ","type":"text"},{"text":"these operators are applied first.","type":"text"}]},{"inlineContent":[{"text":"Operator ","type":"text"},{"inlineContent":[{"type":"text","text":"associativity"}],"type":"emphasis"},{"text":" defines how operators of the same precedence","type":"text"},{"type":"text","text":" "},{"type":"text","text":"are grouped together —"},{"type":"text","text":" "},{"type":"text","text":"either grouped from the left, or grouped from the right."},{"text":" ","type":"text"},{"text":"Think of it as meaning “they associate with the expression to their left,”","type":"text"},{"type":"text","text":" "},{"text":"or “they associate with the expression to their right.”","type":"text"}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"It’s important to consider"},{"type":"text","text":" "},{"type":"text","text":"each operator’s precedence and associativity"},{"type":"text","text":" "},{"type":"text","text":"when working out the order in which a compound expression will be calculated."},{"type":"text","text":" "},{"text":"For example,","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"operator precedence explains why the following expression equals "},{"type":"codeVoice","code":"17"},{"type":"text","text":"."}]},{"type":"codeListing","syntax":"swift","code":["2 + 3 % 4 * 5","\/\/ this equals 17"]},{"inlineContent":[{"text":"If you read strictly from left to right,","type":"text"},{"type":"text","text":" "},{"text":"you might expect the expression to be calculated as follows:","type":"text"}],"type":"paragraph"},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"code":"2","type":"codeVoice"},{"text":" plus ","type":"text"},{"type":"codeVoice","code":"3"},{"text":" equals ","type":"text"},{"type":"codeVoice","code":"5"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"5"},{"text":" remainder ","type":"text"},{"type":"codeVoice","code":"4"},{"type":"text","text":" equals "},{"code":"1","type":"codeVoice"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"code":"1","type":"codeVoice"},{"type":"text","text":" times "},{"code":"5","type":"codeVoice"},{"text":" equals ","type":"text"},{"type":"codeVoice","code":"5"}]}]}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"However, the actual answer is "},{"type":"codeVoice","code":"17"},{"type":"text","text":", not "},{"code":"5","type":"codeVoice"},{"type":"text","text":"."},{"type":"text","text":" "},{"text":"Higher-precedence operators are evaluated before lower-precedence ones.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"In Swift, as in C,"},{"type":"text","text":" "},{"type":"text","text":"the remainder operator ("},{"type":"codeVoice","code":"%"},{"text":") and the multiplication operator (","type":"text"},{"type":"codeVoice","code":"*"},{"type":"text","text":")"},{"text":" ","type":"text"},{"type":"text","text":"have a higher precedence than the addition operator ("},{"type":"codeVoice","code":"+"},{"text":").","type":"text"},{"text":" ","type":"text"},{"text":"As a result, they’re both evaluated before the addition is considered.","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"However, remainder and multiplication have the ","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"same"}]},{"type":"text","text":" precedence as each other."},{"text":" ","type":"text"},{"type":"text","text":"To work out the exact evaluation order to use,"},{"text":" ","type":"text"},{"text":"you also need to consider their associativity.","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"Remainder and multiplication both associate with the expression to their left."},{"type":"text","text":" "},{"text":"Think of this as adding implicit parentheses around these parts of the expression,","type":"text"},{"type":"text","text":" "},{"type":"text","text":"starting from their left:"}]},{"type":"codeListing","syntax":"swift","code":["2 + ((3 % 4) * 5)"]},{"inlineContent":[{"type":"codeVoice","code":"(3 % 4)"},{"type":"text","text":" is "},{"type":"codeVoice","code":"3"},{"type":"text","text":", so this is equivalent to:"}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["2 + (3 * 5)"]},{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"(3 * 5)"},{"type":"text","text":" is "},{"type":"codeVoice","code":"15"},{"text":", so this is equivalent to:","type":"text"}]},{"type":"codeListing","syntax":"swift","code":["2 + 15"]},{"inlineContent":[{"type":"text","text":"This calculation yields the final answer of "},{"code":"17","type":"codeVoice"},{"text":".","type":"text"}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"For information about the operators provided by the Swift standard library,"},{"text":" ","type":"text"},{"type":"text","text":"including a complete list of the operator precedence groups and associativity settings,"},{"type":"text","text":" "},{"text":"see ","type":"text"},{"identifier":"https:\/\/developer.apple.com\/documentation\/swift\/operator_declarations","type":"reference","isActive":true},{"type":"text","text":"."}]},{"style":"note","name":"Note","content":[{"inlineContent":[{"type":"text","text":"Swift’s operator precedences and associativity rules are simpler and more predictable"},{"type":"text","text":" "},{"type":"text","text":"than those found in C and Objective-C."},{"text":" ","type":"text"},{"type":"text","text":"However, this means that they aren’t exactly the same as in C-based languages."},{"type":"text","text":" "},{"type":"text","text":"Be careful to ensure that operator interactions still behave in the way you intend"},{"type":"text","text":" "},{"text":"when porting existing code to Swift.","type":"text"}],"type":"paragraph"}],"type":"aside"},{"anchor":"M%C3%A9todos-operadores","level":2,"text":"Métodos operadores","type":"heading"},{"type":"paragraph","inlineContent":[{"text":"Classes and structures can provide their own implementations of existing operators.","type":"text"},{"type":"text","text":" "},{"text":"This is known as ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"overloading","type":"text"}]},{"type":"text","text":" the existing operators."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The example below shows how to implement"},{"text":" ","type":"text"},{"text":"the arithmetic addition operator (","type":"text"},{"code":"+","type":"codeVoice"},{"text":") for a custom structure.","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"The arithmetic addition operator is a binary operator"},{"text":" ","type":"text"},{"type":"text","text":"because it operates on two targets"},{"type":"text","text":" "},{"type":"text","text":"and it’s an infix operator because it appears between those two targets."}]},{"inlineContent":[{"text":"The example defines a ","type":"text"},{"type":"codeVoice","code":"Vector2D"},{"type":"text","text":" structure for"},{"type":"text","text":" "},{"text":"a two-dimensional position vector ","type":"text"},{"type":"codeVoice","code":"(x, y)"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"followed by a definition of an "},{"type":"emphasis","inlineContent":[{"text":"operator method","type":"text"}]},{"type":"text","text":" "},{"type":"text","text":"to add together instances of the "},{"code":"Vector2D","type":"codeVoice"},{"text":" structure:","type":"text"}],"type":"paragraph"},{"code":["struct Vector2D {","    var x = 0.0, y = 0.0","}","","extension Vector2D {","    static func + (left: Vector2D, right: Vector2D) -> Vector2D {","       return Vector2D(x: left.x + right.x, y: left.y + right.y)","    }","}"],"type":"codeListing","syntax":"swift"},{"type":"paragraph","inlineContent":[{"text":"The operator method is defined as a type method on ","type":"text"},{"code":"Vector2D","type":"codeVoice"},{"text":",","type":"text"},{"text":" ","type":"text"},{"text":"with a method name that matches the operator to be overloaded (","type":"text"},{"type":"codeVoice","code":"+"},{"text":").","type":"text"},{"type":"text","text":" "},{"text":"Because addition isn’t part of the essential behavior for a vector,","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"the type method is defined in an extension of "},{"type":"codeVoice","code":"Vector2D"},{"type":"text","text":" "},{"text":"rather than in the main structure declaration of ","type":"text"},{"type":"codeVoice","code":"Vector2D"},{"type":"text","text":"."},{"text":" ","type":"text"},{"type":"text","text":"Because the arithmetic addition operator is a binary operator,"},{"type":"text","text":" "},{"type":"text","text":"this operator method takes two input parameters of type "},{"type":"codeVoice","code":"Vector2D"},{"text":" ","type":"text"},{"type":"text","text":"and returns a single output value, also of type "},{"type":"codeVoice","code":"Vector2D"},{"text":".","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"In this implementation, the input parameters are named ","type":"text"},{"type":"codeVoice","code":"left"},{"text":" and ","type":"text"},{"code":"right","type":"codeVoice"},{"type":"text","text":" "},{"type":"text","text":"to represent the "},{"type":"codeVoice","code":"Vector2D"},{"text":" instances that will be on","type":"text"},{"type":"text","text":" "},{"text":"the left side and right side of the ","type":"text"},{"type":"codeVoice","code":"+"},{"text":" operator.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"The method returns a new "},{"code":"Vector2D","type":"codeVoice"},{"text":" instance,","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"whose "},{"code":"x","type":"codeVoice"},{"type":"text","text":" and "},{"code":"y","type":"codeVoice"},{"type":"text","text":" properties are"},{"type":"text","text":" "},{"text":"initialized with the sum of the ","type":"text"},{"type":"codeVoice","code":"x"},{"type":"text","text":" and "},{"type":"codeVoice","code":"y"},{"type":"text","text":" properties from"},{"type":"text","text":" "},{"text":"the two ","type":"text"},{"type":"codeVoice","code":"Vector2D"},{"type":"text","text":" instances that are added together."}]},{"inlineContent":[{"text":"The type method","type":"text"},{"type":"text","text":" "},{"type":"text","text":"can be used as an infix operator between existing "},{"type":"codeVoice","code":"Vector2D"},{"text":" instances:","type":"text"}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["let vector = Vector2D(x: 3.0, y: 1.0)","let anotherVector = Vector2D(x: 2.0, y: 4.0)","let combinedVector = vector + anotherVector","\/\/ combinedVector is a Vector2D instance with values of (5.0, 5.0)"]},{"inlineContent":[{"text":"This example adds together the vectors ","type":"text"},{"type":"codeVoice","code":"(3.0, 1.0)"},{"type":"text","text":" and "},{"type":"codeVoice","code":"(2.0, 4.0)"},{"type":"text","text":" "},{"text":"to make the vector ","type":"text"},{"code":"(5.0, 5.0)","type":"codeVoice"},{"type":"text","text":", as illustrated below."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"identifier":"vectorAddition","type":"image"}]},{"anchor":"Operadores-prefijos-y-postfijos","text":"Operadores prefijos y postfijos","level":3,"type":"heading"},{"type":"paragraph","inlineContent":[{"type":"text","text":"The example shown above demonstrates a custom implementation of a binary infix operator."},{"type":"text","text":" "},{"type":"text","text":"Classes and structures can also provide implementations"},{"type":"text","text":" "},{"type":"text","text":"of the standard "},{"type":"emphasis","inlineContent":[{"type":"text","text":"unary operators"}]},{"text":".","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"Unary operators operate on a single target."},{"text":" ","type":"text"},{"type":"text","text":"They’re "},{"type":"emphasis","inlineContent":[{"text":"prefix","type":"text"}]},{"type":"text","text":" if they precede their target (such as "},{"code":"-a","type":"codeVoice"},{"type":"text","text":")"},{"type":"text","text":" "},{"text":"and ","type":"text"},{"inlineContent":[{"type":"text","text":"postfix"}],"type":"emphasis"},{"type":"text","text":" operators if they follow their target (such as "},{"type":"codeVoice","code":"b!"},{"type":"text","text":")."}]},{"type":"paragraph","inlineContent":[{"text":"You implement a prefix or postfix unary operator by writing","type":"text"},{"type":"text","text":" "},{"type":"text","text":"the "},{"type":"codeVoice","code":"prefix"},{"text":" or ","type":"text"},{"type":"codeVoice","code":"postfix"},{"type":"text","text":" modifier"},{"type":"text","text":" "},{"text":"before the ","type":"text"},{"type":"codeVoice","code":"func"},{"text":" keyword when declaring the operator method:","type":"text"}]},{"syntax":"swift","type":"codeListing","code":["extension Vector2D {","    static prefix func - (vector: Vector2D) -> Vector2D {","        return Vector2D(x: -vector.x, y: -vector.y)","    }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The example above implements the unary minus operator"},{"type":"text","text":" "},{"type":"text","text":"("},{"code":"-a","type":"codeVoice"},{"type":"text","text":") for "},{"code":"Vector2D","type":"codeVoice"},{"text":" instances.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"The unary minus operator is a prefix operator,"},{"type":"text","text":" "},{"text":"and so this method has to be qualified with the ","type":"text"},{"code":"prefix","type":"codeVoice"},{"text":" modifier.","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"For simple numeric values, the unary minus operator converts"},{"text":" ","type":"text"},{"text":"positive numbers into their negative equivalent and vice versa.","type":"text"},{"type":"text","text":" "},{"text":"The corresponding implementation for ","type":"text"},{"type":"codeVoice","code":"Vector2D"},{"text":" instances","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"performs this operation on both the "},{"type":"codeVoice","code":"x"},{"type":"text","text":" and "},{"code":"y","type":"codeVoice"},{"text":" properties:","type":"text"}]},{"type":"codeListing","syntax":"swift","code":["let positive = Vector2D(x: 3.0, y: 4.0)","let negative = -positive","\/\/ negative is a Vector2D instance with values of (-3.0, -4.0)","let alsoPositive = -negative","\/\/ alsoPositive is a Vector2D instance with values of (3.0, 4.0)"]},{"anchor":"Operadores-de-asignaci%C3%B3n-compuestos","level":3,"text":"Operadores de asignación compuestos","type":"heading"},{"type":"paragraph","inlineContent":[{"inlineContent":[{"type":"text","text":"Compound assignment operators"}],"type":"emphasis"},{"text":" combine assignment (","type":"text"},{"type":"codeVoice","code":"="},{"text":") with another operation.","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"For example, the addition assignment operator ("},{"code":"+=","type":"codeVoice"},{"type":"text","text":")"},{"text":" ","type":"text"},{"type":"text","text":"combines addition and assignment into a single operation."},{"type":"text","text":" "},{"text":"You mark a compound assignment operator’s left input parameter type as ","type":"text"},{"type":"codeVoice","code":"inout"},{"type":"text","text":","},{"text":" ","type":"text"},{"text":"because the parameter’s value will be modified directly from within the operator method.","type":"text"}]},{"inlineContent":[{"text":"The example below implements","type":"text"},{"type":"text","text":" "},{"type":"text","text":"an addition assignment operator method for "},{"code":"Vector2D","type":"codeVoice"},{"text":" instances:","type":"text"}],"type":"paragraph"},{"syntax":"swift","code":["extension Vector2D {","    static func += (left: inout Vector2D, right: Vector2D) {","        left = left + right","    }","}"],"type":"codeListing"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Because an addition operator was defined earlier,"},{"text":" ","type":"text"},{"type":"text","text":"you don’t need to reimplement the addition process here."},{"text":" ","type":"text"},{"text":"Instead, the addition assignment operator method","type":"text"},{"type":"text","text":" "},{"type":"text","text":"takes advantage of the existing addition operator method,"},{"type":"text","text":" "},{"text":"and uses it to set the left value to be the left value plus the right value:","type":"text"}]},{"type":"codeListing","syntax":"swift","code":["var original = Vector2D(x: 1.0, y: 2.0)","let vectorToAdd = Vector2D(x: 3.0, y: 4.0)","original += vectorToAdd","\/\/ original now has values of (4.0, 6.0)"]},{"style":"note","type":"aside","name":"Note","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"It isn’t possible to overload the default"},{"type":"text","text":" "},{"text":"assignment operator (","type":"text"},{"code":"=","type":"codeVoice"},{"type":"text","text":")."},{"text":" ","type":"text"},{"text":"Only the compound assignment operators can be overloaded.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"Similarly, the ternary conditional operator"},{"text":" ","type":"text"},{"type":"text","text":"("},{"code":"a ? b : c","type":"codeVoice"},{"type":"text","text":") can’t be overloaded."}]}]},{"type":"heading","text":"Operadores de equivalencia","level":3,"anchor":"Operadores-de-equivalencia"},{"type":"paragraph","inlineContent":[{"text":"By default, custom classes and structures don’t have an implementation of","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"the "},{"type":"emphasis","inlineContent":[{"type":"text","text":"equivalence operators"}]},{"text":",","type":"text"},{"type":"text","text":" "},{"text":"known as the ","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"equal to"}]},{"type":"text","text":" operator ("},{"code":"==","type":"codeVoice"},{"type":"text","text":") and "},{"inlineContent":[{"type":"text","text":"not equal to"}],"type":"emphasis"},{"text":" operator (","type":"text"},{"type":"codeVoice","code":"!="},{"text":").","type":"text"},{"text":" ","type":"text"},{"text":"You usually implement the ","type":"text"},{"code":"==","type":"codeVoice"},{"text":" operator,","type":"text"},{"type":"text","text":" "},{"type":"text","text":"and use the standard library’s default implementation of the "},{"code":"!=","type":"codeVoice"},{"text":" operator","type":"text"},{"text":" ","type":"text"},{"text":"that negates the result of the ","type":"text"},{"code":"==","type":"codeVoice"},{"text":" operator.","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"There are two ways to implement the "},{"type":"codeVoice","code":"=="},{"type":"text","text":" operator:"},{"text":" ","type":"text"},{"type":"text","text":"You can implement it yourself,"},{"text":" ","type":"text"},{"text":"or for many types, you can ask Swift to synthesize","type":"text"},{"text":" ","type":"text"},{"text":"an implementation for you.","type":"text"},{"type":"text","text":" "},{"text":"In both cases,","type":"text"},{"text":" ","type":"text"},{"text":"you add conformance to the standard library’s ","type":"text"},{"code":"Equatable","type":"codeVoice"},{"text":" protocol.","type":"text"}]},{"inlineContent":[{"type":"text","text":"You provide an implementation of the "},{"code":"==","type":"codeVoice"},{"text":" operator","type":"text"},{"type":"text","text":" "},{"type":"text","text":"in the same way as you implement other infix operators:"}],"type":"paragraph"},{"code":["extension Vector2D: Equatable {","    static func == (left: Vector2D, right: Vector2D) -> Bool {","       return (left.x == right.x) && (left.y == right.y)","    }","}"],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"text":"The example above implements an ","type":"text"},{"code":"==","type":"codeVoice"},{"type":"text","text":" operator"},{"text":" ","type":"text"},{"text":"to check whether two ","type":"text"},{"code":"Vector2D","type":"codeVoice"},{"type":"text","text":" instances have equivalent values."},{"type":"text","text":" "},{"text":"In the context of ","type":"text"},{"type":"codeVoice","code":"Vector2D"},{"text":",","type":"text"},{"type":"text","text":" "},{"type":"text","text":"it makes sense to consider “equal” as meaning"},{"type":"text","text":" "},{"type":"text","text":"“both instances have the same "},{"type":"codeVoice","code":"x"},{"text":" values and ","type":"text"},{"code":"y","type":"codeVoice"},{"type":"text","text":" values”,"},{"text":" ","type":"text"},{"text":"and so this is the logic used by the operator implementation.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"You can now use this operator to check whether two ","type":"text"},{"code":"Vector2D","type":"codeVoice"},{"type":"text","text":" instances are equivalent:"}],"type":"paragraph"},{"code":["let twoThree = Vector2D(x: 2.0, y: 3.0)","let anotherTwoThree = Vector2D(x: 2.0, y: 3.0)","if twoThree == anotherTwoThree {","    print(\"These two vectors are equivalent.\")","}","\/\/ Prints \"These two vectors are equivalent.\""],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"type":"text","text":"In many simple cases, you can ask Swift"},{"type":"text","text":" "},{"text":"to provide synthesized implementations of the equivalence operators for you,","type":"text"},{"type":"text","text":" "},{"type":"text","text":"as described in "},{"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Protocols#Adoptando-Un-Protocolo-Mediante-Una-Implementaci%C3%B3n-Sintetizada","type":"reference","isActive":true},{"type":"text","text":"."}],"type":"paragraph"},{"anchor":"Operadores-personalizados","level":2,"type":"heading","text":"Operadores personalizados"},{"type":"paragraph","inlineContent":[{"text":"You can declare and implement your own ","type":"text"},{"inlineContent":[{"type":"text","text":"custom operators"}],"type":"emphasis"},{"type":"text","text":" in addition to"},{"type":"text","text":" "},{"text":"the standard operators provided by Swift.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"For a list of characters that can be used to define custom operators,"},{"text":" ","type":"text"},{"type":"text","text":"see "},{"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/LexicalStructure#Operadores","type":"reference","isActive":true},{"type":"text","text":"."}]},{"type":"paragraph","inlineContent":[{"text":"New operators are declared at a global level using the ","type":"text"},{"type":"codeVoice","code":"operator"},{"type":"text","text":" keyword,"},{"type":"text","text":" "},{"text":"and are marked with the ","type":"text"},{"code":"prefix","type":"codeVoice"},{"text":", ","type":"text"},{"type":"codeVoice","code":"infix"},{"text":" or ","type":"text"},{"type":"codeVoice","code":"postfix"},{"text":" modifiers:","type":"text"}]},{"code":["prefix operator +++"],"type":"codeListing","syntax":"swift"},{"type":"paragraph","inlineContent":[{"type":"text","text":"The example above defines a new prefix operator called "},{"type":"codeVoice","code":"+++"},{"type":"text","text":"."},{"text":" ","type":"text"},{"text":"This operator doesn’t have an existing meaning in Swift,","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"and so it’s given its own custom meaning below in the specific context of"},{"text":" ","type":"text"},{"type":"text","text":"working with "},{"code":"Vector2D","type":"codeVoice"},{"text":" instances. For the purposes of this example,","type":"text"},{"text":" ","type":"text"},{"type":"codeVoice","code":"+++"},{"type":"text","text":" is treated as a new “prefix doubling” operator."},{"type":"text","text":" "},{"type":"text","text":"It doubles the "},{"type":"codeVoice","code":"x"},{"text":" and ","type":"text"},{"code":"y","type":"codeVoice"},{"text":" values of a ","type":"text"},{"type":"codeVoice","code":"Vector2D"},{"text":" instance,","type":"text"},{"type":"text","text":" "},{"type":"text","text":"by adding the vector to itself with the addition assignment operator defined earlier."},{"type":"text","text":" "},{"type":"text","text":"To implement the "},{"type":"codeVoice","code":"+++"},{"text":" operator,","type":"text"},{"text":" ","type":"text"},{"text":"you add a type method called ","type":"text"},{"type":"codeVoice","code":"+++"},{"type":"text","text":" to "},{"code":"Vector2D","type":"codeVoice"},{"text":" as follows:","type":"text"}]},{"type":"codeListing","code":["extension Vector2D {","    static prefix func +++ (vector: inout Vector2D) -> Vector2D {","        vector += vector","        return vector","    }","}","","var toBeDoubled = Vector2D(x: 1.0, y: 4.0)","let afterDoubling = +++toBeDoubled","\/\/ toBeDoubled now has values of (2.0, 8.0)","\/\/ afterDoubling also has values of (2.0, 8.0)"],"syntax":"swift"},{"text":"Precedencia para operadores interfijos personalizados","type":"heading","anchor":"Precedencia-para-operadores-interfijos-personalizados","level":3},{"inlineContent":[{"type":"text","text":"Custom infix operators each belong to a precedence group."},{"type":"text","text":" "},{"type":"text","text":"A precedence group specifies an operator’s precedence relative"},{"text":" ","type":"text"},{"text":"to other infix operators, as well as the operator’s associativity.","type":"text"},{"text":" ","type":"text"},{"text":"See ","type":"text"},{"isActive":true,"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/AdvancedOperators#Precedencia-y-asociatividad","type":"reference"},{"type":"text","text":" for an explanation of"},{"type":"text","text":" "},{"type":"text","text":"how these characteristics affect an infix operator’s interaction"},{"text":" ","type":"text"},{"text":"with other infix operators.","type":"text"}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"A custom infix operator that isn’t explicitly placed into a precedence group is"},{"text":" ","type":"text"},{"text":"given a default precedence group with a precedence immediately higher","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"than the precedence of the ternary conditional operator."}]},{"inlineContent":[{"type":"text","text":"The following example defines a new custom infix operator called "},{"type":"codeVoice","code":"+-"},{"text":",","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"which belongs to the precedence group "},{"type":"codeVoice","code":"AdditionPrecedence"},{"text":":","type":"text"}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["infix operator +-: AdditionPrecedence","extension Vector2D {","    static func +- (left: Vector2D, right: Vector2D) -> Vector2D {","        return Vector2D(x: left.x + right.x, y: left.y - right.y)","    }","}","let firstVector = Vector2D(x: 1.0, y: 2.0)","let secondVector = Vector2D(x: 3.0, y: 4.0)","let plusMinusVector = firstVector +- secondVector","\/\/ plusMinusVector is a Vector2D instance with values of (4.0, -2.0)"]},{"inlineContent":[{"text":"This operator adds together the ","type":"text"},{"code":"x","type":"codeVoice"},{"text":" values of two vectors,","type":"text"},{"type":"text","text":" "},{"type":"text","text":"and subtracts the "},{"type":"codeVoice","code":"y"},{"text":" value of the second vector from the first.","type":"text"},{"type":"text","text":" "},{"text":"Because it’s in essence an “additive” operator,","type":"text"},{"type":"text","text":" "},{"text":"it has been given the same precedence group","type":"text"},{"type":"text","text":" "},{"type":"text","text":"as additive infix operators such as "},{"code":"+","type":"codeVoice"},{"text":" and ","type":"text"},{"type":"codeVoice","code":"-"},{"text":".","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"For information about the operators provided by the Swift standard library,"},{"type":"text","text":" "},{"text":"including a complete list of the operator precedence groups and associativity settings,","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"see "},{"overridingTitleInlineContent":[{"type":"text","text":"Operator Declarations"}],"type":"reference","isActive":true,"identifier":"https:\/\/developer.apple.com\/documentation\/swift\/operator_declarations","overridingTitle":"Operator Declarations"},{"type":"text","text":"."},{"text":" ","type":"text"},{"type":"text","text":"For more information about precedence groups and to see the syntax for"},{"type":"text","text":" "},{"text":"defining your own operators and precedence groups,","type":"text"},{"text":" ","type":"text"},{"text":"see ","type":"text"},{"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Declarations#Declaraci%C3%B3n-de-Operadores","isActive":true,"type":"reference"},{"text":".","type":"text"}],"type":"paragraph"},{"type":"aside","style":"note","name":"Note","content":[{"type":"paragraph","inlineContent":[{"text":"You don’t specify a precedence when defining a prefix or postfix operator.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"However, if you apply both a prefix and a postfix operator to the same operand,"},{"text":" ","type":"text"},{"text":"the postfix operator is applied first.","type":"text"}]}]},{"text":"Constructores de resultados","type":"heading","level":2,"anchor":"Constructores-de-resultados"},{"inlineContent":[{"type":"text","text":"A "},{"inlineContent":[{"text":"result builder","type":"text"}],"type":"emphasis"},{"type":"text","text":" is a type you define"},{"text":" ","type":"text"},{"type":"text","text":"that adds syntax for creating nested data,"},{"type":"text","text":" "},{"type":"text","text":"like a list or tree,"},{"type":"text","text":" "},{"type":"text","text":"in a natural, declarative way."},{"text":" ","type":"text"},{"text":"The code that uses the result builder","type":"text"},{"text":" ","type":"text"},{"text":"can include ordinary Swift syntax, like ","type":"text"},{"code":"if","type":"codeVoice"},{"type":"text","text":"  and "},{"code":"for","type":"codeVoice"},{"type":"text","text":","},{"text":" ","type":"text"},{"text":"to handle conditional or repeated pieces of data.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"The code below defines a few types for drawing on a single line","type":"text"},{"text":" ","type":"text"},{"text":"using stars and text.","type":"text"}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["protocol Drawable {","    func draw() -> String","}","struct Line: Drawable {","    var elements: [Drawable]","    func draw() -> String {","        return elements.map { $0.draw() }.joined(separator: \"\")","    }","}","struct Text: Drawable {","    var content: String","    init(_ content: String) { self.content = content }","    func draw() -> String { return content }","}","struct Space: Drawable {","    func draw() -> String { return \" \" }","}","struct Stars: Drawable {","    var length: Int","    func draw() -> String { return String(repeating: \"*\", count: length) }","}","struct AllCaps: Drawable {","    var content: Drawable","    func draw() -> String { return content.draw().uppercased() }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"code":"Drawable","type":"codeVoice"},{"type":"text","text":" protocol defines the requirement"},{"type":"text","text":" "},{"type":"text","text":"for something that can be drawn, like a line or shape:"},{"type":"text","text":" "},{"text":"The type must implement a ","type":"text"},{"type":"codeVoice","code":"draw()"},{"type":"text","text":" method."},{"type":"text","text":" "},{"type":"text","text":"The "},{"type":"codeVoice","code":"Line"},{"text":" structure represents a single-line drawing,","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"and it serves the top-level container for most drawings."},{"text":" ","type":"text"},{"type":"text","text":"To draw a "},{"code":"Line","type":"codeVoice"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"the structure calls "},{"type":"codeVoice","code":"draw()"},{"text":" on each of the line’s components,","type":"text"},{"type":"text","text":" "},{"type":"text","text":"and then concatenates the resulting strings into a single string."},{"type":"text","text":" "},{"type":"text","text":"The "},{"type":"codeVoice","code":"Text"},{"type":"text","text":" structure wraps a string to make it part of a drawing."},{"type":"text","text":" "},{"type":"text","text":"The "},{"code":"AllCaps","type":"codeVoice"},{"type":"text","text":" structure wraps and modifies another drawing,"},{"text":" ","type":"text"},{"type":"text","text":"converting any text in the drawing to uppercase."}]},{"type":"paragraph","inlineContent":[{"text":"It’s possible to make a drawing with these types","type":"text"},{"type":"text","text":" "},{"type":"text","text":"by calling their initializers:"}]},{"syntax":"swift","type":"codeListing","code":["let name: String? = \"Ravi Patel\"","let manualDrawing = Line(elements: [","     Stars(length: 3),","     Text(\"Hello\"),","     Space(),","     AllCaps(content: Text((name ?? \"World\") + \"!\")),","     Stars(length: 2),","])","print(manualDrawing.draw())","\/\/ Prints \"***Hello RAVI PATEL!**\""]},{"type":"paragraph","inlineContent":[{"text":"This code works, but it’s a little awkward.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"The deeply nested parentheses after "},{"type":"codeVoice","code":"AllCaps"},{"type":"text","text":" are hard to read."},{"text":" ","type":"text"},{"text":"The fallback logic to use “World” when ","type":"text"},{"code":"name","type":"codeVoice"},{"text":" is ","type":"text"},{"code":"nil","type":"codeVoice"},{"text":" ","type":"text"},{"text":"has to be done inline using the ","type":"text"},{"type":"codeVoice","code":"??"},{"text":" operator,","type":"text"},{"type":"text","text":" "},{"type":"text","text":"which would be difficult with anything more complex."},{"type":"text","text":" "},{"type":"text","text":"If you needed to include switches or "},{"type":"codeVoice","code":"for"},{"type":"text","text":" loops"},{"text":" ","type":"text"},{"text":"to build up part of the drawing, there’s no way to do that.","type":"text"},{"type":"text","text":" "},{"text":"A result builder lets you rewrite code like this","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"so that it looks like normal Swift code."}]},{"inlineContent":[{"type":"text","text":"To define a result builder,"},{"type":"text","text":" "},{"type":"text","text":"you write the "},{"type":"codeVoice","code":"@resultBuilder"},{"type":"text","text":" attribute on a type declaration."},{"type":"text","text":" "},{"type":"text","text":"For example, this code defines a result builder called "},{"type":"codeVoice","code":"DrawingBuilder"},{"text":",","type":"text"},{"type":"text","text":" "},{"text":"which lets you use a declarative syntax to describe a drawing:","type":"text"}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["@resultBuilder","struct DrawingBuilder {","    static func buildBlock(_ components: Drawable...) -> Drawable {","        return Line(elements: components)","    }","    static func buildEither(first: Drawable) -> Drawable {","        return first","    }","    static func buildEither(second: Drawable) -> Drawable {","        return second","    }","}"]},{"inlineContent":[{"text":"The ","type":"text"},{"code":"DrawingBuilder","type":"codeVoice"},{"text":" structure defines three methods","type":"text"},{"type":"text","text":" "},{"type":"text","text":"that implement parts of the result builder syntax."},{"text":" ","type":"text"},{"type":"text","text":"The "},{"code":"buildBlock(_:)","type":"codeVoice"},{"type":"text","text":" method adds support for"},{"text":" ","type":"text"},{"text":"writing a series of lines in a block of code.","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"It combines the components in that block into a "},{"code":"Line","type":"codeVoice"},{"type":"text","text":"."},{"text":" ","type":"text"},{"type":"text","text":"The "},{"type":"codeVoice","code":"buildEither(first:)"},{"type":"text","text":" and "},{"type":"codeVoice","code":"buildEither(second:)"},{"text":" methods","type":"text"},{"text":" ","type":"text"},{"text":"add support for ","type":"text"},{"type":"codeVoice","code":"if"},{"text":"-","type":"text"},{"type":"codeVoice","code":"else"},{"type":"text","text":"."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"You can apply the "},{"code":"@DrawingBuilder","type":"codeVoice"},{"type":"text","text":" attribute to a function’s parameter,"},{"text":" ","type":"text"},{"text":"which turns a closure passed to the function","type":"text"},{"type":"text","text":" "},{"type":"text","text":"into the value that the result builder creates from that closure."},{"text":" ","type":"text"},{"type":"text","text":"For example:"}]},{"syntax":"swift","code":["func draw(@DrawingBuilder content: () -> Drawable) -> Drawable {","    return content()","}","func caps(@DrawingBuilder content: () -> Drawable) -> Drawable {","    return AllCaps(content: content())","}","","func makeGreeting(for name: String? = nil) -> Drawable {","    let greeting = draw {","        Stars(length: 3)","        Text(\"Hello\")","        Space()","        caps {","            if let name = name {","                Text(name + \"!\")","            } else {","                Text(\"World!\")","            }","        }","        Stars(length: 2)","    }","    return greeting","}","let genericGreeting = makeGreeting()","print(genericGreeting.draw())","\/\/ Prints \"***Hello WORLD!**\"","","let personalGreeting = makeGreeting(for: \"Ravi Patel\")","print(personalGreeting.draw())","\/\/ Prints \"***Hello RAVI PATEL!**\""],"type":"codeListing"},{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"type":"codeVoice","code":"makeGreeting(for:)"},{"text":" function takes a ","type":"text"},{"code":"name","type":"codeVoice"},{"type":"text","text":" parameter"},{"text":" ","type":"text"},{"text":"and uses it to draw a personalized greeting.","type":"text"},{"text":" ","type":"text"},{"text":"The ","type":"text"},{"type":"codeVoice","code":"draw(_:)"},{"text":" and ","type":"text"},{"code":"caps(_:)","type":"codeVoice"},{"type":"text","text":" functions"},{"type":"text","text":" "},{"text":"both take a single closure as their argument,","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"which is marked with the "},{"type":"codeVoice","code":"@DrawingBuilder"},{"type":"text","text":" attribute."},{"type":"text","text":" "},{"type":"text","text":"When you call those functions,"},{"text":" ","type":"text"},{"text":"you use the special syntax that ","type":"text"},{"code":"DrawingBuilder","type":"codeVoice"},{"type":"text","text":" defines."},{"type":"text","text":" "},{"text":"Swift transforms that declarative description of a drawing","type":"text"},{"text":" ","type":"text"},{"text":"into a series of calls to the methods on ","type":"text"},{"code":"DrawingBuilder","type":"codeVoice"},{"type":"text","text":" "},{"type":"text","text":"to build up the value that’s passed as the function argument."},{"type":"text","text":" "},{"type":"text","text":"For example,"},{"type":"text","text":" "},{"text":"Swift transforms the call to ","type":"text"},{"code":"caps(_:)","type":"codeVoice"},{"type":"text","text":" in that example"},{"type":"text","text":" "},{"text":"into code like the following:","type":"text"}]},{"type":"codeListing","code":["let capsDrawing = caps {","    let partialDrawing: Drawable","    if let name = name {","        let text = Text(name + \"!\")","        partialDrawing = DrawingBuilder.buildEither(first: text)","    } else {","        let text = Text(\"World!\")","        partialDrawing = DrawingBuilder.buildEither(second: text)","    }","    return partialDrawing","}"],"syntax":"swift"},{"inlineContent":[{"text":"Swift transforms the ","type":"text"},{"code":"if","type":"codeVoice"},{"type":"text","text":"-"},{"code":"else","type":"codeVoice"},{"type":"text","text":" block into"},{"text":" ","type":"text"},{"text":"calls to the ","type":"text"},{"type":"codeVoice","code":"buildEither(first:)"},{"type":"text","text":" and "},{"type":"codeVoice","code":"buildEither(second:)"},{"type":"text","text":" methods."},{"type":"text","text":" "},{"text":"Although you don’t call these methods in your own code,","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"showing the result of the transformation"},{"text":" ","type":"text"},{"type":"text","text":"makes it easier to see how Swift transforms your code"},{"type":"text","text":" "},{"type":"text","text":"when you use the "},{"type":"codeVoice","code":"DrawingBuilder"},{"text":" syntax.","type":"text"}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"text":"To add support for writing ","type":"text"},{"type":"codeVoice","code":"for"},{"type":"text","text":" loops in the special drawing syntax,"},{"text":" ","type":"text"},{"type":"text","text":"add a "},{"code":"buildArray(_:)","type":"codeVoice"},{"type":"text","text":" method."}]},{"syntax":"swift","code":["extension DrawingBuilder {","    static func buildArray(_ components: [Drawable]) -> Drawable {","        return Line(elements: components)","    }","}","let manyStars = draw {","    Text(\"Stars:\")","    for length in 1...3 {","        Space()","        Stars(length: length)","    }","}"],"type":"codeListing"},{"type":"paragraph","inlineContent":[{"type":"text","text":"In the code above, the "},{"type":"codeVoice","code":"for"},{"text":" loop creates an array of drawings,","type":"text"},{"type":"text","text":" "},{"type":"text","text":"and the "},{"type":"codeVoice","code":"buildArray(_:)"},{"type":"text","text":" method turns that array into a "},{"type":"codeVoice","code":"Line"},{"type":"text","text":"."}]},{"inlineContent":[{"text":"For a complete list of how Swift transforms builder syntax","type":"text"},{"text":" ","type":"text"},{"text":"into calls to the builder type’s methods,","type":"text"},{"type":"text","text":" "},{"text":"see ","type":"text"},{"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Attributes#resultBuilder","isActive":true,"type":"reference"},{"type":"text","text":"."}],"type":"paragraph"},{"name":"Software Beta","type":"aside","style":"note","content":[{"type":"paragraph","inlineContent":[{"text":"","type":"text"}]},{"inlineContent":[{"text":"Esta documentación contiene información preliminar sobre una API o tecnología en desarrollo. Esta información está sujeta a cambios, y todo software implementado en conformidad con esta documentación debe ser testeado con el software final del sistema operativo.","type":"text"}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"text":"Conoce más acerca del uso del ","type":"text"},{"type":"reference","identifier":"https:\/\/developer.apple.com\/es\/support\/beta-software\/","isActive":true},{"type":"text","text":"."}]}]}]}],"schemaVersion":{"minor":3,"major":0,"patch":0},"metadata":{"title":"Operadores avanzados"},"abstract":[{"text":"Define custom operators, perform bitwise operations, and use builder syntax.","type":"text"}],"identifier":{"interfaceLanguage":"swift","url":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/AdvancedOperators"},"references":{"https://developer.apple.com/es/support/beta-software/":{"identifier":"https:\/\/developer.apple.com\/es\/support\/beta-software\/","titleInlineContent":[{"text":"software beta de Apple","type":"text"}],"title":"software beta de Apple","url":"https:\/\/developer.apple.com\/es\/support\/beta-software\/","type":"link"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Protocols#Adoptando-Un-Protocolo-Mediante-Una-Implementaci%C3%B3n-Sintetizada":{"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Protocols#Adoptando-Un-Protocolo-Mediante-Una-Implementaci%C3%B3n-Sintetizada","url":"\/documentation\/the-swift-programming-language\/protocols#Adoptando-Un-Protocolo-Mediante-Una-Implementaci%C3%B3n-Sintetizada","title":"Adoptando Un Protocolo Mediante Una Implementación Sintetizada","kind":"section","abstract":[],"type":"topic"},"bitshiftSignedMinusFour":{"identifier":"bitshiftSignedMinusFour","variants":[{"traits":["2x","light"],"url":"\/images\/org.swift.tspl\/bitshiftSignedMinusFour@2x.png"},{"traits":["2x","dark"],"url":"\/images\/org.swift.tspl\/bitshiftSignedMinusFour~dark@2x.png"}],"alt":null,"type":"image"},"bitwiseAND":{"identifier":"bitwiseAND","variants":[{"traits":["2x","light"],"url":"\/images\/org.swift.tspl\/bitwiseAND@2x.png"},{"traits":["2x","dark"],"url":"\/images\/org.swift.tspl\/bitwiseAND~dark@2x.png"}],"alt":null,"type":"image"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/AdvancedOperators#Operadores-Bit-a-Bit-de-desplazamiento-a-la-izquierda-y-a-la-derecha":{"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/AdvancedOperators#Operadores-Bit-a-Bit-de-desplazamiento-a-la-izquierda-y-a-la-derecha","url":"\/documentation\/the-swift-programming-language\/advancedoperators#Operadores-Bit-a-Bit-de-desplazamiento-a-la-izquierda-y-a-la-derecha","title":"Operadores Bit a Bit de desplazamiento a la izquierda y a la derecha","kind":"section","abstract":[],"type":"topic"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/BasicOperators":{"url":"\/documentation\/the-swift-programming-language\/basicoperators","role":"article","identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/BasicOperators","type":"topic","title":"Operadores básicos","abstract":[{"type":"text","text":"Perform operations like assignment, arithmetic, and comparison."}],"kind":"article"},"bitshiftSignedMinusFourValue":{"identifier":"bitshiftSignedMinusFourValue","variants":[{"traits":["2x","light"],"url":"\/images\/org.swift.tspl\/bitshiftSignedMinusFourValue@2x.png"},{"traits":["2x","dark"],"url":"\/images\/org.swift.tspl\/bitshiftSignedMinusFourValue~dark@2x.png"}],"alt":null,"type":"image"},"overflowAddition":{"identifier":"overflowAddition","variants":[{"traits":["2x","light"],"url":"\/images\/org.swift.tspl\/overflowAddition@2x.png"},{"traits":["2x","dark"],"url":"\/images\/org.swift.tspl\/overflowAddition~dark@2x.png"}],"alt":null,"type":"image"},"vectorAddition":{"identifier":"vectorAddition","variants":[{"traits":["2x","light"],"url":"\/images\/org.swift.tspl\/vectorAddition@2x.png"},{"traits":["2x","dark"],"url":"\/images\/org.swift.tspl\/vectorAddition~dark@2x.png"}],"alt":null,"type":"image"},"bitshiftSignedAddition":{"identifier":"bitshiftSignedAddition","variants":[{"traits":["2x","light"],"url":"\/images\/org.swift.tspl\/bitshiftSignedAddition@2x.png"},{"traits":["2x","dark"],"url":"\/images\/org.swift.tspl\/bitshiftSignedAddition~dark@2x.png"}],"alt":null,"type":"image"},"bitshiftUnsigned":{"identifier":"bitshiftUnsigned","variants":[{"traits":["2x","light"],"url":"\/images\/org.swift.tspl\/bitshiftUnsigned@2x.png"},{"traits":["2x","dark"],"url":"\/images\/org.swift.tspl\/bitshiftUnsigned~dark@2x.png"}],"alt":null,"type":"image"},"overflowSignedSubtraction":{"identifier":"overflowSignedSubtraction","variants":[{"traits":["2x","light"],"url":"\/images\/org.swift.tspl\/overflowSignedSubtraction@2x.png"},{"traits":["2x","dark"],"url":"\/images\/org.swift.tspl\/overflowSignedSubtraction~dark@2x.png"}],"alt":null,"type":"image"},"bitshiftSignedFour":{"identifier":"bitshiftSignedFour","variants":[{"traits":["2x","light"],"url":"\/images\/org.swift.tspl\/bitshiftSignedFour@2x.png"},{"traits":["2x","dark"],"url":"\/images\/org.swift.tspl\/bitshiftSignedFour~dark@2x.png"}],"alt":null,"type":"image"},"bitshiftSigned":{"identifier":"bitshiftSigned","variants":[{"traits":["2x","light"],"url":"\/images\/org.swift.tspl\/bitshiftSigned@2x.png"},{"traits":["2x","dark"],"url":"\/images\/org.swift.tspl\/bitshiftSigned~dark@2x.png"}],"alt":null,"type":"image"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/LexicalStructure#Operadores":{"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/LexicalStructure#Operadores","url":"\/documentation\/the-swift-programming-language\/lexicalstructure#Operadores","title":"Operadores","kind":"section","abstract":[],"type":"topic"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language":{"url":"\/documentation\/the-swift-programming-language","kind":"article","type":"topic","title":"The Swift Programming Language (6)","role":"collection","identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language","abstract":[]},"bitwiseXOR":{"identifier":"bitwiseXOR","variants":[{"traits":["2x","light"],"url":"\/images\/org.swift.tspl\/bitwiseXOR@2x.png"},{"traits":["2x","dark"],"url":"\/images\/org.swift.tspl\/bitwiseXOR~dark@2x.png"}],"alt":null,"type":"image"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Declarations#Declaraci%C3%B3n-de-Operadores":{"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Declarations#Declaraci%C3%B3n-de-Operadores","url":"\/documentation\/the-swift-programming-language\/declarations#Declaraci%C3%B3n-de-Operadores","title":"Declaración de Operadores","kind":"section","abstract":[],"type":"topic"},"bitwiseOR":{"identifier":"bitwiseOR","variants":[{"traits":["2x","light"],"url":"\/images\/org.swift.tspl\/bitwiseOR@2x.png"},{"traits":["2x","dark"],"url":"\/images\/org.swift.tspl\/bitwiseOR~dark@2x.png"}],"alt":null,"type":"image"},"https://developer.apple.com/documentation/swift/operator_declarations":{"identifier":"https:\/\/developer.apple.com\/documentation\/swift\/operator_declarations","titleInlineContent":[{"text":"Operator Declarations","type":"text"}],"title":"Operator Declarations","url":"https:\/\/developer.apple.com\/documentation\/swift\/operator_declarations","type":"link"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/AdvancedOperators#Precedencia-y-asociatividad":{"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/AdvancedOperators#Precedencia-y-asociatividad","url":"\/documentation\/the-swift-programming-language\/advancedoperators#Precedencia-y-asociatividad","title":"Precedencia y asociatividad","kind":"section","abstract":[],"type":"topic"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Attributes#resultBuilder":{"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Attributes#resultBuilder","url":"\/documentation\/the-swift-programming-language\/attributes#resultBuilder","title":"resultBuilder","kind":"section","abstract":[],"type":"topic"},"bitwiseNOT":{"identifier":"bitwiseNOT","variants":[{"traits":["2x","light"],"url":"\/images\/org.swift.tspl\/bitwiseNOT@2x.png"},{"traits":["2x","dark"],"url":"\/images\/org.swift.tspl\/bitwiseNOT~dark@2x.png"}],"alt":null,"type":"image"},"overflowUnsignedSubtraction":{"identifier":"overflowUnsignedSubtraction","variants":[{"traits":["2x","light"],"url":"\/images\/org.swift.tspl\/overflowUnsignedSubtraction@2x.png"},{"traits":["2x","dark"],"url":"\/images\/org.swift.tspl\/overflowUnsignedSubtraction~dark@2x.png"}],"alt":null,"type":"image"}}}