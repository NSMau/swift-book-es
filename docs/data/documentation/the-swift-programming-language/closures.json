<<<<<<< HEAD
{"hierarchy":{"paths":[["doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language"]]},"identifier":{"interfaceLanguage":"swift","url":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Closures"},"sections":[],"kind":"article","abstract":[{"text":"Group code that executes together, without creating a named function.","type":"text"}],"schemaVersion":{"patch":0,"major":0,"minor":3},"metadata":{"title":"Clausuras"},"primaryContentSections":[{"kind":"content","content":[{"inlineContent":[{"type":"emphasis","inlineContent":[{"text":"Closures","type":"text"}]},{"type":"text","text":" are self-contained blocks of functionality"},{"text":" ","type":"text"},{"type":"text","text":"that can be passed around and used in your code."},{"text":" ","type":"text"},{"type":"text","text":"Closures in Swift are similar to blocks in C and Objective-C"},{"type":"text","text":" "},{"type":"text","text":"and to lambdas in other programming languages."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Closures can capture and store references to any constants and variables"},{"text":" ","type":"text"},{"text":"from the context in which they’re defined.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"This is known as "},{"inlineContent":[{"type":"text","text":"closing over"}],"type":"emphasis"},{"type":"text","text":" those constants and variables."},{"text":" ","type":"text"},{"type":"text","text":"Swift handles all of the memory management of capturing for you."}]},{"name":"Note","content":[{"type":"paragraph","inlineContent":[{"text":"Don’t worry if you aren’t familiar with the concept of capturing.","type":"text"},{"type":"text","text":" "},{"text":"It’s explained in detail below in ","type":"text"},{"isActive":true,"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Closures#Captura-de-valores","type":"reference"},{"type":"text","text":"."}]}],"type":"aside","style":"note"},{"inlineContent":[{"text":"Global and nested functions, as introduced in ","type":"text"},{"type":"reference","isActive":true,"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Functions"},{"type":"text","text":","},{"text":" ","type":"text"},{"type":"text","text":"are actually special cases of closures."},{"text":" ","type":"text"},{"text":"Closures take one of three forms:","type":"text"}],"type":"paragraph"},{"items":[{"content":[{"inlineContent":[{"text":"Global functions are closures that have a name","type":"text"},{"text":" ","type":"text"},{"text":"and don’t capture any values.","type":"text"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"Nested functions are closures that have a name","type":"text"},{"text":" ","type":"text"},{"text":"and can capture values from their enclosing function.","type":"text"}]}]},{"content":[{"inlineContent":[{"text":"Closure expressions are unnamed closures written in a lightweight syntax","type":"text"},{"type":"text","text":" "},{"type":"text","text":"that can capture values from their surrounding context."}],"type":"paragraph"}]}],"type":"unorderedList"},{"inlineContent":[{"text":"Swift’s closure expressions have a clean, clear style,","type":"text"},{"type":"text","text":" "},{"type":"text","text":"with optimizations that encourage brief, clutter-free syntax in common scenarios."},{"text":" ","type":"text"},{"text":"These optimizations include:","type":"text"}],"type":"paragraph"},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"Inferring parameter and return value types from context","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Implicit returns from single-expression closures"}]}]},{"content":[{"inlineContent":[{"text":"Shorthand argument names","type":"text"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"Trailing closure syntax","type":"text"}]}]}]},{"level":2,"anchor":"Expresiones-clausura","type":"heading","text":"Expresiones clausura"},{"inlineContent":[{"type":"text","text":"Nested functions, as introduced in "},{"type":"text","text":"doc:Functions#Funciones-anidadas"},{"text":",","type":"text"},{"type":"text","text":" "},{"text":"are a convenient means of naming and defining self-contained blocks of code","type":"text"},{"type":"text","text":" "},{"text":"as part of a larger function.","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"However, it’s sometimes useful to write shorter versions of function-like constructs"},{"type":"text","text":" "},{"type":"text","text":"without a full declaration and name."},{"type":"text","text":" "},{"type":"text","text":"This is particularly true when you work with functions or methods that take functions"},{"text":" ","type":"text"},{"type":"text","text":"as one or more of their arguments."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"emphasis","inlineContent":[{"type":"text","text":"Closure expressions"}]},{"type":"text","text":" are a way to write inline closures in a brief, focused syntax."},{"text":" ","type":"text"},{"text":"Closure expressions provide several syntax optimizations","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"for writing closures in a shortened form without loss of clarity or intent."},{"type":"text","text":" "},{"text":"The closure expression examples below illustrate these optimizations","type":"text"},{"type":"text","text":" "},{"type":"text","text":"by refining a single example of the "},{"code":"sorted(by:)","type":"codeVoice"},{"type":"text","text":" method over several iterations,"},{"type":"text","text":" "},{"type":"text","text":"each of which expresses the same functionality in a more succinct way."}]},{"type":"heading","text":"El método sorted","anchor":"El-m%C3%A9todo-sorted","level":3},{"type":"paragraph","inlineContent":[{"type":"text","text":"Swift’s standard library provides a method called "},{"code":"sorted(by:)","type":"codeVoice"},{"text":",","type":"text"},{"text":" ","type":"text"},{"text":"which sorts an array of values of a known type,","type":"text"},{"type":"text","text":" "},{"text":"based on the output of a sorting closure that you provide.","type":"text"},{"type":"text","text":" "},{"text":"Once it completes the sorting process,","type":"text"},{"text":" ","type":"text"},{"text":"the ","type":"text"},{"type":"codeVoice","code":"sorted(by:)"},{"type":"text","text":" method returns a new array of the same type and size as the old one,"},{"text":" ","type":"text"},{"type":"text","text":"with its elements in the correct sorted order."},{"text":" ","type":"text"},{"type":"text","text":"The original array isn’t modified by the "},{"type":"codeVoice","code":"sorted(by:)"},{"type":"text","text":" method."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The closure expression examples below use the "},{"type":"codeVoice","code":"sorted(by:)"},{"text":" method","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"to sort an array of "},{"code":"String","type":"codeVoice"},{"text":" values in reverse alphabetical order.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"Here’s the initial array to be sorted:"}]},{"syntax":"swift","code":["let names = [\"Chris\", \"Alex\", \"Ewa\", \"Barry\", \"Daniella\"]"],"type":"codeListing"},{"type":"paragraph","inlineContent":[{"text":"The ","type":"text"},{"type":"codeVoice","code":"sorted(by:)"},{"text":" method accepts a closure that takes two arguments","type":"text"},{"type":"text","text":" "},{"text":"of the same type as the array’s contents,","type":"text"},{"text":" ","type":"text"},{"text":"and returns a ","type":"text"},{"type":"codeVoice","code":"Bool"},{"type":"text","text":" value to say whether the first value should appear"},{"text":" ","type":"text"},{"text":"before or after the second value once the values are sorted.","type":"text"},{"text":" ","type":"text"},{"text":"The sorting closure needs to return ","type":"text"},{"code":"true","type":"codeVoice"},{"type":"text","text":" "},{"text":"if the first value should appear ","type":"text"},{"inlineContent":[{"text":"before","type":"text"}],"type":"emphasis"},{"type":"text","text":" the second value,"},{"text":" ","type":"text"},{"type":"text","text":"and "},{"type":"codeVoice","code":"false"},{"text":" otherwise.","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"This example is sorting an array of ","type":"text"},{"type":"codeVoice","code":"String"},{"type":"text","text":" values,"},{"type":"text","text":" "},{"type":"text","text":"and so the sorting closure needs to be a function of type "},{"type":"codeVoice","code":"(String, String) -> Bool"},{"text":".","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"One way to provide the sorting closure is to write a normal function of the correct type,"},{"text":" ","type":"text"},{"text":"and to pass it in as an argument to the ","type":"text"},{"type":"codeVoice","code":"sorted(by:)"},{"type":"text","text":" method:"}]},{"type":"codeListing","syntax":"swift","code":["func backward(_ s1: String, _ s2: String) -> Bool {","    return s1 > s2","}","var reversedNames = names.sorted(by: backward)","\/\/ reversedNames is equal to [\"Ewa\", \"Daniella\", \"Chris\", \"Barry\", \"Alex\"]"]},{"inlineContent":[{"text":"If the first string (","type":"text"},{"code":"s1","type":"codeVoice"},{"text":") is greater than the second string (","type":"text"},{"type":"codeVoice","code":"s2"},{"type":"text","text":"),"},{"type":"text","text":" "},{"text":"the ","type":"text"},{"type":"codeVoice","code":"backward(_:_:)"},{"type":"text","text":" function will return "},{"type":"codeVoice","code":"true"},{"text":",","type":"text"},{"text":" ","type":"text"},{"text":"indicating that ","type":"text"},{"type":"codeVoice","code":"s1"},{"type":"text","text":" should appear before "},{"type":"codeVoice","code":"s2"},{"type":"text","text":" in the sorted array."},{"text":" ","type":"text"},{"text":"For characters in strings,","type":"text"},{"text":" ","type":"text"},{"text":"“greater than” means “appears later in the alphabet than”.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"This means that the letter "},{"type":"codeVoice","code":"\"B\""},{"type":"text","text":" is “greater than” the letter "},{"type":"codeVoice","code":"\"A\""},{"type":"text","text":","},{"text":" ","type":"text"},{"type":"text","text":"and the string "},{"code":"\"Tom\"","type":"codeVoice"},{"type":"text","text":" is greater than the string "},{"code":"\"Tim\"","type":"codeVoice"},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"This gives a reverse alphabetical sort,"},{"text":" ","type":"text"},{"type":"text","text":"with "},{"code":"\"Barry\"","type":"codeVoice"},{"text":" being placed before ","type":"text"},{"type":"codeVoice","code":"\"Alex\""},{"text":", and so on.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"However, this is a rather long-winded way to write"},{"text":" ","type":"text"},{"type":"text","text":"what is essentially a single-expression function ("},{"code":"a > b","type":"codeVoice"},{"text":").","type":"text"},{"type":"text","text":" "},{"type":"text","text":"In this example, it would be preferable to write the sorting closure inline,"},{"type":"text","text":" "},{"text":"using closure expression syntax.","type":"text"}],"type":"paragraph"},{"level":3,"anchor":"Sintaxis-de-expresiones-clausura","type":"heading","text":"Sintaxis de expresiones clausura"},{"inlineContent":[{"type":"text","text":"Closure expression syntax has the following general form:"}],"type":"paragraph"},{"syntax":"swift","code":["{ (<#parameters#>) -> <#return type#> in","   <#statements#>","}"],"type":"codeListing"},{"inlineContent":[{"text":"The ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"parameters","type":"text"}]},{"text":" in closure expression syntax","type":"text"},{"type":"text","text":" "},{"text":"can be in-out parameters,","type":"text"},{"type":"text","text":" "},{"type":"text","text":"but they can’t have a default value."},{"type":"text","text":" "},{"type":"text","text":"Variadic parameters can be used if you name the variadic parameter."},{"text":" ","type":"text"},{"type":"text","text":"Tuples can also be used as parameter types and return types."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"The example below shows a closure expression version of the "},{"code":"backward(_:_:)","type":"codeVoice"},{"type":"text","text":" function"},{"text":" ","type":"text"},{"text":"from above:","type":"text"}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["reversedNames = names.sorted(by: { (s1: String, s2: String) -> Bool in","    return s1 > s2","})"]},{"inlineContent":[{"type":"text","text":"Note that the declaration of parameters and return type for this inline closure"},{"type":"text","text":" "},{"type":"text","text":"is identical to the declaration from the "},{"code":"backward(_:_:)","type":"codeVoice"},{"text":" function.","type":"text"},{"type":"text","text":" "},{"text":"In both cases, it’s written as ","type":"text"},{"code":"(s1: String, s2: String) -> Bool","type":"codeVoice"},{"type":"text","text":"."},{"type":"text","text":" "},{"text":"However, for the inline closure expression,","type":"text"},{"text":" ","type":"text"},{"text":"the parameters and return type are written ","type":"text"},{"inlineContent":[{"type":"text","text":"inside"}],"type":"emphasis"},{"type":"text","text":" the curly braces,"},{"text":" ","type":"text"},{"type":"text","text":"not outside of them."}],"type":"paragraph"},{"inlineContent":[{"text":"The start of the closure’s body is introduced by the ","type":"text"},{"code":"in","type":"codeVoice"},{"text":" keyword.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"This keyword indicates that"},{"type":"text","text":" "},{"type":"text","text":"the definition of the closure’s parameters and return type has finished,"},{"type":"text","text":" "},{"type":"text","text":"and the body of the closure is about to begin."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Because the body of the closure is so short,"},{"text":" ","type":"text"},{"type":"text","text":"it can even be written on a single line:"}]},{"code":["reversedNames = names.sorted(by: { (s1: String, s2: String) -> Bool in return s1 > s2 } )"],"syntax":"swift","type":"codeListing"},{"type":"paragraph","inlineContent":[{"type":"text","text":"This illustrates that the overall call to the "},{"type":"codeVoice","code":"sorted(by:)"},{"text":" method has remained the same.","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"A pair of parentheses still wrap the entire argument for the method."},{"type":"text","text":" "},{"text":"However, that argument is now an inline closure.","type":"text"}]},{"anchor":"Inferencia-de-tipos-a-partir-del-contexto","type":"heading","text":"Inferencia de tipos a partir del contexto","level":3},{"inlineContent":[{"type":"text","text":"Because the sorting closure is passed as an argument to a method,"},{"type":"text","text":" "},{"type":"text","text":"Swift can infer the types of its parameters"},{"type":"text","text":" "},{"type":"text","text":"and the type of the value it returns."},{"text":" ","type":"text"},{"text":"The ","type":"text"},{"code":"sorted(by:)","type":"codeVoice"},{"text":" method is being called on an array of strings,","type":"text"},{"type":"text","text":" "},{"type":"text","text":"so its argument must be a function of type "},{"code":"(String, String) -> Bool","type":"codeVoice"},{"type":"text","text":"."},{"type":"text","text":" "},{"text":"This means that the ","type":"text"},{"type":"codeVoice","code":"(String, String)"},{"text":" and ","type":"text"},{"type":"codeVoice","code":"Bool"},{"type":"text","text":" types don’t need to be written"},{"text":" ","type":"text"},{"type":"text","text":"as part of the closure expression’s definition."},{"type":"text","text":" "},{"type":"text","text":"Because all of the types can be inferred,"},{"type":"text","text":" "},{"type":"text","text":"the return arrow ("},{"code":"->","type":"codeVoice"},{"text":") and the parentheses around the names of the parameters","type":"text"},{"type":"text","text":" "},{"type":"text","text":"can also be omitted:"}],"type":"paragraph"},{"code":["reversedNames = names.sorted(by: { s1, s2 in return s1 > s2 } )"],"syntax":"swift","type":"codeListing"},{"type":"paragraph","inlineContent":[{"type":"text","text":"It’s always possible to infer the parameter types and return type"},{"type":"text","text":" "},{"type":"text","text":"when passing a closure to a function or method as an inline closure expression."},{"type":"text","text":" "},{"type":"text","text":"As a result, you never need to write an inline closure in its fullest form"},{"text":" ","type":"text"},{"type":"text","text":"when the closure is used as a function or method argument."}]},{"inlineContent":[{"type":"text","text":"Nonetheless, you can still make the types explicit if you wish,"},{"text":" ","type":"text"},{"type":"text","text":"and doing so is encouraged if it avoids ambiguity for readers of your code."},{"type":"text","text":" "},{"text":"In the case of the ","type":"text"},{"code":"sorted(by:)","type":"codeVoice"},{"type":"text","text":" method,"},{"type":"text","text":" "},{"text":"the purpose of the closure is clear from the fact that sorting is taking place,","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"and it’s safe for a reader to assume that"},{"type":"text","text":" "},{"type":"text","text":"the closure is likely to be working with "},{"code":"String","type":"codeVoice"},{"type":"text","text":" values,"},{"type":"text","text":" "},{"text":"because it’s assisting with the sorting of an array of strings.","type":"text"}],"type":"paragraph"},{"text":"Devolución implícita desde clausuras de una sola expresión","level":3,"anchor":"Devoluci%C3%B3n-impl%C3%ADcita-desde-clausuras-de-una-sola-expresi%C3%B3n","type":"heading"},{"type":"paragraph","inlineContent":[{"text":"Single-expression closures can implicitly return the result of their single expression","type":"text"},{"type":"text","text":" "},{"text":"by omitting the ","type":"text"},{"code":"return","type":"codeVoice"},{"type":"text","text":" keyword from their declaration,"},{"text":" ","type":"text"},{"type":"text","text":"as in this version of the previous example:"}]},{"type":"codeListing","syntax":"swift","code":["reversedNames = names.sorted(by: { s1, s2 in s1 > s2 } )"]},{"type":"paragraph","inlineContent":[{"text":"Here, the function type of the ","type":"text"},{"code":"sorted(by:)","type":"codeVoice"},{"type":"text","text":" method’s argument"},{"text":" ","type":"text"},{"text":"makes it clear that a ","type":"text"},{"type":"codeVoice","code":"Bool"},{"text":" value must be returned by the closure.","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"Because the closure’s body contains a single expression ("},{"type":"codeVoice","code":"s1 > s2"},{"text":")","type":"text"},{"text":" ","type":"text"},{"text":"that returns a ","type":"text"},{"code":"Bool","type":"codeVoice"},{"text":" value,","type":"text"},{"text":" ","type":"text"},{"text":"there’s no ambiguity, and the ","type":"text"},{"code":"return","type":"codeVoice"},{"type":"text","text":" keyword can be omitted."}]},{"type":"heading","text":"Nombres de argumentos concisos","anchor":"Nombres-de-argumentos-concisos","level":3},{"inlineContent":[{"text":"Swift automatically provides shorthand argument names to inline closures,","type":"text"},{"text":" ","type":"text"},{"text":"which can be used to refer to the values of the closure’s arguments","type":"text"},{"type":"text","text":" "},{"text":"by the names ","type":"text"},{"code":"$0","type":"codeVoice"},{"type":"text","text":", "},{"code":"$1","type":"codeVoice"},{"text":", ","type":"text"},{"code":"$2","type":"codeVoice"},{"type":"text","text":", and so on."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"If you use these shorthand argument names within your closure expression,"},{"type":"text","text":" "},{"text":"you can omit the closure’s argument list from its definition.","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"The type of the shorthand argument names"},{"type":"text","text":" "},{"type":"text","text":"is inferred from the expected function type,"},{"text":" ","type":"text"},{"type":"text","text":"and the highest numbered shorthand argument you use"},{"text":" ","type":"text"},{"text":"determines the number of arguments that the closure takes.","type":"text"},{"type":"text","text":" "},{"text":"The ","type":"text"},{"type":"codeVoice","code":"in"},{"type":"text","text":" keyword can also be omitted,"},{"text":" ","type":"text"},{"text":"because the closure expression is made up entirely of its body:","type":"text"}]},{"type":"codeListing","syntax":"swift","code":["reversedNames = names.sorted(by: { $0 > $1 } )"]},{"inlineContent":[{"text":"Here, ","type":"text"},{"type":"codeVoice","code":"$0"},{"text":" and ","type":"text"},{"code":"$1","type":"codeVoice"},{"type":"text","text":" refer to the closure’s first and second "},{"type":"codeVoice","code":"String"},{"text":" arguments.","type":"text"},{"text":" ","type":"text"},{"text":"Because ","type":"text"},{"type":"codeVoice","code":"$1"},{"text":" is the shorthand argument with highest number,","type":"text"},{"type":"text","text":" "},{"text":"the closure is understood to take two arguments.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"Because the "},{"code":"sorted(by:)","type":"codeVoice"},{"type":"text","text":" function here expects a closure"},{"type":"text","text":" "},{"type":"text","text":"whose arguments are both strings,"},{"text":" ","type":"text"},{"text":"the shorthand arguments ","type":"text"},{"type":"codeVoice","code":"$0"},{"text":" and ","type":"text"},{"code":"$1","type":"codeVoice"},{"text":" are both of type ","type":"text"},{"code":"String","type":"codeVoice"},{"text":".","type":"text"}],"type":"paragraph"},{"text":"Métodos operadores","anchor":"M%C3%A9todos-operadores","type":"heading","level":3},{"type":"paragraph","inlineContent":[{"type":"text","text":"There’s actually an even "},{"inlineContent":[{"type":"text","text":"shorter"}],"type":"emphasis"},{"type":"text","text":" way to write the closure expression above."},{"text":" ","type":"text"},{"type":"text","text":"Swift’s "},{"code":"String","type":"codeVoice"},{"text":" type defines its string-specific implementation of","type":"text"},{"text":" ","type":"text"},{"text":"the greater-than operator (","type":"text"},{"type":"codeVoice","code":">"},{"text":")","type":"text"},{"type":"text","text":" "},{"text":"as a method that has two parameters of type ","type":"text"},{"type":"codeVoice","code":"String"},{"text":",","type":"text"},{"type":"text","text":" "},{"text":"and returns a value of type ","type":"text"},{"code":"Bool","type":"codeVoice"},{"text":".","type":"text"},{"text":" ","type":"text"},{"text":"This exactly matches the method type needed by the ","type":"text"},{"type":"codeVoice","code":"sorted(by:)"},{"text":" method.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"Therefore, you can simply pass in the greater-than operator,"},{"text":" ","type":"text"},{"type":"text","text":"and Swift will infer that you want to use its string-specific implementation:"}]},{"syntax":"swift","type":"codeListing","code":["reversedNames = names.sorted(by: >)"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"For more about operator methods, see "},{"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/AdvancedOperators#M%C3%A9todos-operadores","type":"reference","isActive":true},{"type":"text","text":"."}]},{"anchor":"Clausuras-colgantes","level":2,"type":"heading","text":"Clausuras colgantes"},{"type":"paragraph","inlineContent":[{"text":"If you need to pass a closure expression to a function as the function’s final argument","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"and the closure expression is long,"},{"type":"text","text":" "},{"text":"it can be useful to write it as a ","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"trailing closure"}]},{"type":"text","text":" instead."},{"type":"text","text":" "},{"text":"You write a trailing closure after the function call’s parentheses,","type":"text"},{"type":"text","text":" "},{"type":"text","text":"even though the trailing closure is still an argument to the function."},{"type":"text","text":" "},{"text":"When you use the trailing closure syntax,","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"you don’t write the argument label for the first closure"},{"type":"text","text":" "},{"type":"text","text":"as part of the function call."},{"type":"text","text":" "},{"type":"text","text":"A function call can include multiple trailing closures;"},{"text":" ","type":"text"},{"type":"text","text":"however, the first few examples below use a single trailing closure."}]},{"type":"codeListing","code":["func someFunctionThatTakesAClosure(closure: () -> Void) {","    \/\/ function body goes here","}","","\/\/ Here's how you call this function without using a trailing closure:","","someFunctionThatTakesAClosure(closure: {","    \/\/ closure's body goes here","})","","\/\/ Here's how you call this function with a trailing closure instead:","","someFunctionThatTakesAClosure() {","    \/\/ trailing closure's body goes here","}"],"syntax":"swift"},{"type":"paragraph","inlineContent":[{"type":"text","text":"The string-sorting closure from the "},{"type":"reference","isActive":true,"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Closures#Sintaxis-de-expresiones-clausura"},{"type":"text","text":" section above"},{"type":"text","text":" "},{"text":"can be written outside of the ","type":"text"},{"type":"codeVoice","code":"sorted(by:)"},{"text":" method’s parentheses as a trailing closure:","type":"text"}]},{"syntax":"swift","code":["reversedNames = names.sorted() { $0 > $1 }"],"type":"codeListing"},{"type":"paragraph","inlineContent":[{"type":"text","text":"If a closure expression is provided as the function’s or method’s only argument"},{"text":" ","type":"text"},{"type":"text","text":"and you provide that expression as a trailing closure,"},{"type":"text","text":" "},{"text":"you don’t need to write a pair of parentheses ","type":"text"},{"type":"codeVoice","code":"()"},{"type":"text","text":" "},{"text":"after the function or method’s name when you call the function:","type":"text"}]},{"type":"codeListing","syntax":"swift","code":["reversedNames = names.sorted { $0 > $1 }"]},{"inlineContent":[{"type":"text","text":"Trailing closures are most useful when the closure is sufficiently long that"},{"text":" ","type":"text"},{"text":"it isn’t possible to write it inline on a single line.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"As an example, Swift’s "},{"code":"Array","type":"codeVoice"},{"text":" type has a ","type":"text"},{"type":"codeVoice","code":"map(_:)"},{"type":"text","text":" method,"},{"text":" ","type":"text"},{"text":"which takes a closure expression as its single argument.","type":"text"},{"text":" ","type":"text"},{"text":"The closure is called once for each item in the array,","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"and returns an alternative mapped value (possibly of some other type) for that item."},{"type":"text","text":" "},{"text":"You specify","type":"text"},{"text":" ","type":"text"},{"text":"the nature of the mapping and the type of the returned value","type":"text"},{"type":"text","text":" "},{"text":"by writing code in the closure that you pass to ","type":"text"},{"code":"map(_:)","type":"codeVoice"},{"type":"text","text":"."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"After applying the provided closure to each array element,"},{"type":"text","text":" "},{"type":"text","text":"the "},{"type":"codeVoice","code":"map(_:)"},{"type":"text","text":" method returns a new array containing all of the new mapped values,"},{"type":"text","text":" "},{"text":"in the same order as their corresponding values in the original array.","type":"text"}]},{"inlineContent":[{"text":"Here’s how you can use the ","type":"text"},{"code":"map(_:)","type":"codeVoice"},{"text":" method with a trailing closure","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"to convert an array of "},{"type":"codeVoice","code":"Int"},{"type":"text","text":" values into an array of "},{"type":"codeVoice","code":"String"},{"type":"text","text":" values."},{"text":" ","type":"text"},{"type":"text","text":"The array "},{"type":"codeVoice","code":"[16, 58, 510]"},{"text":" is used to create the new array","type":"text"},{"type":"text","text":" "},{"type":"codeVoice","code":"[\"OneSix\", \"FiveEight\", \"FiveOneZero\"]"},{"type":"text","text":":"}],"type":"paragraph"},{"type":"codeListing","syntax":"swift","code":["let digitNames = [","    0: \"Zero\", 1: \"One\", 2: \"Two\",   3: \"Three\", 4: \"Four\",","    5: \"Five\", 6: \"Six\", 7: \"Seven\", 8: \"Eight\", 9: \"Nine\"","]","let numbers = [16, 58, 510]"]},{"type":"paragraph","inlineContent":[{"text":"The code above creates a dictionary of mappings between","type":"text"},{"type":"text","text":" "},{"text":"the integer digits and English-language versions of their names.","type":"text"},{"type":"text","text":" "},{"text":"It also defines an array of integers, ready to be converted into strings.","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"You can now use the ","type":"text"},{"type":"codeVoice","code":"numbers"},{"type":"text","text":" array to create an array of "},{"type":"codeVoice","code":"String"},{"text":" values,","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"by passing a closure expression to the array’s "},{"code":"map(_:)","type":"codeVoice"},{"text":" method as a trailing closure:","type":"text"}]},{"type":"codeListing","syntax":"swift","code":["let strings = numbers.map { (number) -> String in","    var number = number","    var output = \"\"","    repeat {","        output = digitNames[number % 10]! + output","        number \/= 10","    } while number > 0","    return output","}","\/\/ strings is inferred to be of type [String]","\/\/ its value is [\"OneSix\", \"FiveEight\", \"FiveOneZero\"]"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"code":"map(_:)","type":"codeVoice"},{"type":"text","text":" method calls the closure expression once for each item in the array."},{"text":" ","type":"text"},{"type":"text","text":"You don’t need to specify the type of the closure’s input parameter, "},{"type":"codeVoice","code":"number"},{"type":"text","text":","},{"text":" ","type":"text"},{"text":"because the type can be inferred from the values in the array to be mapped.","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"In this example,"},{"type":"text","text":" "},{"type":"text","text":"the variable "},{"code":"number","type":"codeVoice"},{"type":"text","text":" is initialized with the value of the closure’s "},{"code":"number","type":"codeVoice"},{"text":" parameter,","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"so that the value can be modified within the closure body."},{"text":" ","type":"text"},{"type":"text","text":"(The parameters to functions and closures are always constants.)"},{"text":" ","type":"text"},{"text":"The closure expression also specifies a return type of ","type":"text"},{"type":"codeVoice","code":"String"},{"type":"text","text":","},{"type":"text","text":" "},{"text":"to indicate the type that will be stored in the mapped output array.","type":"text"}]},{"inlineContent":[{"type":"text","text":"The closure expression builds a string called "},{"type":"codeVoice","code":"output"},{"text":" each time it’s called.","type":"text"},{"type":"text","text":" "},{"text":"It calculates the last digit of ","type":"text"},{"type":"codeVoice","code":"number"},{"type":"text","text":" by using the remainder operator ("},{"code":"number % 10","type":"codeVoice"},{"text":"),","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"and uses this digit to look up an appropriate string in the "},{"type":"codeVoice","code":"digitNames"},{"type":"text","text":" dictionary."},{"type":"text","text":" "},{"type":"text","text":"The closure can be used to create a string representation of any integer greater than zero."}],"type":"paragraph"},{"type":"aside","style":"note","name":"Note","content":[{"type":"paragraph","inlineContent":[{"text":"The call to the ","type":"text"},{"code":"digitNames","type":"codeVoice"},{"text":" dictionary’s subscript","type":"text"},{"type":"text","text":" "},{"type":"text","text":"is followed by an exclamation point ("},{"type":"codeVoice","code":"!"},{"type":"text","text":"),"},{"text":" ","type":"text"},{"type":"text","text":"because dictionary subscripts return an optional value"},{"type":"text","text":" "},{"type":"text","text":"to indicate that the dictionary lookup can fail if the key doesn’t exist."},{"type":"text","text":" "},{"text":"In the example above, it’s guaranteed that ","type":"text"},{"code":"number % 10","type":"codeVoice"},{"text":" ","type":"text"},{"text":"will always be a valid subscript key for the ","type":"text"},{"code":"digitNames","type":"codeVoice"},{"text":" dictionary,","type":"text"},{"text":" ","type":"text"},{"text":"and so an exclamation point is used to force-unwrap the ","type":"text"},{"type":"codeVoice","code":"String"},{"text":" value","type":"text"},{"type":"text","text":" "},{"text":"stored in the subscript’s optional return value.","type":"text"}]}]},{"inlineContent":[{"text":"The string retrieved from the ","type":"text"},{"type":"codeVoice","code":"digitNames"},{"type":"text","text":" dictionary"},{"type":"text","text":" "},{"type":"text","text":"is added to the "},{"type":"emphasis","inlineContent":[{"type":"text","text":"front"}]},{"type":"text","text":" of "},{"type":"codeVoice","code":"output"},{"type":"text","text":","},{"text":" ","type":"text"},{"text":"effectively building a string version of the number in reverse.","type":"text"},{"text":" ","type":"text"},{"text":"(The expression ","type":"text"},{"code":"number % 10","type":"codeVoice"},{"text":" gives a value of","type":"text"},{"type":"text","text":" "},{"type":"codeVoice","code":"6"},{"type":"text","text":" for "},{"code":"16","type":"codeVoice"},{"text":", ","type":"text"},{"code":"8","type":"codeVoice"},{"type":"text","text":" for "},{"type":"codeVoice","code":"58"},{"type":"text","text":", and "},{"code":"0","type":"codeVoice"},{"type":"text","text":" for "},{"type":"codeVoice","code":"510"},{"type":"text","text":".)"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"The "},{"type":"codeVoice","code":"number"},{"type":"text","text":" variable is then divided by "},{"type":"codeVoice","code":"10"},{"text":".","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"Because it’s an integer, it’s rounded down during the division,"},{"type":"text","text":" "},{"type":"text","text":"so "},{"type":"codeVoice","code":"16"},{"text":" becomes ","type":"text"},{"code":"1","type":"codeVoice"},{"text":", ","type":"text"},{"type":"codeVoice","code":"58"},{"text":" becomes ","type":"text"},{"code":"5","type":"codeVoice"},{"type":"text","text":", and "},{"code":"510","type":"codeVoice"},{"type":"text","text":" becomes "},{"type":"codeVoice","code":"51"},{"type":"text","text":"."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"The process is repeated until "},{"type":"codeVoice","code":"number"},{"text":" is equal to ","type":"text"},{"code":"0","type":"codeVoice"},{"type":"text","text":","},{"type":"text","text":" "},{"text":"at which point the ","type":"text"},{"type":"codeVoice","code":"output"},{"type":"text","text":" string is returned by the closure,"},{"text":" ","type":"text"},{"text":"and is added to the output array by the ","type":"text"},{"type":"codeVoice","code":"map(_:)"},{"type":"text","text":" method."}]},{"type":"paragraph","inlineContent":[{"text":"The use of trailing closure syntax in the example above","type":"text"},{"type":"text","text":" "},{"text":"neatly encapsulates the closure’s functionality","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"immediately after the function that closure supports,"},{"text":" ","type":"text"},{"type":"text","text":"without needing to wrap the entire closure within"},{"text":" ","type":"text"},{"type":"text","text":"the "},{"type":"codeVoice","code":"map(_:)"},{"type":"text","text":" method’s outer parentheses."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"If a function takes multiple closures,"},{"type":"text","text":" "},{"text":"you omit the argument label for the first trailing closure","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"and you label the remaining trailing closures."},{"text":" ","type":"text"},{"text":"For example,","type":"text"},{"type":"text","text":" "},{"type":"text","text":"the function below loads a picture for a photo gallery:"}]},{"type":"codeListing","syntax":"swift","code":["func loadPicture(from server: Server, completion: (Picture) -> Void, onFailure: () -> Void) {","    if let picture = download(\"photo.jpg\", from: server) {","        completion(picture)","    } else {","        onFailure()","    }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"When you call this function to load a picture,"},{"type":"text","text":" "},{"type":"text","text":"you provide two closures."},{"text":" ","type":"text"},{"type":"text","text":"The first closure is a completion handler"},{"type":"text","text":" "},{"type":"text","text":"that displays a picture after a successful download."},{"text":" ","type":"text"},{"text":"The second closure is an error handler","type":"text"},{"text":" ","type":"text"},{"text":"that displays an error to the user.","type":"text"}]},{"type":"codeListing","code":["loadPicture(from: someServer) { picture in","    someView.currentPicture = picture","} onFailure: {","    print(\"Couldn't download the next picture.\")","}"],"syntax":"swift"},{"type":"paragraph","inlineContent":[{"type":"text","text":"In this example,"},{"type":"text","text":" "},{"type":"text","text":"the "},{"code":"loadPicture(from:completion:onFailure:)","type":"codeVoice"},{"text":" function","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"dispatches its network task into the background,"},{"text":" ","type":"text"},{"text":"and calls one of the two completion handlers when the network task finishes.","type":"text"},{"type":"text","text":" "},{"text":"Writing the function this way lets you cleanly separate the code","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"that’s responsible for handling a network failure"},{"text":" ","type":"text"},{"text":"from the code that updates the user interface after a successful download,","type":"text"},{"type":"text","text":" "},{"type":"text","text":"instead of using just one closure that handles both circumstances."}]},{"name":"Note","style":"note","type":"aside","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Completion handlers can become hard to read,"},{"type":"text","text":" "},{"text":"especially when you have to nest multiple handlers.","type":"text"},{"type":"text","text":" "},{"text":"An alternate approach is to use asynchronous code,","type":"text"},{"type":"text","text":" "},{"type":"text","text":"as described in "},{"type":"reference","isActive":true,"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Concurrency"},{"type":"text","text":"."}]}]},{"type":"heading","level":2,"text":"Captura de valores","anchor":"Captura-de-valores"},{"inlineContent":[{"type":"text","text":"A closure can "},{"type":"emphasis","inlineContent":[{"type":"text","text":"capture"}]},{"type":"text","text":" constants and variables"},{"type":"text","text":" "},{"type":"text","text":"from the surrounding context in which it’s defined."},{"text":" ","type":"text"},{"text":"The closure can then refer to and modify","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"the values of those constants and variables from within its body,"},{"text":" ","type":"text"},{"type":"text","text":"even if the original scope that defined the constants and variables no longer exists."}],"type":"paragraph"},{"inlineContent":[{"text":"In Swift, the simplest form of a closure that can capture values is a nested function,","type":"text"},{"type":"text","text":" "},{"text":"written within the body of another function.","type":"text"},{"text":" ","type":"text"},{"text":"A nested function can capture any of its outer function’s arguments","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"and can also capture any constants and variables defined within the outer function."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Here’s an example of a function called "},{"code":"makeIncrementer","type":"codeVoice"},{"type":"text","text":","},{"text":" ","type":"text"},{"text":"which contains a nested function called ","type":"text"},{"code":"incrementer","type":"codeVoice"},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"The nested "},{"type":"codeVoice","code":"incrementer()"},{"text":" function captures two values,","type":"text"},{"type":"text","text":" "},{"code":"runningTotal","type":"codeVoice"},{"text":" and ","type":"text"},{"type":"codeVoice","code":"amount"},{"type":"text","text":","},{"text":" ","type":"text"},{"type":"text","text":"from its surrounding context."},{"type":"text","text":" "},{"text":"After capturing these values,","type":"text"},{"type":"text","text":" "},{"type":"codeVoice","code":"incrementer"},{"type":"text","text":" is returned by "},{"code":"makeIncrementer","type":"codeVoice"},{"text":" as a closure","type":"text"},{"type":"text","text":" "},{"type":"text","text":"that increments "},{"type":"codeVoice","code":"runningTotal"},{"text":" by ","type":"text"},{"type":"codeVoice","code":"amount"},{"type":"text","text":" each time it’s called."}]},{"type":"codeListing","code":["func makeIncrementer(forIncrement amount: Int) -> () -> Int {","    var runningTotal = 0","    func incrementer() -> Int {","        runningTotal += amount","        return runningTotal","    }","    return incrementer","}"],"syntax":"swift"},{"inlineContent":[{"type":"text","text":"The return type of "},{"type":"codeVoice","code":"makeIncrementer"},{"text":" is ","type":"text"},{"type":"codeVoice","code":"() -> Int"},{"text":".","type":"text"},{"type":"text","text":" "},{"type":"text","text":"This means that it returns a "},{"type":"emphasis","inlineContent":[{"text":"function","type":"text"}]},{"type":"text","text":", rather than a simple value."},{"type":"text","text":" "},{"text":"The function it returns has no parameters,","type":"text"},{"type":"text","text":" "},{"text":"and returns an ","type":"text"},{"type":"codeVoice","code":"Int"},{"type":"text","text":" value each time it’s called."},{"type":"text","text":" "},{"type":"text","text":"To learn how functions can return other functions,"},{"type":"text","text":" "},{"type":"text","text":"see "},{"type":"text","text":"doc:Functions#Tipos-de-funciones-como-tipos-de-devolución"},{"type":"text","text":"."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"The "},{"code":"makeIncrementer(forIncrement:)","type":"codeVoice"},{"type":"text","text":" function defines an integer variable called "},{"code":"runningTotal","type":"codeVoice"},{"text":",","type":"text"},{"text":" ","type":"text"},{"text":"to store the current running total of the incrementer that will be returned.","type":"text"},{"type":"text","text":" "},{"text":"This variable is initialized with a value of ","type":"text"},{"type":"codeVoice","code":"0"},{"text":".","type":"text"}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"type":"codeVoice","code":"makeIncrementer(forIncrement:)"},{"text":" function has a single ","type":"text"},{"type":"codeVoice","code":"Int"},{"type":"text","text":" parameter"},{"text":" ","type":"text"},{"text":"with an argument label of ","type":"text"},{"code":"forIncrement","type":"codeVoice"},{"type":"text","text":", and a parameter name of "},{"code":"amount","type":"codeVoice"},{"text":".","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"The argument value passed to this parameter specifies"},{"type":"text","text":" "},{"text":"how much ","type":"text"},{"type":"codeVoice","code":"runningTotal"},{"type":"text","text":" should be incremented by"},{"text":" ","type":"text"},{"type":"text","text":"each time the returned incrementer function is called."},{"type":"text","text":" "},{"type":"text","text":"The "},{"code":"makeIncrementer","type":"codeVoice"},{"type":"text","text":" function defines a nested function called "},{"code":"incrementer","type":"codeVoice"},{"type":"text","text":","},{"text":" ","type":"text"},{"text":"which performs the actual incrementing.","type":"text"},{"type":"text","text":" "},{"text":"This function simply adds ","type":"text"},{"type":"codeVoice","code":"amount"},{"type":"text","text":" to "},{"type":"codeVoice","code":"runningTotal"},{"type":"text","text":", and returns the result."}]},{"type":"paragraph","inlineContent":[{"text":"When considered in isolation,","type":"text"},{"type":"text","text":" "},{"text":"the nested ","type":"text"},{"code":"incrementer()","type":"codeVoice"},{"text":" function might seem unusual:","type":"text"}]},{"code":["func incrementer() -> Int {","    runningTotal += amount","    return runningTotal","}"],"type":"codeListing","syntax":"swift"},{"type":"paragraph","inlineContent":[{"text":"The ","type":"text"},{"code":"incrementer()","type":"codeVoice"},{"text":" function doesn’t have any parameters,","type":"text"},{"type":"text","text":" "},{"type":"text","text":"and yet it refers to "},{"type":"codeVoice","code":"runningTotal"},{"text":" and ","type":"text"},{"code":"amount","type":"codeVoice"},{"type":"text","text":" from within its function body."},{"text":" ","type":"text"},{"type":"text","text":"It does this by capturing a "},{"type":"emphasis","inlineContent":[{"type":"text","text":"reference"}]},{"type":"text","text":" to "},{"type":"codeVoice","code":"runningTotal"},{"type":"text","text":" and "},{"type":"codeVoice","code":"amount"},{"type":"text","text":" "},{"text":"from the surrounding function and using them within its own function body.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"Capturing by reference ensures that "},{"type":"codeVoice","code":"runningTotal"},{"text":" and ","type":"text"},{"type":"codeVoice","code":"amount"},{"type":"text","text":" don’t disappear"},{"type":"text","text":" "},{"type":"text","text":"when the call to "},{"type":"codeVoice","code":"makeIncrementer"},{"type":"text","text":" ends,"},{"text":" ","type":"text"},{"text":"and also ensures that ","type":"text"},{"code":"runningTotal","type":"codeVoice"},{"text":" is available","type":"text"},{"text":" ","type":"text"},{"text":"the next time the ","type":"text"},{"code":"incrementer","type":"codeVoice"},{"text":" function is called.","type":"text"}]},{"type":"aside","name":"Note","style":"note","content":[{"inlineContent":[{"type":"text","text":"As an optimization,"},{"type":"text","text":" "},{"type":"text","text":"Swift may instead capture and store a "},{"type":"emphasis","inlineContent":[{"type":"text","text":"copy"}]},{"text":" of a value","type":"text"},{"type":"text","text":" "},{"text":"if that value isn’t mutated by a closure,","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"and if the value isn’t mutated after the closure is created."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"text":"Swift also handles all memory management involved in disposing of","type":"text"},{"type":"text","text":" "},{"type":"text","text":"variables when they’re no longer needed."}]}]},{"type":"paragraph","inlineContent":[{"text":"Here’s an example of ","type":"text"},{"code":"makeIncrementer","type":"codeVoice"},{"type":"text","text":" in action:"}]},{"syntax":"swift","type":"codeListing","code":["let incrementByTen = makeIncrementer(forIncrement: 10)"]},{"type":"paragraph","inlineContent":[{"text":"This example sets a constant called ","type":"text"},{"type":"codeVoice","code":"incrementByTen"},{"text":" ","type":"text"},{"text":"to refer to an incrementer function that adds ","type":"text"},{"type":"codeVoice","code":"10"},{"text":" to","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"its "},{"code":"runningTotal","type":"codeVoice"},{"type":"text","text":" variable each time it’s called."},{"type":"text","text":" "},{"type":"text","text":"Calling the function multiple times shows this behavior in action:"}]},{"code":["incrementByTen()","\/\/ returns a value of 10","incrementByTen()","\/\/ returns a value of 20","incrementByTen()","\/\/ returns a value of 30"],"type":"codeListing","syntax":"swift"},{"type":"paragraph","inlineContent":[{"type":"text","text":"If you create a second incrementer,"},{"type":"text","text":" "},{"type":"text","text":"it will have its own stored reference to a new, separate "},{"type":"codeVoice","code":"runningTotal"},{"text":" variable:","type":"text"}]},{"code":["let incrementBySeven = makeIncrementer(forIncrement: 7)","incrementBySeven()","\/\/ returns a value of 7"],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"text":"Calling the original incrementer (","type":"text"},{"code":"incrementByTen","type":"codeVoice"},{"text":") again","type":"text"},{"type":"text","text":" "},{"type":"text","text":"continues to increment its own "},{"code":"runningTotal","type":"codeVoice"},{"text":" variable,","type":"text"},{"type":"text","text":" "},{"type":"text","text":"and doesn’t affect the variable captured by "},{"type":"codeVoice","code":"incrementBySeven"},{"text":":","type":"text"}],"type":"paragraph"},{"type":"codeListing","syntax":"swift","code":["incrementByTen()","\/\/ returns a value of 40"]},{"type":"aside","content":[{"inlineContent":[{"text":"If you assign a closure to a property of a class instance,","type":"text"},{"type":"text","text":" "},{"text":"and the closure captures that instance by referring to the instance or its members,","type":"text"},{"type":"text","text":" "},{"type":"text","text":"you will create a strong reference cycle between the closure and the instance."},{"text":" ","type":"text"},{"text":"Swift uses ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"capture lists","type":"text"}]},{"type":"text","text":" to break these strong reference cycles."},{"type":"text","text":" "},{"type":"text","text":"For more information, see "},{"isActive":true,"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/AutomaticReferenceCounting#Ciclos-de-referencias-fuertes-para-clausuras","type":"reference"},{"type":"text","text":"."}],"type":"paragraph"}],"name":"Note","style":"note"},{"text":"Las clausuras son tipos de referencia","anchor":"Las-clausuras-son-tipos-de-referencia","level":2,"type":"heading"},{"inlineContent":[{"text":"In the example above,","type":"text"},{"type":"text","text":" "},{"type":"codeVoice","code":"incrementBySeven"},{"type":"text","text":" and "},{"type":"codeVoice","code":"incrementByTen"},{"type":"text","text":" are constants,"},{"type":"text","text":" "},{"type":"text","text":"but the closures these constants refer to are still able to increment"},{"text":" ","type":"text"},{"type":"text","text":"the "},{"type":"codeVoice","code":"runningTotal"},{"type":"text","text":" variables that they have captured."},{"type":"text","text":" "},{"type":"text","text":"This is because functions and closures are "},{"inlineContent":[{"text":"reference types","type":"text"}],"type":"emphasis"},{"type":"text","text":"."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Whenever you assign a function or a closure to a constant or a variable,"},{"text":" ","type":"text"},{"type":"text","text":"you are actually setting that constant or variable to be"},{"text":" ","type":"text"},{"type":"text","text":"a "},{"type":"emphasis","inlineContent":[{"type":"text","text":"reference"}]},{"type":"text","text":" to the function or closure."},{"type":"text","text":" "},{"text":"In the example above,","type":"text"},{"type":"text","text":" "},{"type":"text","text":"it’s the choice of closure that "},{"type":"codeVoice","code":"incrementByTen"},{"text":" ","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"refers to"}]},{"text":" that’s constant,","type":"text"},{"type":"text","text":" "},{"text":"and not the contents of the closure itself.","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"This also means that if you assign a closure to two different constants or variables,","type":"text"},{"type":"text","text":" "},{"type":"text","text":"both of those constants or variables refer to the same closure."}]},{"code":["let alsoIncrementByTen = incrementByTen","alsoIncrementByTen()","\/\/ returns a value of 50","","incrementByTen()","\/\/ returns a value of 60"],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"type":"text","text":"The example above shows that calling "},{"code":"alsoIncrementByTen","type":"codeVoice"},{"type":"text","text":" "},{"text":"is the same as calling ","type":"text"},{"type":"codeVoice","code":"incrementByTen"},{"type":"text","text":"."},{"type":"text","text":" "},{"text":"Because both of them refer to the same closure,","type":"text"},{"type":"text","text":" "},{"text":"they both increment and return the same running total.","type":"text"}],"type":"paragraph"},{"level":2,"text":"Clausuras que escapan","anchor":"Clausuras-que-escapan","type":"heading"},{"inlineContent":[{"type":"text","text":"A closure is said to "},{"inlineContent":[{"type":"text","text":"escape"}],"type":"emphasis"},{"text":" a function","type":"text"},{"type":"text","text":" "},{"type":"text","text":"when the closure is passed as an argument to the function,"},{"text":" ","type":"text"},{"type":"text","text":"but is called after the function returns."},{"type":"text","text":" "},{"text":"When you declare a function that takes a closure as one of its parameters,","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"you can write "},{"code":"@escaping","type":"codeVoice"},{"type":"text","text":" before the parameter’s type"},{"text":" ","type":"text"},{"text":"to indicate that the closure is allowed to escape.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"One way that a closure can escape"},{"text":" ","type":"text"},{"type":"text","text":"is by being stored in a variable that’s defined outside the function."},{"type":"text","text":" "},{"text":"As an example,","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"many functions that start an asynchronous operation"},{"text":" ","type":"text"},{"type":"text","text":"take a closure argument as a completion handler."},{"type":"text","text":" "},{"text":"The function returns after it starts the operation,","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"but the closure isn’t called until the operation is completed —"},{"text":" ","type":"text"},{"text":"the closure needs to escape, to be called later.","type":"text"},{"type":"text","text":" "},{"text":"For example:","type":"text"}],"type":"paragraph"},{"code":["var completionHandlers: [() -> Void] = []","func someFunctionWithEscapingClosure(completionHandler: @escaping () -> Void) {","    completionHandlers.append(completionHandler)","}"],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"type":"text","text":"The "},{"code":"someFunctionWithEscapingClosure(_:)","type":"codeVoice"},{"text":" function takes a closure as its argument","type":"text"},{"type":"text","text":" "},{"text":"and adds it to an array that’s declared outside the function.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"If you didn’t mark the parameter of this function with "},{"code":"@escaping","type":"codeVoice"},{"type":"text","text":","},{"type":"text","text":" "},{"text":"you would get a compile-time error.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"An escaping closure that refers to ","type":"text"},{"type":"codeVoice","code":"self"},{"type":"text","text":" "},{"text":"needs special consideration if ","type":"text"},{"code":"self","type":"codeVoice"},{"text":" refers to an instance of a class.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"Capturing "},{"code":"self","type":"codeVoice"},{"type":"text","text":" in an escaping closure"},{"text":" ","type":"text"},{"type":"text","text":"makes it easy to accidentally create a strong reference cycle."},{"text":" ","type":"text"},{"type":"text","text":"For information about reference cycles,"},{"type":"text","text":" "},{"text":"see ","type":"text"},{"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/AutomaticReferenceCounting","isActive":true,"type":"reference"},{"type":"text","text":"."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"Normally, a closure captures variables implicitly"},{"type":"text","text":" "},{"text":"by using them in the body of the closure,","type":"text"},{"type":"text","text":" "},{"text":"but in this case you need to be explicit.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"If you want to capture "},{"code":"self","type":"codeVoice"},{"type":"text","text":","},{"type":"text","text":" "},{"text":"write ","type":"text"},{"code":"self","type":"codeVoice"},{"type":"text","text":" explicitly when you use it,"},{"type":"text","text":" "},{"text":"or include ","type":"text"},{"code":"self","type":"codeVoice"},{"text":" in the closure’s capture list.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"Writing "},{"type":"codeVoice","code":"self"},{"text":" explicitly lets you express your intent,","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"and reminds you to confirm that there isn’t a reference cycle."},{"type":"text","text":" "},{"type":"text","text":"For example, in the code below,"},{"text":" ","type":"text"},{"text":"the closure passed to ","type":"text"},{"type":"codeVoice","code":"someFunctionWithEscapingClosure(_:)"},{"type":"text","text":" "},{"type":"text","text":"refers to "},{"code":"self","type":"codeVoice"},{"text":" explicitly.","type":"text"},{"type":"text","text":" "},{"text":"In contrast, the closure passed to ","type":"text"},{"code":"someFunctionWithNonescapingClosure(_:)","type":"codeVoice"},{"text":" ","type":"text"},{"text":"is a nonescaping closure, which means it can refer to ","type":"text"},{"type":"codeVoice","code":"self"},{"type":"text","text":" implicitly."}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["func someFunctionWithNonescapingClosure(closure: () -> Void) {","    closure()","}","","class SomeClass {","    var x = 10","    func doSomething() {","        someFunctionWithEscapingClosure { self.x = 100 }","        someFunctionWithNonescapingClosure { x = 200 }","    }","}","","let instance = SomeClass()","instance.doSomething()","print(instance.x)","\/\/ Prints \"200\"","","completionHandlers.first?()","print(instance.x)","\/\/ Prints \"100\""]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Here’s a version of "},{"code":"doSomething()","type":"codeVoice"},{"type":"text","text":" that captures "},{"type":"codeVoice","code":"self"},{"type":"text","text":" "},{"text":"by including it in the closure’s capture list,","type":"text"},{"type":"text","text":" "},{"type":"text","text":"and then refers to "},{"code":"self","type":"codeVoice"},{"type":"text","text":" implicitly:"}]},{"syntax":"swift","code":["class SomeOtherClass {","    var x = 10","    func doSomething() {","        someFunctionWithEscapingClosure { [self] in x = 100 }","        someFunctionWithNonescapingClosure { x = 200 }","    }","}"],"type":"codeListing"},{"inlineContent":[{"type":"text","text":"If "},{"code":"self","type":"codeVoice"},{"type":"text","text":" is an instance of a structure or an enumeration,"},{"type":"text","text":" "},{"type":"text","text":"you can always refer to "},{"type":"codeVoice","code":"self"},{"text":" implicitly.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"However,"},{"text":" ","type":"text"},{"type":"text","text":"an escaping closure can’t capture a mutable reference to "},{"code":"self","type":"codeVoice"},{"type":"text","text":" "},{"type":"text","text":"when "},{"code":"self","type":"codeVoice"},{"text":" is an instance of a structure or an enumeration.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"Structures and enumerations don’t allow shared mutability,"},{"type":"text","text":" "},{"type":"text","text":"as discussed in "},{"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/ClassesAndStructures#Las-estructuras-y-las-enumeraciones-son-tipos-de-valor","isActive":true,"type":"reference"},{"text":".","type":"text"}],"type":"paragraph"},{"type":"codeListing","code":["struct SomeStruct {","    var x = 10","    mutating func doSomething() {","        someFunctionWithNonescapingClosure { x = 200 }  \/\/ Ok","        someFunctionWithEscapingClosure { x = 100 }     \/\/ Error","    }","}"],"syntax":"swift"},{"inlineContent":[{"text":"The call to the ","type":"text"},{"type":"codeVoice","code":"someFunctionWithEscapingClosure"},{"text":" function","type":"text"},{"text":" ","type":"text"},{"text":"in the example above is an error","type":"text"},{"text":" ","type":"text"},{"text":"because it’s inside a mutating method,","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"so "},{"type":"codeVoice","code":"self"},{"type":"text","text":" is mutable."},{"type":"text","text":" "},{"type":"text","text":"That violates the rule that escaping closures can’t capture"},{"type":"text","text":" "},{"type":"text","text":"a mutable reference to "},{"code":"self","type":"codeVoice"},{"text":" for structures.","type":"text"}],"type":"paragraph"},{"anchor":"Autoclausuras","level":2,"text":"Autoclausuras","type":"heading"},{"inlineContent":[{"type":"text","text":"An "},{"inlineContent":[{"type":"text","text":"autoclosure"}],"type":"emphasis"},{"type":"text","text":" is a closure that’s automatically created"},{"type":"text","text":" "},{"type":"text","text":"to wrap an expression that’s being passed as an argument to a function."},{"type":"text","text":" "},{"type":"text","text":"It doesn’t take any arguments,"},{"type":"text","text":" "},{"type":"text","text":"and when it’s called, it returns the value"},{"text":" ","type":"text"},{"type":"text","text":"of the expression that’s wrapped inside of it."},{"text":" ","type":"text"},{"type":"text","text":"This syntactic convenience lets you omit braces around a function’s parameter"},{"type":"text","text":" "},{"type":"text","text":"by writing a normal expression instead of an explicit closure."}],"type":"paragraph"},{"inlineContent":[{"text":"It’s common to ","type":"text"},{"inlineContent":[{"type":"text","text":"call"}],"type":"emphasis"},{"text":" functions that take autoclosures,","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"but it’s not common to "},{"type":"emphasis","inlineContent":[{"text":"implement","type":"text"}]},{"type":"text","text":" that kind of function."},{"text":" ","type":"text"},{"text":"For example,","type":"text"},{"type":"text","text":" "},{"type":"text","text":"the "},{"type":"codeVoice","code":"assert(condition:message:file:line:)"},{"text":" function","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"takes an autoclosure for its "},{"code":"condition","type":"codeVoice"},{"text":" and ","type":"text"},{"type":"codeVoice","code":"message"},{"type":"text","text":" parameters;"},{"type":"text","text":" "},{"text":"its ","type":"text"},{"type":"codeVoice","code":"condition"},{"text":" parameter is evaluated only in debug builds","type":"text"},{"type":"text","text":" "},{"text":"and its ","type":"text"},{"type":"codeVoice","code":"message"},{"type":"text","text":" parameter is evaluated only if "},{"type":"codeVoice","code":"condition"},{"type":"text","text":" is "},{"type":"codeVoice","code":"false"},{"text":".","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"An autoclosure lets you delay evaluation,","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"because the code inside isn’t run until you call the closure."},{"text":" ","type":"text"},{"type":"text","text":"Delaying evaluation is useful for code"},{"text":" ","type":"text"},{"type":"text","text":"that has side effects or is computationally expensive,"},{"type":"text","text":" "},{"text":"because it lets you control when that code is evaluated.","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"The code below shows how a closure delays evaluation."}],"type":"paragraph"},{"syntax":"swift","code":["var customersInLine = [\"Chris\", \"Alex\", \"Ewa\", \"Barry\", \"Daniella\"]","print(customersInLine.count)","\/\/ Prints \"5\"","","let customerProvider = { customersInLine.remove(at: 0) }","print(customersInLine.count)","\/\/ Prints \"5\"","","print(\"Now serving \\(customerProvider())!\")","\/\/ Prints \"Now serving Chris!\"","print(customersInLine.count)","\/\/ Prints \"4\""],"type":"codeListing"},{"inlineContent":[{"type":"text","text":"Even though the first element of the "},{"code":"customersInLine","type":"codeVoice"},{"type":"text","text":" array is removed"},{"type":"text","text":" "},{"text":"by the code inside the closure,","type":"text"},{"type":"text","text":" "},{"type":"text","text":"the array element isn’t removed until the closure is actually called."},{"text":" ","type":"text"},{"text":"If the closure is never called,","type":"text"},{"text":" ","type":"text"},{"text":"the expression inside the closure is never evaluated,","type":"text"},{"type":"text","text":" "},{"text":"which means the array element is never removed.","type":"text"},{"text":" ","type":"text"},{"text":"Note that the type of ","type":"text"},{"type":"codeVoice","code":"customerProvider"},{"type":"text","text":" isn’t "},{"type":"codeVoice","code":"String"},{"type":"text","text":" "},{"type":"text","text":"but "},{"type":"codeVoice","code":"() -> String"},{"text":" —","type":"text"},{"type":"text","text":" "},{"type":"text","text":"a function with no parameters that returns a string."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"text":"You get the same behavior of delayed evaluation","type":"text"},{"type":"text","text":" "},{"type":"text","text":"when you pass a closure as an argument to a function."}]},{"code":["\/\/ customersInLine is [\"Alex\", \"Ewa\", \"Barry\", \"Daniella\"]","func serve(customer customerProvider: () -> String) {","    print(\"Now serving \\(customerProvider())!\")","}","serve(customer: { customersInLine.remove(at: 0) } )","\/\/ Prints \"Now serving Alex!\""],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"type":"text","text":"The "},{"code":"serve(customer:)","type":"codeVoice"},{"text":" function in the listing above","type":"text"},{"type":"text","text":" "},{"text":"takes an explicit closure that returns a customer’s name.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"The version of "},{"code":"serve(customer:)","type":"codeVoice"},{"text":" below","type":"text"},{"text":" ","type":"text"},{"text":"performs the same operation but, instead of taking an explicit closure,","type":"text"},{"text":" ","type":"text"},{"text":"it takes an autoclosure","type":"text"},{"type":"text","text":" "},{"text":"by marking its parameter’s type with the ","type":"text"},{"type":"codeVoice","code":"@autoclosure"},{"text":" attribute.","type":"text"},{"text":" ","type":"text"},{"text":"Now you can call the function","type":"text"},{"type":"text","text":" "},{"type":"text","text":"as if it took a "},{"type":"codeVoice","code":"String"},{"type":"text","text":" argument instead of a closure."},{"type":"text","text":" "},{"type":"text","text":"The argument is automatically converted to a closure,"},{"type":"text","text":" "},{"type":"text","text":"because the "},{"code":"customerProvider","type":"codeVoice"},{"type":"text","text":" parameter’s type is marked"},{"type":"text","text":" "},{"text":"with the ","type":"text"},{"type":"codeVoice","code":"@autoclosure"},{"text":" attribute.","type":"text"}],"type":"paragraph"},{"type":"codeListing","syntax":"swift","code":["\/\/ customersInLine is [\"Ewa\", \"Barry\", \"Daniella\"]","func serve(customer customerProvider: @autoclosure () -> String) {","    print(\"Now serving \\(customerProvider())!\")","}","serve(customer: customersInLine.remove(at: 0))","\/\/ Prints \"Now serving Ewa!\""]},{"type":"aside","style":"note","name":"Note","content":[{"type":"paragraph","inlineContent":[{"text":"Overusing autoclosures can make your code hard to understand.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"The context and function name should make it clear"},{"type":"text","text":" "},{"text":"that evaluation is being deferred.","type":"text"}]}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"If you want an autoclosure that’s allowed to escape,"},{"type":"text","text":" "},{"text":"use both the ","type":"text"},{"type":"codeVoice","code":"@autoclosure"},{"type":"text","text":" and "},{"type":"codeVoice","code":"@escaping"},{"type":"text","text":" attributes."},{"text":" ","type":"text"},{"text":"The ","type":"text"},{"code":"@escaping","type":"codeVoice"},{"type":"text","text":" attribute is described above in "},{"isActive":true,"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Closures#Clausuras-que-escapan","type":"reference"},{"type":"text","text":"."}]},{"code":["\/\/ customersInLine is [\"Barry\", \"Daniella\"]","var customerProviders: [() -> String] = []","func collectCustomerProviders(_ customerProvider: @autoclosure @escaping () -> String) {","    customerProviders.append(customerProvider)","}","collectCustomerProviders(customersInLine.remove(at: 0))","collectCustomerProviders(customersInLine.remove(at: 0))","","print(\"Collected \\(customerProviders.count) closures.\")","\/\/ Prints \"Collected 2 closures.\"","for customerProvider in customerProviders {","    print(\"Now serving \\(customerProvider())!\")","}","\/\/ Prints \"Now serving Barry!\"","\/\/ Prints \"Now serving Daniella!\""],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"text":"In the code above,","type":"text"},{"text":" ","type":"text"},{"text":"instead of calling the closure passed to it","type":"text"},{"text":" ","type":"text"},{"text":"as its ","type":"text"},{"type":"codeVoice","code":"customerProvider"},{"type":"text","text":" argument,"},{"text":" ","type":"text"},{"text":"the ","type":"text"},{"type":"codeVoice","code":"collectCustomerProviders(_:)"},{"text":" function","type":"text"},{"type":"text","text":" "},{"type":"text","text":"appends the closure to the "},{"code":"customerProviders","type":"codeVoice"},{"text":" array.","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"The array is declared outside the scope of the function,"},{"type":"text","text":" "},{"type":"text","text":"which means the closures in the array can be executed after the function returns."},{"text":" ","type":"text"},{"type":"text","text":"As a result,"},{"type":"text","text":" "},{"text":"the value of the ","type":"text"},{"code":"customerProvider","type":"codeVoice"},{"text":" argument","type":"text"},{"type":"text","text":" "},{"text":"must be allowed to escape the function’s scope.","type":"text"}],"type":"paragraph"},{"name":"Software Beta","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":""}]},{"inlineContent":[{"text":"Esta documentación contiene información preliminar sobre una API o tecnología en desarrollo. Esta información está sujeta a cambios, y todo software implementado en conformidad con esta documentación debe ser testeado con el software final del sistema operativo.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"Conoce más acerca del uso del ","type":"text"},{"identifier":"https:\/\/developer.apple.com\/es\/support\/beta-software\/","isActive":true,"type":"reference"},{"type":"text","text":"."}],"type":"paragraph"}],"type":"aside","style":"note"}]}],"references":{"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/ClassesAndStructures#Las-estructuras-y-las-enumeraciones-son-tipos-de-valor":{"type":"topic","kind":"section","identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/ClassesAndStructures#Las-estructuras-y-las-enumeraciones-son-tipos-de-valor","abstract":[],"title":"Las estructuras y las enumeraciones son tipos de valor","url":"\/documentation\/the-swift-programming-language\/classesandstructures#Las-estructuras-y-las-enumeraciones-son-tipos-de-valor"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/AdvancedOperators#M%C3%A9todos-operadores":{"type":"topic","kind":"section","identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/AdvancedOperators#M%C3%A9todos-operadores","abstract":[],"title":"Métodos operadores","url":"\/documentation\/the-swift-programming-language\/advancedoperators#M%C3%A9todos-operadores"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/AutomaticReferenceCounting#Ciclos-de-referencias-fuertes-para-clausuras":{"type":"topic","kind":"section","identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/AutomaticReferenceCounting#Ciclos-de-referencias-fuertes-para-clausuras","abstract":[],"title":"Ciclos de referencias fuertes para clausuras","url":"\/documentation\/the-swift-programming-language\/automaticreferencecounting#Ciclos-de-referencias-fuertes-para-clausuras"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/AutomaticReferenceCounting":{"abstract":[{"type":"text","text":"Model the lifetime of objects and their relationships."}],"url":"\/documentation\/the-swift-programming-language\/automaticreferencecounting","kind":"article","title":"Conteo automático de referencias","identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/AutomaticReferenceCounting","type":"topic","role":"article"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Closures#Clausuras-que-escapan":{"type":"topic","kind":"section","identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Closures#Clausuras-que-escapan","abstract":[],"title":"Clausuras que escapan","url":"\/documentation\/the-swift-programming-language\/closures#Clausuras-que-escapan"},"https://developer.apple.com/es/support/beta-software/":{"type":"link","url":"https:\/\/developer.apple.com\/es\/support\/beta-software\/","identifier":"https:\/\/developer.apple.com\/es\/support\/beta-software\/","title":"software beta de Apple","titleInlineContent":[{"text":"software beta de Apple","type":"text"}]},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Closures#Captura-de-valores":{"type":"topic","kind":"section","identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Closures#Captura-de-valores","abstract":[],"title":"Captura de valores","url":"\/documentation\/the-swift-programming-language\/closures#Captura-de-valores"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Closures#Sintaxis-de-expresiones-clausura":{"type":"topic","kind":"section","identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Closures#Sintaxis-de-expresiones-clausura","abstract":[],"title":"Sintaxis de expresiones clausura","url":"\/documentation\/the-swift-programming-language\/closures#Sintaxis-de-expresiones-clausura"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language":{"role":"collection","kind":"article","identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language","url":"\/documentation\/the-swift-programming-language","title":"The Swift Programming Language (6)","abstract":[],"type":"topic"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Concurrency":{"type":"topic","abstract":[{"text":"Perform asynchronous operations.","type":"text"}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Concurrency","role":"article","kind":"article","title":"Concurrencia","url":"\/documentation\/the-swift-programming-language\/concurrency"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Functions":{"abstract":[{"text":"Define and call functions, label their arguments, and use their return values.","type":"text"}],"title":"Funciones","type":"topic","url":"\/documentation\/the-swift-programming-language\/functions","kind":"article","identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Functions","role":"article"}}}
||||||| parent of 2fa5d86d (yet one more fix attempt)
{"primaryContentSections":[{"content":[{"type":"paragraph","inlineContent":[{"type":"emphasis","inlineContent":[{"type":"text","text":"Closures"}]},{"type":"text","text":" are self-contained blocks of functionality"},{"type":"text","text":" "},{"type":"text","text":"that can be passed around and used in your code."},{"type":"text","text":" "},{"type":"text","text":"Closures in Swift are similar to blocks in C and Objective-C"},{"type":"text","text":" "},{"text":"and to lambdas in other programming languages.","type":"text"}]},{"inlineContent":[{"text":"Closures can capture and store references to any constants and variables","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"from the context in which they’re defined."},{"type":"text","text":" "},{"type":"text","text":"This is known as "},{"type":"emphasis","inlineContent":[{"text":"closing over","type":"text"}]},{"text":" those constants and variables.","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"Swift handles all of the memory management of capturing for you."}],"type":"paragraph"},{"type":"aside","content":[{"type":"paragraph","inlineContent":[{"text":"Don’t worry if you aren’t familiar with the concept of capturing.","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"It’s explained in detail below in "},{"type":"reference","identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Closures#Captura-de-valores","isActive":true},{"text":".","type":"text"}]}],"name":"Note","style":"note"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Global and nested functions, as introduced in "},{"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Functions","isActive":true,"type":"reference"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"are actually special cases of closures."},{"text":" ","type":"text"},{"text":"Closures take one of three forms:","type":"text"}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"Global functions are closures that have a name","type":"text"},{"type":"text","text":" "},{"text":"and don’t capture any values.","type":"text"}]}]},{"content":[{"inlineContent":[{"type":"text","text":"Nested functions are closures that have a name"},{"type":"text","text":" "},{"text":"and can capture values from their enclosing function.","type":"text"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Closure expressions are unnamed closures written in a lightweight syntax"},{"type":"text","text":" "},{"text":"that can capture values from their surrounding context.","type":"text"}]}]}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Swift’s closure expressions have a clean, clear style,"},{"type":"text","text":" "},{"text":"with optimizations that encourage brief, clutter-free syntax in common scenarios.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"These optimizations include:"}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Inferring parameter and return value types from context"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"Implicit returns from single-expression closures","type":"text"}]}]},{"content":[{"inlineContent":[{"type":"text","text":"Shorthand argument names"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"text","text":"Trailing closure syntax"}],"type":"paragraph"}]}]},{"level":2,"text":"Expresiones clausura","type":"heading","anchor":"Expresiones-clausura"},{"inlineContent":[{"type":"text","text":"Nested functions, as introduced in "},{"type":"text","text":"doc:Functions#Funciones-anidadas"},{"text":",","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"are a convenient means of naming and defining self-contained blocks of code"},{"text":" ","type":"text"},{"type":"text","text":"as part of a larger function."},{"type":"text","text":" "},{"type":"text","text":"However, it’s sometimes useful to write shorter versions of function-like constructs"},{"text":" ","type":"text"},{"text":"without a full declaration and name.","type":"text"},{"text":" ","type":"text"},{"text":"This is particularly true when you work with functions or methods that take functions","type":"text"},{"type":"text","text":" "},{"text":"as one or more of their arguments.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"emphasis","inlineContent":[{"text":"Closure expressions","type":"text"}]},{"type":"text","text":" are a way to write inline closures in a brief, focused syntax."},{"text":" ","type":"text"},{"text":"Closure expressions provide several syntax optimizations","type":"text"},{"type":"text","text":" "},{"type":"text","text":"for writing closures in a shortened form without loss of clarity or intent."},{"type":"text","text":" "},{"text":"The closure expression examples below illustrate these optimizations","type":"text"},{"type":"text","text":" "},{"text":"by refining a single example of the ","type":"text"},{"code":"sorted(by:)","type":"codeVoice"},{"type":"text","text":" method over several iterations,"},{"text":" ","type":"text"},{"text":"each of which expresses the same functionality in a more succinct way.","type":"text"}],"type":"paragraph"},{"type":"heading","text":"El método sorted","level":3,"anchor":"El-m%C3%A9todo-sorted"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Swift’s standard library provides a method called "},{"code":"sorted(by:)","type":"codeVoice"},{"type":"text","text":","},{"text":" ","type":"text"},{"type":"text","text":"which sorts an array of values of a known type,"},{"text":" ","type":"text"},{"text":"based on the output of a sorting closure that you provide.","type":"text"},{"text":" ","type":"text"},{"text":"Once it completes the sorting process,","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"the "},{"type":"codeVoice","code":"sorted(by:)"},{"text":" method returns a new array of the same type and size as the old one,","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"with its elements in the correct sorted order."},{"type":"text","text":" "},{"text":"The original array isn’t modified by the ","type":"text"},{"code":"sorted(by:)","type":"codeVoice"},{"type":"text","text":" method."}]},{"inlineContent":[{"type":"text","text":"The closure expression examples below use the "},{"code":"sorted(by:)","type":"codeVoice"},{"type":"text","text":" method"},{"text":" ","type":"text"},{"type":"text","text":"to sort an array of "},{"type":"codeVoice","code":"String"},{"type":"text","text":" values in reverse alphabetical order."},{"type":"text","text":" "},{"type":"text","text":"Here’s the initial array to be sorted:"}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["let names = [\"Chris\", \"Alex\", \"Ewa\", \"Barry\", \"Daniella\"]"]},{"inlineContent":[{"type":"text","text":"The "},{"code":"sorted(by:)","type":"codeVoice"},{"type":"text","text":" method accepts a closure that takes two arguments"},{"type":"text","text":" "},{"type":"text","text":"of the same type as the array’s contents,"},{"text":" ","type":"text"},{"type":"text","text":"and returns a "},{"code":"Bool","type":"codeVoice"},{"type":"text","text":" value to say whether the first value should appear"},{"type":"text","text":" "},{"text":"before or after the second value once the values are sorted.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"The sorting closure needs to return "},{"code":"true","type":"codeVoice"},{"type":"text","text":" "},{"type":"text","text":"if the first value should appear "},{"inlineContent":[{"text":"before","type":"text"}],"type":"emphasis"},{"type":"text","text":" the second value,"},{"type":"text","text":" "},{"text":"and ","type":"text"},{"code":"false","type":"codeVoice"},{"type":"text","text":" otherwise."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"This example is sorting an array of "},{"type":"codeVoice","code":"String"},{"text":" values,","type":"text"},{"type":"text","text":" "},{"type":"text","text":"and so the sorting closure needs to be a function of type "},{"type":"codeVoice","code":"(String, String) -> Bool"},{"text":".","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"One way to provide the sorting closure is to write a normal function of the correct type,"},{"type":"text","text":" "},{"text":"and to pass it in as an argument to the ","type":"text"},{"code":"sorted(by:)","type":"codeVoice"},{"type":"text","text":" method:"}]},{"type":"codeListing","syntax":"swift","code":["func backward(_ s1: String, _ s2: String) -> Bool {","    return s1 > s2","}","var reversedNames = names.sorted(by: backward)","\/\/ reversedNames is equal to [\"Ewa\", \"Daniella\", \"Chris\", \"Barry\", \"Alex\"]"]},{"type":"paragraph","inlineContent":[{"text":"If the first string (","type":"text"},{"code":"s1","type":"codeVoice"},{"type":"text","text":") is greater than the second string ("},{"type":"codeVoice","code":"s2"},{"text":"),","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"the "},{"type":"codeVoice","code":"backward(_:_:)"},{"type":"text","text":" function will return "},{"type":"codeVoice","code":"true"},{"text":",","type":"text"},{"type":"text","text":" "},{"text":"indicating that ","type":"text"},{"type":"codeVoice","code":"s1"},{"type":"text","text":" should appear before "},{"type":"codeVoice","code":"s2"},{"text":" in the sorted array.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"For characters in strings,"},{"type":"text","text":" "},{"text":"“greater than” means “appears later in the alphabet than”.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"This means that the letter "},{"type":"codeVoice","code":"\"B\""},{"type":"text","text":" is “greater than” the letter "},{"code":"\"A\"","type":"codeVoice"},{"text":",","type":"text"},{"text":" ","type":"text"},{"text":"and the string ","type":"text"},{"type":"codeVoice","code":"\"Tom\""},{"text":" is greater than the string ","type":"text"},{"type":"codeVoice","code":"\"Tim\""},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"This gives a reverse alphabetical sort,"},{"type":"text","text":" "},{"text":"with ","type":"text"},{"type":"codeVoice","code":"\"Barry\""},{"text":" being placed before ","type":"text"},{"type":"codeVoice","code":"\"Alex\""},{"type":"text","text":", and so on."}]},{"type":"paragraph","inlineContent":[{"text":"However, this is a rather long-winded way to write","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"what is essentially a single-expression function ("},{"type":"codeVoice","code":"a > b"},{"text":").","type":"text"},{"text":" ","type":"text"},{"text":"In this example, it would be preferable to write the sorting closure inline,","type":"text"},{"type":"text","text":" "},{"text":"using closure expression syntax.","type":"text"}]},{"level":3,"text":"Sintaxis de expresiones clausura","type":"heading","anchor":"Sintaxis-de-expresiones-clausura"},{"inlineContent":[{"type":"text","text":"Closure expression syntax has the following general form:"}],"type":"paragraph"},{"type":"codeListing","syntax":"swift","code":["{ (<#parameters#>) -> <#return type#> in","   <#statements#>","}"]},{"inlineContent":[{"type":"text","text":"The "},{"inlineContent":[{"text":"parameters","type":"text"}],"type":"emphasis"},{"type":"text","text":" in closure expression syntax"},{"text":" ","type":"text"},{"type":"text","text":"can be in-out parameters,"},{"type":"text","text":" "},{"text":"but they can’t have a default value.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"Variadic parameters can be used if you name the variadic parameter."},{"type":"text","text":" "},{"type":"text","text":"Tuples can also be used as parameter types and return types."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"The example below shows a closure expression version of the "},{"type":"codeVoice","code":"backward(_:_:)"},{"type":"text","text":" function"},{"type":"text","text":" "},{"type":"text","text":"from above:"}]},{"syntax":"swift","code":["reversedNames = names.sorted(by: { (s1: String, s2: String) -> Bool in","    return s1 > s2","})"],"type":"codeListing"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Note that the declaration of parameters and return type for this inline closure"},{"type":"text","text":" "},{"text":"is identical to the declaration from the ","type":"text"},{"type":"codeVoice","code":"backward(_:_:)"},{"type":"text","text":" function."},{"text":" ","type":"text"},{"type":"text","text":"In both cases, it’s written as "},{"type":"codeVoice","code":"(s1: String, s2: String) -> Bool"},{"type":"text","text":"."},{"text":" ","type":"text"},{"type":"text","text":"However, for the inline closure expression,"},{"text":" ","type":"text"},{"text":"the parameters and return type are written ","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"inside"}]},{"text":" the curly braces,","type":"text"},{"text":" ","type":"text"},{"text":"not outside of them.","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"The start of the closure’s body is introduced by the ","type":"text"},{"type":"codeVoice","code":"in"},{"type":"text","text":" keyword."},{"text":" ","type":"text"},{"type":"text","text":"This keyword indicates that"},{"type":"text","text":" "},{"text":"the definition of the closure’s parameters and return type has finished,","type":"text"},{"text":" ","type":"text"},{"text":"and the body of the closure is about to begin.","type":"text"}]},{"inlineContent":[{"type":"text","text":"Because the body of the closure is so short,"},{"text":" ","type":"text"},{"type":"text","text":"it can even be written on a single line:"}],"type":"paragraph"},{"code":["reversedNames = names.sorted(by: { (s1: String, s2: String) -> Bool in return s1 > s2 } )"],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"text":"This illustrates that the overall call to the ","type":"text"},{"type":"codeVoice","code":"sorted(by:)"},{"text":" method has remained the same.","type":"text"},{"type":"text","text":" "},{"text":"A pair of parentheses still wrap the entire argument for the method.","type":"text"},{"text":" ","type":"text"},{"text":"However, that argument is now an inline closure.","type":"text"}],"type":"paragraph"},{"text":"Inferencia de tipos a partir del contexto","anchor":"Inferencia-de-tipos-a-partir-del-contexto","type":"heading","level":3},{"inlineContent":[{"text":"Because the sorting closure is passed as an argument to a method,","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"Swift can infer the types of its parameters"},{"text":" ","type":"text"},{"type":"text","text":"and the type of the value it returns."},{"type":"text","text":" "},{"type":"text","text":"The "},{"type":"codeVoice","code":"sorted(by:)"},{"type":"text","text":" method is being called on an array of strings,"},{"type":"text","text":" "},{"type":"text","text":"so its argument must be a function of type "},{"type":"codeVoice","code":"(String, String) -> Bool"},{"text":".","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"This means that the "},{"type":"codeVoice","code":"(String, String)"},{"type":"text","text":" and "},{"code":"Bool","type":"codeVoice"},{"text":" types don’t need to be written","type":"text"},{"text":" ","type":"text"},{"text":"as part of the closure expression’s definition.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"Because all of the types can be inferred,"},{"type":"text","text":" "},{"type":"text","text":"the return arrow ("},{"code":"->","type":"codeVoice"},{"type":"text","text":") and the parentheses around the names of the parameters"},{"text":" ","type":"text"},{"type":"text","text":"can also be omitted:"}],"type":"paragraph"},{"type":"codeListing","syntax":"swift","code":["reversedNames = names.sorted(by: { s1, s2 in return s1 > s2 } )"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"It’s always possible to infer the parameter types and return type"},{"type":"text","text":" "},{"text":"when passing a closure to a function or method as an inline closure expression.","type":"text"},{"text":" ","type":"text"},{"text":"As a result, you never need to write an inline closure in its fullest form","type":"text"},{"type":"text","text":" "},{"type":"text","text":"when the closure is used as a function or method argument."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Nonetheless, you can still make the types explicit if you wish,"},{"type":"text","text":" "},{"type":"text","text":"and doing so is encouraged if it avoids ambiguity for readers of your code."},{"text":" ","type":"text"},{"type":"text","text":"In the case of the "},{"code":"sorted(by:)","type":"codeVoice"},{"text":" method,","type":"text"},{"type":"text","text":" "},{"type":"text","text":"the purpose of the closure is clear from the fact that sorting is taking place,"},{"type":"text","text":" "},{"text":"and it’s safe for a reader to assume that","type":"text"},{"type":"text","text":" "},{"type":"text","text":"the closure is likely to be working with "},{"type":"codeVoice","code":"String"},{"type":"text","text":" values,"},{"type":"text","text":" "},{"type":"text","text":"because it’s assisting with the sorting of an array of strings."}]},{"text":"Devolución implícita desde clausuras de una sola expresión","type":"heading","level":3,"anchor":"Devoluci%C3%B3n-impl%C3%ADcita-desde-clausuras-de-una-sola-expresi%C3%B3n"},{"inlineContent":[{"text":"Single-expression closures can implicitly return the result of their single expression","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"by omitting the "},{"code":"return","type":"codeVoice"},{"text":" keyword from their declaration,","type":"text"},{"text":" ","type":"text"},{"text":"as in this version of the previous example:","type":"text"}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["reversedNames = names.sorted(by: { s1, s2 in s1 > s2 } )"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Here, the function type of the "},{"type":"codeVoice","code":"sorted(by:)"},{"text":" method’s argument","type":"text"},{"type":"text","text":" "},{"text":"makes it clear that a ","type":"text"},{"code":"Bool","type":"codeVoice"},{"text":" value must be returned by the closure.","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"Because the closure’s body contains a single expression ("},{"code":"s1 > s2","type":"codeVoice"},{"text":")","type":"text"},{"type":"text","text":" "},{"type":"text","text":"that returns a "},{"type":"codeVoice","code":"Bool"},{"text":" value,","type":"text"},{"type":"text","text":" "},{"text":"there’s no ambiguity, and the ","type":"text"},{"type":"codeVoice","code":"return"},{"text":" keyword can be omitted.","type":"text"}]},{"level":3,"anchor":"Nombres-de-argumentos-concisos","type":"heading","text":"Nombres de argumentos concisos"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Swift automatically provides shorthand argument names to inline closures,"},{"type":"text","text":" "},{"text":"which can be used to refer to the values of the closure’s arguments","type":"text"},{"type":"text","text":" "},{"type":"text","text":"by the names "},{"type":"codeVoice","code":"$0"},{"type":"text","text":", "},{"code":"$1","type":"codeVoice"},{"type":"text","text":", "},{"code":"$2","type":"codeVoice"},{"type":"text","text":", and so on."}]},{"inlineContent":[{"text":"If you use these shorthand argument names within your closure expression,","type":"text"},{"text":" ","type":"text"},{"text":"you can omit the closure’s argument list from its definition.","type":"text"},{"type":"text","text":" "},{"text":"The type of the shorthand argument names","type":"text"},{"type":"text","text":" "},{"text":"is inferred from the expected function type,","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"and the highest numbered shorthand argument you use"},{"type":"text","text":" "},{"type":"text","text":"determines the number of arguments that the closure takes."},{"text":" ","type":"text"},{"type":"text","text":"The "},{"code":"in","type":"codeVoice"},{"text":" keyword can also be omitted,","type":"text"},{"type":"text","text":" "},{"type":"text","text":"because the closure expression is made up entirely of its body:"}],"type":"paragraph"},{"type":"codeListing","syntax":"swift","code":["reversedNames = names.sorted(by: { $0 > $1 } )"]},{"inlineContent":[{"type":"text","text":"Here, "},{"code":"$0","type":"codeVoice"},{"type":"text","text":" and "},{"code":"$1","type":"codeVoice"},{"text":" refer to the closure’s first and second ","type":"text"},{"type":"codeVoice","code":"String"},{"text":" arguments.","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"Because "},{"code":"$1","type":"codeVoice"},{"type":"text","text":" is the shorthand argument with highest number,"},{"text":" ","type":"text"},{"text":"the closure is understood to take two arguments.","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"Because the "},{"code":"sorted(by:)","type":"codeVoice"},{"text":" function here expects a closure","type":"text"},{"text":" ","type":"text"},{"text":"whose arguments are both strings,","type":"text"},{"text":" ","type":"text"},{"text":"the shorthand arguments ","type":"text"},{"type":"codeVoice","code":"$0"},{"text":" and ","type":"text"},{"type":"codeVoice","code":"$1"},{"type":"text","text":" are both of type "},{"type":"codeVoice","code":"String"},{"text":".","type":"text"}],"type":"paragraph"},{"anchor":"M%C3%A9todos-operadores","level":3,"type":"heading","text":"Métodos operadores"},{"inlineContent":[{"type":"text","text":"There’s actually an even "},{"inlineContent":[{"text":"shorter","type":"text"}],"type":"emphasis"},{"type":"text","text":" way to write the closure expression above."},{"type":"text","text":" "},{"type":"text","text":"Swift’s "},{"type":"codeVoice","code":"String"},{"text":" type defines its string-specific implementation of","type":"text"},{"type":"text","text":" "},{"type":"text","text":"the greater-than operator ("},{"code":">","type":"codeVoice"},{"text":")","type":"text"},{"type":"text","text":" "},{"text":"as a method that has two parameters of type ","type":"text"},{"code":"String","type":"codeVoice"},{"text":",","type":"text"},{"type":"text","text":" "},{"text":"and returns a value of type ","type":"text"},{"code":"Bool","type":"codeVoice"},{"text":".","type":"text"},{"text":" ","type":"text"},{"text":"This exactly matches the method type needed by the ","type":"text"},{"type":"codeVoice","code":"sorted(by:)"},{"text":" method.","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"Therefore, you can simply pass in the greater-than operator,"},{"type":"text","text":" "},{"text":"and Swift will infer that you want to use its string-specific implementation:","type":"text"}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["reversedNames = names.sorted(by: >)"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"For more about operator methods, see "},{"type":"reference","isActive":true,"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/AdvancedOperators#M%C3%A9todos-operadores"},{"type":"text","text":"."}]},{"level":2,"text":"Clausuras colgantes","anchor":"Clausuras-colgantes","type":"heading"},{"inlineContent":[{"type":"text","text":"If you need to pass a closure expression to a function as the function’s final argument"},{"type":"text","text":" "},{"type":"text","text":"and the closure expression is long,"},{"text":" ","type":"text"},{"type":"text","text":"it can be useful to write it as a "},{"inlineContent":[{"type":"text","text":"trailing closure"}],"type":"emphasis"},{"text":" instead.","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"You write a trailing closure after the function call’s parentheses,"},{"text":" ","type":"text"},{"text":"even though the trailing closure is still an argument to the function.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"When you use the trailing closure syntax,"},{"type":"text","text":" "},{"text":"you don’t write the argument label for the first closure","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"as part of the function call."},{"text":" ","type":"text"},{"type":"text","text":"A function call can include multiple trailing closures;"},{"type":"text","text":" "},{"text":"however, the first few examples below use a single trailing closure.","type":"text"}],"type":"paragraph"},{"syntax":"swift","code":["func someFunctionThatTakesAClosure(closure: () -> Void) {","    \/\/ function body goes here","}","","\/\/ Here's how you call this function without using a trailing closure:","","someFunctionThatTakesAClosure(closure: {","    \/\/ closure's body goes here","})","","\/\/ Here's how you call this function with a trailing closure instead:","","someFunctionThatTakesAClosure() {","    \/\/ trailing closure's body goes here","}"],"type":"codeListing"},{"inlineContent":[{"type":"text","text":"The string-sorting closure from the "},{"isActive":true,"type":"reference","identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Closures#Sintaxis-de-expresiones-clausura"},{"type":"text","text":" section above"},{"text":" ","type":"text"},{"type":"text","text":"can be written outside of the "},{"code":"sorted(by:)","type":"codeVoice"},{"text":" method’s parentheses as a trailing closure:","type":"text"}],"type":"paragraph"},{"syntax":"swift","code":["reversedNames = names.sorted() { $0 > $1 }"],"type":"codeListing"},{"inlineContent":[{"type":"text","text":"If a closure expression is provided as the function’s or method’s only argument"},{"type":"text","text":" "},{"type":"text","text":"and you provide that expression as a trailing closure,"},{"text":" ","type":"text"},{"text":"you don’t need to write a pair of parentheses ","type":"text"},{"type":"codeVoice","code":"()"},{"text":" ","type":"text"},{"type":"text","text":"after the function or method’s name when you call the function:"}],"type":"paragraph"},{"syntax":"swift","code":["reversedNames = names.sorted { $0 > $1 }"],"type":"codeListing"},{"inlineContent":[{"type":"text","text":"Trailing closures are most useful when the closure is sufficiently long that"},{"text":" ","type":"text"},{"text":"it isn’t possible to write it inline on a single line.","type":"text"},{"type":"text","text":" "},{"text":"As an example, Swift’s ","type":"text"},{"code":"Array","type":"codeVoice"},{"type":"text","text":" type has a "},{"type":"codeVoice","code":"map(_:)"},{"type":"text","text":" method,"},{"text":" ","type":"text"},{"text":"which takes a closure expression as its single argument.","type":"text"},{"type":"text","text":" "},{"text":"The closure is called once for each item in the array,","type":"text"},{"type":"text","text":" "},{"type":"text","text":"and returns an alternative mapped value (possibly of some other type) for that item."},{"type":"text","text":" "},{"type":"text","text":"You specify"},{"type":"text","text":" "},{"type":"text","text":"the nature of the mapping and the type of the returned value"},{"text":" ","type":"text"},{"text":"by writing code in the closure that you pass to ","type":"text"},{"type":"codeVoice","code":"map(_:)"},{"text":".","type":"text"}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"text":"After applying the provided closure to each array element,","type":"text"},{"text":" ","type":"text"},{"text":"the ","type":"text"},{"type":"codeVoice","code":"map(_:)"},{"type":"text","text":" method returns a new array containing all of the new mapped values,"},{"type":"text","text":" "},{"text":"in the same order as their corresponding values in the original array.","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Here’s how you can use the "},{"code":"map(_:)","type":"codeVoice"},{"type":"text","text":" method with a trailing closure"},{"type":"text","text":" "},{"type":"text","text":"to convert an array of "},{"code":"Int","type":"codeVoice"},{"type":"text","text":" values into an array of "},{"code":"String","type":"codeVoice"},{"type":"text","text":" values."},{"type":"text","text":" "},{"type":"text","text":"The array "},{"type":"codeVoice","code":"[16, 58, 510]"},{"type":"text","text":" is used to create the new array"},{"type":"text","text":" "},{"code":"[\"OneSix\", \"FiveEight\", \"FiveOneZero\"]","type":"codeVoice"},{"type":"text","text":":"}]},{"syntax":"swift","code":["let digitNames = [","    0: \"Zero\", 1: \"One\", 2: \"Two\",   3: \"Three\", 4: \"Four\",","    5: \"Five\", 6: \"Six\", 7: \"Seven\", 8: \"Eight\", 9: \"Nine\"","]","let numbers = [16, 58, 510]"],"type":"codeListing"},{"type":"paragraph","inlineContent":[{"type":"text","text":"The code above creates a dictionary of mappings between"},{"type":"text","text":" "},{"type":"text","text":"the integer digits and English-language versions of their names."},{"text":" ","type":"text"},{"type":"text","text":"It also defines an array of integers, ready to be converted into strings."}]},{"inlineContent":[{"type":"text","text":"You can now use the "},{"type":"codeVoice","code":"numbers"},{"type":"text","text":" array to create an array of "},{"type":"codeVoice","code":"String"},{"type":"text","text":" values,"},{"text":" ","type":"text"},{"type":"text","text":"by passing a closure expression to the array’s "},{"type":"codeVoice","code":"map(_:)"},{"text":" method as a trailing closure:","type":"text"}],"type":"paragraph"},{"code":["let strings = numbers.map { (number) -> String in","    var number = number","    var output = \"\"","    repeat {","        output = digitNames[number % 10]! + output","        number \/= 10","    } while number > 0","    return output","}","\/\/ strings is inferred to be of type [String]","\/\/ its value is [\"OneSix\", \"FiveEight\", \"FiveOneZero\"]"],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"type":"text","text":"The "},{"type":"codeVoice","code":"map(_:)"},{"text":" method calls the closure expression once for each item in the array.","type":"text"},{"text":" ","type":"text"},{"text":"You don’t need to specify the type of the closure’s input parameter, ","type":"text"},{"type":"codeVoice","code":"number"},{"text":",","type":"text"},{"text":" ","type":"text"},{"text":"because the type can be inferred from the values in the array to be mapped.","type":"text"}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"In this example,"},{"text":" ","type":"text"},{"text":"the variable ","type":"text"},{"type":"codeVoice","code":"number"},{"type":"text","text":" is initialized with the value of the closure’s "},{"code":"number","type":"codeVoice"},{"type":"text","text":" parameter,"},{"type":"text","text":" "},{"text":"so that the value can be modified within the closure body.","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"(The parameters to functions and closures are always constants.)"},{"text":" ","type":"text"},{"text":"The closure expression also specifies a return type of ","type":"text"},{"type":"codeVoice","code":"String"},{"type":"text","text":","},{"text":" ","type":"text"},{"type":"text","text":"to indicate the type that will be stored in the mapped output array."}]},{"inlineContent":[{"type":"text","text":"The closure expression builds a string called "},{"type":"codeVoice","code":"output"},{"text":" each time it’s called.","type":"text"},{"type":"text","text":" "},{"text":"It calculates the last digit of ","type":"text"},{"type":"codeVoice","code":"number"},{"type":"text","text":" by using the remainder operator ("},{"type":"codeVoice","code":"number % 10"},{"type":"text","text":"),"},{"text":" ","type":"text"},{"text":"and uses this digit to look up an appropriate string in the ","type":"text"},{"type":"codeVoice","code":"digitNames"},{"type":"text","text":" dictionary."},{"text":" ","type":"text"},{"text":"The closure can be used to create a string representation of any integer greater than zero.","type":"text"}],"type":"paragraph"},{"type":"aside","content":[{"inlineContent":[{"text":"The call to the ","type":"text"},{"type":"codeVoice","code":"digitNames"},{"type":"text","text":" dictionary’s subscript"},{"type":"text","text":" "},{"type":"text","text":"is followed by an exclamation point ("},{"code":"!","type":"codeVoice"},{"type":"text","text":"),"},{"type":"text","text":" "},{"text":"because dictionary subscripts return an optional value","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"to indicate that the dictionary lookup can fail if the key doesn’t exist."},{"type":"text","text":" "},{"text":"In the example above, it’s guaranteed that ","type":"text"},{"type":"codeVoice","code":"number % 10"},{"text":" ","type":"text"},{"text":"will always be a valid subscript key for the ","type":"text"},{"code":"digitNames","type":"codeVoice"},{"type":"text","text":" dictionary,"},{"type":"text","text":" "},{"text":"and so an exclamation point is used to force-unwrap the ","type":"text"},{"type":"codeVoice","code":"String"},{"text":" value","type":"text"},{"type":"text","text":" "},{"type":"text","text":"stored in the subscript’s optional return value."}],"type":"paragraph"}],"style":"note","name":"Note"},{"type":"paragraph","inlineContent":[{"text":"The string retrieved from the ","type":"text"},{"type":"codeVoice","code":"digitNames"},{"text":" dictionary","type":"text"},{"type":"text","text":" "},{"text":"is added to the ","type":"text"},{"inlineContent":[{"text":"front","type":"text"}],"type":"emphasis"},{"type":"text","text":" of "},{"type":"codeVoice","code":"output"},{"type":"text","text":","},{"text":" ","type":"text"},{"type":"text","text":"effectively building a string version of the number in reverse."},{"type":"text","text":" "},{"type":"text","text":"(The expression "},{"code":"number % 10","type":"codeVoice"},{"text":" gives a value of","type":"text"},{"type":"text","text":" "},{"code":"6","type":"codeVoice"},{"text":" for ","type":"text"},{"code":"16","type":"codeVoice"},{"type":"text","text":", "},{"type":"codeVoice","code":"8"},{"type":"text","text":" for "},{"type":"codeVoice","code":"58"},{"text":", and ","type":"text"},{"type":"codeVoice","code":"0"},{"text":" for ","type":"text"},{"code":"510","type":"codeVoice"},{"type":"text","text":".)"}]},{"inlineContent":[{"type":"text","text":"The "},{"code":"number","type":"codeVoice"},{"text":" variable is then divided by ","type":"text"},{"code":"10","type":"codeVoice"},{"type":"text","text":"."},{"text":" ","type":"text"},{"text":"Because it’s an integer, it’s rounded down during the division,","type":"text"},{"text":" ","type":"text"},{"text":"so ","type":"text"},{"type":"codeVoice","code":"16"},{"type":"text","text":" becomes "},{"type":"codeVoice","code":"1"},{"type":"text","text":", "},{"type":"codeVoice","code":"58"},{"text":" becomes ","type":"text"},{"type":"codeVoice","code":"5"},{"text":", and ","type":"text"},{"type":"codeVoice","code":"510"},{"type":"text","text":" becomes "},{"code":"51","type":"codeVoice"},{"text":".","type":"text"}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"text":"The process is repeated until ","type":"text"},{"type":"codeVoice","code":"number"},{"type":"text","text":" is equal to "},{"code":"0","type":"codeVoice"},{"text":",","type":"text"},{"type":"text","text":" "},{"type":"text","text":"at which point the "},{"code":"output","type":"codeVoice"},{"text":" string is returned by the closure,","type":"text"},{"text":" ","type":"text"},{"text":"and is added to the output array by the ","type":"text"},{"code":"map(_:)","type":"codeVoice"},{"type":"text","text":" method."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The use of trailing closure syntax in the example above"},{"type":"text","text":" "},{"type":"text","text":"neatly encapsulates the closure’s functionality"},{"text":" ","type":"text"},{"text":"immediately after the function that closure supports,","type":"text"},{"type":"text","text":" "},{"type":"text","text":"without needing to wrap the entire closure within"},{"text":" ","type":"text"},{"type":"text","text":"the "},{"type":"codeVoice","code":"map(_:)"},{"type":"text","text":" method’s outer parentheses."}]},{"inlineContent":[{"type":"text","text":"If a function takes multiple closures,"},{"text":" ","type":"text"},{"text":"you omit the argument label for the first trailing closure","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"and you label the remaining trailing closures."},{"text":" ","type":"text"},{"type":"text","text":"For example,"},{"text":" ","type":"text"},{"text":"the function below loads a picture for a photo gallery:","type":"text"}],"type":"paragraph"},{"code":["func loadPicture(from server: Server, completion: (Picture) -> Void, onFailure: () -> Void) {","    if let picture = download(\"photo.jpg\", from: server) {","        completion(picture)","    } else {","        onFailure()","    }","}"],"syntax":"swift","type":"codeListing"},{"inlineContent":[{"type":"text","text":"When you call this function to load a picture,"},{"text":" ","type":"text"},{"text":"you provide two closures.","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"The first closure is a completion handler"},{"type":"text","text":" "},{"text":"that displays a picture after a successful download.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"The second closure is an error handler"},{"text":" ","type":"text"},{"text":"that displays an error to the user.","type":"text"}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["loadPicture(from: someServer) { picture in","    someView.currentPicture = picture","} onFailure: {","    print(\"Couldn't download the next picture.\")","}"]},{"inlineContent":[{"text":"In this example,","type":"text"},{"text":" ","type":"text"},{"text":"the ","type":"text"},{"code":"loadPicture(from:completion:onFailure:)","type":"codeVoice"},{"type":"text","text":" function"},{"type":"text","text":" "},{"text":"dispatches its network task into the background,","type":"text"},{"type":"text","text":" "},{"type":"text","text":"and calls one of the two completion handlers when the network task finishes."},{"type":"text","text":" "},{"text":"Writing the function this way lets you cleanly separate the code","type":"text"},{"type":"text","text":" "},{"type":"text","text":"that’s responsible for handling a network failure"},{"text":" ","type":"text"},{"type":"text","text":"from the code that updates the user interface after a successful download,"},{"type":"text","text":" "},{"text":"instead of using just one closure that handles both circumstances.","type":"text"}],"type":"paragraph"},{"name":"Note","style":"note","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Completion handlers can become hard to read,"},{"type":"text","text":" "},{"type":"text","text":"especially when you have to nest multiple handlers."},{"type":"text","text":" "},{"type":"text","text":"An alternate approach is to use asynchronous code,"},{"text":" ","type":"text"},{"text":"as described in ","type":"text"},{"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Concurrency","type":"reference","isActive":true},{"type":"text","text":"."}]}],"type":"aside"},{"type":"heading","level":2,"text":"Captura de valores","anchor":"Captura-de-valores"},{"type":"paragraph","inlineContent":[{"type":"text","text":"A closure can "},{"type":"emphasis","inlineContent":[{"text":"capture","type":"text"}]},{"text":" constants and variables","type":"text"},{"text":" ","type":"text"},{"text":"from the surrounding context in which it’s defined.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"The closure can then refer to and modify"},{"text":" ","type":"text"},{"type":"text","text":"the values of those constants and variables from within its body,"},{"type":"text","text":" "},{"text":"even if the original scope that defined the constants and variables no longer exists.","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"In Swift, the simplest form of a closure that can capture values is a nested function,","type":"text"},{"type":"text","text":" "},{"type":"text","text":"written within the body of another function."},{"type":"text","text":" "},{"type":"text","text":"A nested function can capture any of its outer function’s arguments"},{"type":"text","text":" "},{"type":"text","text":"and can also capture any constants and variables defined within the outer function."}]},{"inlineContent":[{"type":"text","text":"Here’s an example of a function called "},{"type":"codeVoice","code":"makeIncrementer"},{"text":",","type":"text"},{"type":"text","text":" "},{"type":"text","text":"which contains a nested function called "},{"code":"incrementer","type":"codeVoice"},{"type":"text","text":"."},{"type":"text","text":" "},{"text":"The nested ","type":"text"},{"type":"codeVoice","code":"incrementer()"},{"type":"text","text":" function captures two values,"},{"type":"text","text":" "},{"type":"codeVoice","code":"runningTotal"},{"type":"text","text":" and "},{"type":"codeVoice","code":"amount"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"from its surrounding context."},{"type":"text","text":" "},{"text":"After capturing these values,","type":"text"},{"type":"text","text":" "},{"type":"codeVoice","code":"incrementer"},{"text":" is returned by ","type":"text"},{"code":"makeIncrementer","type":"codeVoice"},{"text":" as a closure","type":"text"},{"type":"text","text":" "},{"text":"that increments ","type":"text"},{"type":"codeVoice","code":"runningTotal"},{"type":"text","text":" by "},{"type":"codeVoice","code":"amount"},{"type":"text","text":" each time it’s called."}],"type":"paragraph"},{"syntax":"swift","code":["func makeIncrementer(forIncrement amount: Int) -> () -> Int {","    var runningTotal = 0","    func incrementer() -> Int {","        runningTotal += amount","        return runningTotal","    }","    return incrementer","}"],"type":"codeListing"},{"inlineContent":[{"text":"The return type of ","type":"text"},{"code":"makeIncrementer","type":"codeVoice"},{"type":"text","text":" is "},{"type":"codeVoice","code":"() -> Int"},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"This means that it returns a "},{"inlineContent":[{"text":"function","type":"text"}],"type":"emphasis"},{"text":", rather than a simple value.","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"The function it returns has no parameters,"},{"text":" ","type":"text"},{"type":"text","text":"and returns an "},{"type":"codeVoice","code":"Int"},{"type":"text","text":" value each time it’s called."},{"text":" ","type":"text"},{"text":"To learn how functions can return other functions,","type":"text"},{"type":"text","text":" "},{"type":"text","text":"see "},{"text":"doc:Functions#Tipos-de-funciones-como-tipos-de-devolución","type":"text"},{"type":"text","text":"."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"type":"codeVoice","code":"makeIncrementer(forIncrement:)"},{"type":"text","text":" function defines an integer variable called "},{"code":"runningTotal","type":"codeVoice"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"to store the current running total of the incrementer that will be returned."},{"text":" ","type":"text"},{"type":"text","text":"This variable is initialized with a value of "},{"type":"codeVoice","code":"0"},{"type":"text","text":"."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"type":"codeVoice","code":"makeIncrementer(forIncrement:)"},{"text":" function has a single ","type":"text"},{"code":"Int","type":"codeVoice"},{"text":" parameter","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"with an argument label of "},{"code":"forIncrement","type":"codeVoice"},{"type":"text","text":", and a parameter name of "},{"type":"codeVoice","code":"amount"},{"type":"text","text":"."},{"text":" ","type":"text"},{"type":"text","text":"The argument value passed to this parameter specifies"},{"type":"text","text":" "},{"type":"text","text":"how much "},{"type":"codeVoice","code":"runningTotal"},{"type":"text","text":" should be incremented by"},{"type":"text","text":" "},{"text":"each time the returned incrementer function is called.","type":"text"},{"text":" ","type":"text"},{"text":"The ","type":"text"},{"type":"codeVoice","code":"makeIncrementer"},{"type":"text","text":" function defines a nested function called "},{"code":"incrementer","type":"codeVoice"},{"text":",","type":"text"},{"type":"text","text":" "},{"text":"which performs the actual incrementing.","type":"text"},{"type":"text","text":" "},{"text":"This function simply adds ","type":"text"},{"type":"codeVoice","code":"amount"},{"text":" to ","type":"text"},{"type":"codeVoice","code":"runningTotal"},{"type":"text","text":", and returns the result."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"When considered in isolation,"},{"text":" ","type":"text"},{"text":"the nested ","type":"text"},{"code":"incrementer()","type":"codeVoice"},{"type":"text","text":" function might seem unusual:"}]},{"type":"codeListing","syntax":"swift","code":["func incrementer() -> Int {","    runningTotal += amount","    return runningTotal","}"]},{"type":"paragraph","inlineContent":[{"text":"The ","type":"text"},{"code":"incrementer()","type":"codeVoice"},{"text":" function doesn’t have any parameters,","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"and yet it refers to "},{"code":"runningTotal","type":"codeVoice"},{"type":"text","text":" and "},{"type":"codeVoice","code":"amount"},{"text":" from within its function body.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"It does this by capturing a "},{"type":"emphasis","inlineContent":[{"type":"text","text":"reference"}]},{"type":"text","text":" to "},{"type":"codeVoice","code":"runningTotal"},{"type":"text","text":" and "},{"type":"codeVoice","code":"amount"},{"type":"text","text":" "},{"type":"text","text":"from the surrounding function and using them within its own function body."},{"type":"text","text":" "},{"text":"Capturing by reference ensures that ","type":"text"},{"type":"codeVoice","code":"runningTotal"},{"type":"text","text":" and "},{"code":"amount","type":"codeVoice"},{"text":" don’t disappear","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"when the call to "},{"code":"makeIncrementer","type":"codeVoice"},{"text":" ends,","type":"text"},{"type":"text","text":" "},{"text":"and also ensures that ","type":"text"},{"code":"runningTotal","type":"codeVoice"},{"type":"text","text":" is available"},{"text":" ","type":"text"},{"type":"text","text":"the next time the "},{"code":"incrementer","type":"codeVoice"},{"type":"text","text":" function is called."}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"As an optimization,","type":"text"},{"text":" ","type":"text"},{"text":"Swift may instead capture and store a ","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"copy"}]},{"type":"text","text":" of a value"},{"type":"text","text":" "},{"type":"text","text":"if that value isn’t mutated by a closure,"},{"text":" ","type":"text"},{"type":"text","text":"and if the value isn’t mutated after the closure is created."}]},{"type":"paragraph","inlineContent":[{"text":"Swift also handles all memory management involved in disposing of","type":"text"},{"type":"text","text":" "},{"type":"text","text":"variables when they’re no longer needed."}]}],"style":"note","type":"aside","name":"Note"},{"inlineContent":[{"text":"Here’s an example of ","type":"text"},{"type":"codeVoice","code":"makeIncrementer"},{"type":"text","text":" in action:"}],"type":"paragraph"},{"type":"codeListing","syntax":"swift","code":["let incrementByTen = makeIncrementer(forIncrement: 10)"]},{"inlineContent":[{"type":"text","text":"This example sets a constant called "},{"type":"codeVoice","code":"incrementByTen"},{"text":" ","type":"text"},{"type":"text","text":"to refer to an incrementer function that adds "},{"code":"10","type":"codeVoice"},{"type":"text","text":" to"},{"type":"text","text":" "},{"type":"text","text":"its "},{"type":"codeVoice","code":"runningTotal"},{"type":"text","text":" variable each time it’s called."},{"type":"text","text":" "},{"text":"Calling the function multiple times shows this behavior in action:","type":"text"}],"type":"paragraph"},{"code":["incrementByTen()","\/\/ returns a value of 10","incrementByTen()","\/\/ returns a value of 20","incrementByTen()","\/\/ returns a value of 30"],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"text":"If you create a second incrementer,","type":"text"},{"type":"text","text":" "},{"type":"text","text":"it will have its own stored reference to a new, separate "},{"code":"runningTotal","type":"codeVoice"},{"type":"text","text":" variable:"}],"type":"paragraph"},{"code":["let incrementBySeven = makeIncrementer(forIncrement: 7)","incrementBySeven()","\/\/ returns a value of 7"],"syntax":"swift","type":"codeListing"},{"inlineContent":[{"text":"Calling the original incrementer (","type":"text"},{"type":"codeVoice","code":"incrementByTen"},{"text":") again","type":"text"},{"type":"text","text":" "},{"type":"text","text":"continues to increment its own "},{"code":"runningTotal","type":"codeVoice"},{"text":" variable,","type":"text"},{"type":"text","text":" "},{"text":"and doesn’t affect the variable captured by ","type":"text"},{"code":"incrementBySeven","type":"codeVoice"},{"text":":","type":"text"}],"type":"paragraph"},{"syntax":"swift","code":["incrementByTen()","\/\/ returns a value of 40"],"type":"codeListing"},{"name":"Note","style":"note","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"If you assign a closure to a property of a class instance,"},{"text":" ","type":"text"},{"text":"and the closure captures that instance by referring to the instance or its members,","type":"text"},{"text":" ","type":"text"},{"text":"you will create a strong reference cycle between the closure and the instance.","type":"text"},{"text":" ","type":"text"},{"text":"Swift uses ","type":"text"},{"inlineContent":[{"type":"text","text":"capture lists"}],"type":"emphasis"},{"type":"text","text":" to break these strong reference cycles."},{"type":"text","text":" "},{"text":"For more information, see ","type":"text"},{"type":"reference","isActive":true,"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/AutomaticReferenceCounting#Ciclos-de-referencias-fuertes-para-clausuras"},{"type":"text","text":"."}]}],"type":"aside"},{"type":"heading","text":"Las clausuras son tipos de referencia","anchor":"Las-clausuras-son-tipos-de-referencia","level":2},{"type":"paragraph","inlineContent":[{"type":"text","text":"In the example above,"},{"text":" ","type":"text"},{"type":"codeVoice","code":"incrementBySeven"},{"type":"text","text":" and "},{"type":"codeVoice","code":"incrementByTen"},{"type":"text","text":" are constants,"},{"text":" ","type":"text"},{"type":"text","text":"but the closures these constants refer to are still able to increment"},{"text":" ","type":"text"},{"text":"the ","type":"text"},{"type":"codeVoice","code":"runningTotal"},{"type":"text","text":" variables that they have captured."},{"type":"text","text":" "},{"type":"text","text":"This is because functions and closures are "},{"inlineContent":[{"type":"text","text":"reference types"}],"type":"emphasis"},{"type":"text","text":"."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Whenever you assign a function or a closure to a constant or a variable,"},{"type":"text","text":" "},{"type":"text","text":"you are actually setting that constant or variable to be"},{"type":"text","text":" "},{"type":"text","text":"a "},{"inlineContent":[{"type":"text","text":"reference"}],"type":"emphasis"},{"text":" to the function or closure.","type":"text"},{"text":" ","type":"text"},{"text":"In the example above,","type":"text"},{"text":" ","type":"text"},{"text":"it’s the choice of closure that ","type":"text"},{"type":"codeVoice","code":"incrementByTen"},{"type":"text","text":" "},{"inlineContent":[{"text":"refers to","type":"text"}],"type":"emphasis"},{"text":" that’s constant,","type":"text"},{"type":"text","text":" "},{"type":"text","text":"and not the contents of the closure itself."}]},{"type":"paragraph","inlineContent":[{"text":"This also means that if you assign a closure to two different constants or variables,","type":"text"},{"type":"text","text":" "},{"text":"both of those constants or variables refer to the same closure.","type":"text"}]},{"code":["let alsoIncrementByTen = incrementByTen","alsoIncrementByTen()","\/\/ returns a value of 50","","incrementByTen()","\/\/ returns a value of 60"],"type":"codeListing","syntax":"swift"},{"type":"paragraph","inlineContent":[{"type":"text","text":"The example above shows that calling "},{"code":"alsoIncrementByTen","type":"codeVoice"},{"text":" ","type":"text"},{"text":"is the same as calling ","type":"text"},{"code":"incrementByTen","type":"codeVoice"},{"text":".","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"Because both of them refer to the same closure,"},{"text":" ","type":"text"},{"text":"they both increment and return the same running total.","type":"text"}]},{"anchor":"Clausuras-que-escapan","text":"Clausuras que escapan","type":"heading","level":2},{"type":"paragraph","inlineContent":[{"text":"A closure is said to ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"escape","type":"text"}]},{"text":" a function","type":"text"},{"type":"text","text":" "},{"type":"text","text":"when the closure is passed as an argument to the function,"},{"type":"text","text":" "},{"text":"but is called after the function returns.","type":"text"},{"type":"text","text":" "},{"text":"When you declare a function that takes a closure as one of its parameters,","type":"text"},{"type":"text","text":" "},{"type":"text","text":"you can write "},{"type":"codeVoice","code":"@escaping"},{"type":"text","text":" before the parameter’s type"},{"text":" ","type":"text"},{"type":"text","text":"to indicate that the closure is allowed to escape."}]},{"inlineContent":[{"text":"One way that a closure can escape","type":"text"},{"type":"text","text":" "},{"text":"is by being stored in a variable that’s defined outside the function.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"As an example,"},{"type":"text","text":" "},{"type":"text","text":"many functions that start an asynchronous operation"},{"type":"text","text":" "},{"text":"take a closure argument as a completion handler.","type":"text"},{"type":"text","text":" "},{"text":"The function returns after it starts the operation,","type":"text"},{"type":"text","text":" "},{"text":"but the closure isn’t called until the operation is completed —","type":"text"},{"type":"text","text":" "},{"type":"text","text":"the closure needs to escape, to be called later."},{"text":" ","type":"text"},{"type":"text","text":"For example:"}],"type":"paragraph"},{"code":["var completionHandlers: [() -> Void] = []","func someFunctionWithEscapingClosure(completionHandler: @escaping () -> Void) {","    completionHandlers.append(completionHandler)","}"],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"type":"text","text":"The "},{"type":"codeVoice","code":"someFunctionWithEscapingClosure(_:)"},{"type":"text","text":" function takes a closure as its argument"},{"type":"text","text":" "},{"type":"text","text":"and adds it to an array that’s declared outside the function."},{"type":"text","text":" "},{"type":"text","text":"If you didn’t mark the parameter of this function with "},{"type":"codeVoice","code":"@escaping"},{"type":"text","text":","},{"text":" ","type":"text"},{"type":"text","text":"you would get a compile-time error."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"An escaping closure that refers to "},{"type":"codeVoice","code":"self"},{"type":"text","text":" "},{"type":"text","text":"needs special consideration if "},{"code":"self","type":"codeVoice"},{"text":" refers to an instance of a class.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"Capturing "},{"type":"codeVoice","code":"self"},{"text":" in an escaping closure","type":"text"},{"type":"text","text":" "},{"type":"text","text":"makes it easy to accidentally create a strong reference cycle."},{"type":"text","text":" "},{"type":"text","text":"For information about reference cycles,"},{"text":" ","type":"text"},{"text":"see ","type":"text"},{"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/AutomaticReferenceCounting","type":"reference","isActive":true},{"type":"text","text":"."}],"type":"paragraph"},{"inlineContent":[{"text":"Normally, a closure captures variables implicitly","type":"text"},{"text":" ","type":"text"},{"text":"by using them in the body of the closure,","type":"text"},{"text":" ","type":"text"},{"text":"but in this case you need to be explicit.","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"If you want to capture "},{"type":"codeVoice","code":"self"},{"text":",","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"write "},{"type":"codeVoice","code":"self"},{"text":" explicitly when you use it,","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"or include "},{"code":"self","type":"codeVoice"},{"text":" in the closure’s capture list.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"Writing "},{"type":"codeVoice","code":"self"},{"type":"text","text":" explicitly lets you express your intent,"},{"type":"text","text":" "},{"text":"and reminds you to confirm that there isn’t a reference cycle.","type":"text"},{"type":"text","text":" "},{"text":"For example, in the code below,","type":"text"},{"type":"text","text":" "},{"text":"the closure passed to ","type":"text"},{"code":"someFunctionWithEscapingClosure(_:)","type":"codeVoice"},{"type":"text","text":" "},{"type":"text","text":"refers to "},{"code":"self","type":"codeVoice"},{"text":" explicitly.","type":"text"},{"type":"text","text":" "},{"text":"In contrast, the closure passed to ","type":"text"},{"type":"codeVoice","code":"someFunctionWithNonescapingClosure(_:)"},{"type":"text","text":" "},{"type":"text","text":"is a nonescaping closure, which means it can refer to "},{"type":"codeVoice","code":"self"},{"text":" implicitly.","type":"text"}],"type":"paragraph"},{"code":["func someFunctionWithNonescapingClosure(closure: () -> Void) {","    closure()","}","","class SomeClass {","    var x = 10","    func doSomething() {","        someFunctionWithEscapingClosure { self.x = 100 }","        someFunctionWithNonescapingClosure { x = 200 }","    }","}","","let instance = SomeClass()","instance.doSomething()","print(instance.x)","\/\/ Prints \"200\"","","completionHandlers.first?()","print(instance.x)","\/\/ Prints \"100\""],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"text":"Here’s a version of ","type":"text"},{"type":"codeVoice","code":"doSomething()"},{"type":"text","text":" that captures "},{"code":"self","type":"codeVoice"},{"type":"text","text":" "},{"text":"by including it in the closure’s capture list,","type":"text"},{"text":" ","type":"text"},{"text":"and then refers to ","type":"text"},{"code":"self","type":"codeVoice"},{"type":"text","text":" implicitly:"}],"type":"paragraph"},{"code":["class SomeOtherClass {","    var x = 10","    func doSomething() {","        someFunctionWithEscapingClosure { [self] in x = 100 }","        someFunctionWithNonescapingClosure { x = 200 }","    }","}"],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"type":"text","text":"If "},{"type":"codeVoice","code":"self"},{"text":" is an instance of a structure or an enumeration,","type":"text"},{"type":"text","text":" "},{"text":"you can always refer to ","type":"text"},{"code":"self","type":"codeVoice"},{"type":"text","text":" implicitly."},{"type":"text","text":" "},{"text":"However,","type":"text"},{"text":" ","type":"text"},{"text":"an escaping closure can’t capture a mutable reference to ","type":"text"},{"code":"self","type":"codeVoice"},{"text":" ","type":"text"},{"type":"text","text":"when "},{"code":"self","type":"codeVoice"},{"text":" is an instance of a structure or an enumeration.","type":"text"},{"type":"text","text":" "},{"text":"Structures and enumerations don’t allow shared mutability,","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"as discussed in "},{"isActive":true,"type":"reference","identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/ClassesAndStructures#Las-estructuras-y-las-enumeraciones-son-tipos-de-valor"},{"type":"text","text":"."}],"type":"paragraph"},{"syntax":"swift","code":["struct SomeStruct {","    var x = 10","    mutating func doSomething() {","        someFunctionWithNonescapingClosure { x = 200 }  \/\/ Ok","        someFunctionWithEscapingClosure { x = 100 }     \/\/ Error","    }","}"],"type":"codeListing"},{"inlineContent":[{"text":"The call to the ","type":"text"},{"type":"codeVoice","code":"someFunctionWithEscapingClosure"},{"text":" function","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"in the example above is an error"},{"type":"text","text":" "},{"type":"text","text":"because it’s inside a mutating method,"},{"text":" ","type":"text"},{"type":"text","text":"so "},{"code":"self","type":"codeVoice"},{"type":"text","text":" is mutable."},{"text":" ","type":"text"},{"type":"text","text":"That violates the rule that escaping closures can’t capture"},{"type":"text","text":" "},{"type":"text","text":"a mutable reference to "},{"type":"codeVoice","code":"self"},{"type":"text","text":" for structures."}],"type":"paragraph"},{"anchor":"Autoclausuras","level":2,"type":"heading","text":"Autoclausuras"},{"type":"paragraph","inlineContent":[{"type":"text","text":"An "},{"inlineContent":[{"type":"text","text":"autoclosure"}],"type":"emphasis"},{"type":"text","text":" is a closure that’s automatically created"},{"text":" ","type":"text"},{"type":"text","text":"to wrap an expression that’s being passed as an argument to a function."},{"text":" ","type":"text"},{"type":"text","text":"It doesn’t take any arguments,"},{"text":" ","type":"text"},{"type":"text","text":"and when it’s called, it returns the value"},{"type":"text","text":" "},{"text":"of the expression that’s wrapped inside of it.","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"This syntactic convenience lets you omit braces around a function’s parameter"},{"type":"text","text":" "},{"text":"by writing a normal expression instead of an explicit closure.","type":"text"}]},{"inlineContent":[{"text":"It’s common to ","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"call"}]},{"text":" functions that take autoclosures,","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"but it’s not common to "},{"inlineContent":[{"type":"text","text":"implement"}],"type":"emphasis"},{"text":" that kind of function.","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"For example,"},{"text":" ","type":"text"},{"type":"text","text":"the "},{"code":"assert(condition:message:file:line:)","type":"codeVoice"},{"type":"text","text":" function"},{"text":" ","type":"text"},{"text":"takes an autoclosure for its ","type":"text"},{"code":"condition","type":"codeVoice"},{"type":"text","text":" and "},{"code":"message","type":"codeVoice"},{"type":"text","text":" parameters;"},{"type":"text","text":" "},{"text":"its ","type":"text"},{"type":"codeVoice","code":"condition"},{"type":"text","text":" parameter is evaluated only in debug builds"},{"text":" ","type":"text"},{"text":"and its ","type":"text"},{"code":"message","type":"codeVoice"},{"type":"text","text":" parameter is evaluated only if "},{"code":"condition","type":"codeVoice"},{"type":"text","text":" is "},{"code":"false","type":"codeVoice"},{"type":"text","text":"."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"text":"An autoclosure lets you delay evaluation,","type":"text"},{"type":"text","text":" "},{"type":"text","text":"because the code inside isn’t run until you call the closure."},{"type":"text","text":" "},{"type":"text","text":"Delaying evaluation is useful for code"},{"type":"text","text":" "},{"text":"that has side effects or is computationally expensive,","type":"text"},{"type":"text","text":" "},{"text":"because it lets you control when that code is evaluated.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"The code below shows how a closure delays evaluation."}]},{"type":"codeListing","syntax":"swift","code":["var customersInLine = [\"Chris\", \"Alex\", \"Ewa\", \"Barry\", \"Daniella\"]","print(customersInLine.count)","\/\/ Prints \"5\"","","let customerProvider = { customersInLine.remove(at: 0) }","print(customersInLine.count)","\/\/ Prints \"5\"","","print(\"Now serving \\(customerProvider())!\")","\/\/ Prints \"Now serving Chris!\"","print(customersInLine.count)","\/\/ Prints \"4\""]},{"inlineContent":[{"type":"text","text":"Even though the first element of the "},{"type":"codeVoice","code":"customersInLine"},{"text":" array is removed","type":"text"},{"type":"text","text":" "},{"type":"text","text":"by the code inside the closure,"},{"type":"text","text":" "},{"text":"the array element isn’t removed until the closure is actually called.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"If the closure is never called,"},{"type":"text","text":" "},{"type":"text","text":"the expression inside the closure is never evaluated,"},{"type":"text","text":" "},{"text":"which means the array element is never removed.","type":"text"},{"type":"text","text":" "},{"text":"Note that the type of ","type":"text"},{"type":"codeVoice","code":"customerProvider"},{"text":" isn’t ","type":"text"},{"type":"codeVoice","code":"String"},{"type":"text","text":" "},{"type":"text","text":"but "},{"type":"codeVoice","code":"() -> String"},{"type":"text","text":" —"},{"type":"text","text":" "},{"type":"text","text":"a function with no parameters that returns a string."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"text":"You get the same behavior of delayed evaluation","type":"text"},{"text":" ","type":"text"},{"text":"when you pass a closure as an argument to a function.","type":"text"}]},{"code":["\/\/ customersInLine is [\"Alex\", \"Ewa\", \"Barry\", \"Daniella\"]","func serve(customer customerProvider: () -> String) {","    print(\"Now serving \\(customerProvider())!\")","}","serve(customer: { customersInLine.remove(at: 0) } )","\/\/ Prints \"Now serving Alex!\""],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"text":"The ","type":"text"},{"type":"codeVoice","code":"serve(customer:)"},{"type":"text","text":" function in the listing above"},{"type":"text","text":" "},{"text":"takes an explicit closure that returns a customer’s name.","type":"text"},{"type":"text","text":" "},{"text":"The version of ","type":"text"},{"code":"serve(customer:)","type":"codeVoice"},{"text":" below","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"performs the same operation but, instead of taking an explicit closure,"},{"text":" ","type":"text"},{"text":"it takes an autoclosure","type":"text"},{"text":" ","type":"text"},{"text":"by marking its parameter’s type with the ","type":"text"},{"type":"codeVoice","code":"@autoclosure"},{"type":"text","text":" attribute."},{"type":"text","text":" "},{"type":"text","text":"Now you can call the function"},{"type":"text","text":" "},{"text":"as if it took a ","type":"text"},{"code":"String","type":"codeVoice"},{"text":" argument instead of a closure.","type":"text"},{"text":" ","type":"text"},{"text":"The argument is automatically converted to a closure,","type":"text"},{"type":"text","text":" "},{"text":"because the ","type":"text"},{"type":"codeVoice","code":"customerProvider"},{"type":"text","text":" parameter’s type is marked"},{"type":"text","text":" "},{"text":"with the ","type":"text"},{"type":"codeVoice","code":"@autoclosure"},{"text":" attribute.","type":"text"}],"type":"paragraph"},{"code":["\/\/ customersInLine is [\"Ewa\", \"Barry\", \"Daniella\"]","func serve(customer customerProvider: @autoclosure () -> String) {","    print(\"Now serving \\(customerProvider())!\")","}","serve(customer: customersInLine.remove(at: 0))","\/\/ Prints \"Now serving Ewa!\""],"syntax":"swift","type":"codeListing"},{"style":"note","name":"Note","type":"aside","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Overusing autoclosures can make your code hard to understand."},{"type":"text","text":" "},{"text":"The context and function name should make it clear","type":"text"},{"text":" ","type":"text"},{"text":"that evaluation is being deferred.","type":"text"}]}]},{"inlineContent":[{"type":"text","text":"If you want an autoclosure that’s allowed to escape,"},{"type":"text","text":" "},{"type":"text","text":"use both the "},{"code":"@autoclosure","type":"codeVoice"},{"type":"text","text":" and "},{"type":"codeVoice","code":"@escaping"},{"type":"text","text":" attributes."},{"text":" ","type":"text"},{"text":"The ","type":"text"},{"type":"codeVoice","code":"@escaping"},{"text":" attribute is described above in ","type":"text"},{"type":"reference","isActive":true,"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Closures#Clausuras-que-escapan"},{"type":"text","text":"."}],"type":"paragraph"},{"syntax":"swift","code":["\/\/ customersInLine is [\"Barry\", \"Daniella\"]","var customerProviders: [() -> String] = []","func collectCustomerProviders(_ customerProvider: @autoclosure @escaping () -> String) {","    customerProviders.append(customerProvider)","}","collectCustomerProviders(customersInLine.remove(at: 0))","collectCustomerProviders(customersInLine.remove(at: 0))","","print(\"Collected \\(customerProviders.count) closures.\")","\/\/ Prints \"Collected 2 closures.\"","for customerProvider in customerProviders {","    print(\"Now serving \\(customerProvider())!\")","}","\/\/ Prints \"Now serving Barry!\"","\/\/ Prints \"Now serving Daniella!\""],"type":"codeListing"},{"type":"paragraph","inlineContent":[{"type":"text","text":"In the code above,"},{"text":" ","type":"text"},{"type":"text","text":"instead of calling the closure passed to it"},{"type":"text","text":" "},{"type":"text","text":"as its "},{"type":"codeVoice","code":"customerProvider"},{"text":" argument,","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"the "},{"type":"codeVoice","code":"collectCustomerProviders(_:)"},{"type":"text","text":" function"},{"text":" ","type":"text"},{"text":"appends the closure to the ","type":"text"},{"type":"codeVoice","code":"customerProviders"},{"type":"text","text":" array."},{"text":" ","type":"text"},{"text":"The array is declared outside the scope of the function,","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"which means the closures in the array can be executed after the function returns."},{"type":"text","text":" "},{"text":"As a result,","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"the value of the "},{"type":"codeVoice","code":"customerProvider"},{"type":"text","text":" argument"},{"text":" ","type":"text"},{"text":"must be allowed to escape the function’s scope.","type":"text"}]},{"style":"note","type":"aside","content":[{"inlineContent":[{"type":"text","text":""}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Esta documentación contiene información preliminar sobre una API o tecnología en desarrollo. Esta información está sujeta a cambios, y todo software implementado en conformidad con esta documentación debe ser testeado con el software final del sistema operativo."}]},{"type":"paragraph","inlineContent":[{"text":"Conoce más acerca del uso del ","type":"text"},{"isActive":true,"type":"reference","identifier":"https:\/\/developer.apple.com\/es\/support\/beta-software\/"},{"text":".","type":"text"}]}],"name":"Software Beta"}],"kind":"content"}],"identifier":{"interfaceLanguage":"swift","url":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Closures"},"abstract":[{"text":"Group code that executes together, without creating a named function.","type":"text"}],"metadata":{"title":"Clausuras"},"sections":[],"hierarchy":{"paths":[["doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language"]]},"schemaVersion":{"minor":3,"patch":0,"major":0},"kind":"article","references":{"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Closures#Captura-de-valores":{"type":"topic","title":"Captura de valores","url":"\/documentation\/the-swift-programming-language\/closures#Captura-de-valores","kind":"section","identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Closures#Captura-de-valores","abstract":[]},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/AutomaticReferenceCounting#Ciclos-de-referencias-fuertes-para-clausuras":{"type":"topic","title":"Ciclos de referencias fuertes para clausuras","url":"\/documentation\/the-swift-programming-language\/automaticreferencecounting#Ciclos-de-referencias-fuertes-para-clausuras","kind":"section","identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/AutomaticReferenceCounting#Ciclos-de-referencias-fuertes-para-clausuras","abstract":[]},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/AutomaticReferenceCounting":{"title":"Conteo automático de referencias","kind":"article","role":"article","url":"\/documentation\/the-swift-programming-language\/automaticreferencecounting","abstract":[{"text":"Model the lifetime of objects and their relationships.","type":"text"}],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/AutomaticReferenceCounting","type":"topic"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Functions":{"kind":"article","abstract":[{"type":"text","text":"Define and call functions, label their arguments, and use their return values."}],"role":"article","type":"topic","title":"Funciones","url":"\/documentation\/the-swift-programming-language\/functions","identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Functions"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/AdvancedOperators#M%C3%A9todos-operadores":{"type":"topic","title":"Métodos operadores","url":"\/documentation\/the-swift-programming-language\/advancedoperators#M%C3%A9todos-operadores","kind":"section","identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/AdvancedOperators#M%C3%A9todos-operadores","abstract":[]},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/ClassesAndStructures#Las-estructuras-y-las-enumeraciones-son-tipos-de-valor":{"type":"topic","title":"Las estructuras y las enumeraciones son tipos de valor","url":"\/documentation\/the-swift-programming-language\/classesandstructures#Las-estructuras-y-las-enumeraciones-son-tipos-de-valor","kind":"section","identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/ClassesAndStructures#Las-estructuras-y-las-enumeraciones-son-tipos-de-valor","abstract":[]},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Closures#Clausuras-que-escapan":{"type":"topic","title":"Clausuras que escapan","url":"\/documentation\/the-swift-programming-language\/closures#Clausuras-que-escapan","kind":"section","identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Closures#Clausuras-que-escapan","abstract":[]},"https://developer.apple.com/es/support/beta-software/":{"type":"link","title":"software beta de Apple","url":"https:\/\/developer.apple.com\/es\/support\/beta-software\/","identifier":"https:\/\/developer.apple.com\/es\/support\/beta-software\/","titleInlineContent":[{"type":"text","text":"software beta de Apple"}]},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Concurrency":{"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Concurrency","abstract":[{"text":"Perform asynchronous operations.","type":"text"}],"kind":"article","role":"article","url":"\/documentation\/the-swift-programming-language\/concurrency","type":"topic","title":"Concurrencia"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language":{"kind":"article","role":"collection","url":"\/documentation\/the-swift-programming-language","abstract":[],"title":"The Swift Programming Language (6)","type":"topic","identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Closures#Sintaxis-de-expresiones-clausura":{"type":"topic","title":"Sintaxis de expresiones clausura","url":"\/documentation\/the-swift-programming-language\/closures#Sintaxis-de-expresiones-clausura","kind":"section","identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Closures#Sintaxis-de-expresiones-clausura","abstract":[]}}}
=======
{"identifier":{"url":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Closures","interfaceLanguage":"swift"},"kind":"article","primaryContentSections":[{"content":[{"type":"paragraph","inlineContent":[{"inlineContent":[{"text":"Closures","type":"text"}],"type":"emphasis"},{"type":"text","text":" are self-contained blocks of functionality"},{"text":" ","type":"text"},{"type":"text","text":"that can be passed around and used in your code."},{"type":"text","text":" "},{"type":"text","text":"Closures in Swift are similar to blocks in C and Objective-C"},{"type":"text","text":" "},{"type":"text","text":"and to lambdas in other programming languages."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Closures can capture and store references to any constants and variables"},{"type":"text","text":" "},{"text":"from the context in which they’re defined.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"This is known as "},{"inlineContent":[{"text":"closing over","type":"text"}],"type":"emphasis"},{"text":" those constants and variables.","type":"text"},{"text":" ","type":"text"},{"text":"Swift handles all of the memory management of capturing for you.","type":"text"}]},{"style":"note","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Don’t worry if you aren’t familiar with the concept of capturing."},{"type":"text","text":" "},{"text":"It’s explained in detail below in ","type":"text"},{"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Closures#Captura-de-valores","isActive":true,"type":"reference"},{"text":".","type":"text"}]}],"name":"Note","type":"aside"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Global and nested functions, as introduced in "},{"type":"reference","isActive":true,"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Functions"},{"text":",","type":"text"},{"type":"text","text":" "},{"type":"text","text":"are actually special cases of closures."},{"type":"text","text":" "},{"text":"Closures take one of three forms:","type":"text"}]},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"Global functions are closures that have a name","type":"text"},{"type":"text","text":" "},{"type":"text","text":"and don’t capture any values."}]}]},{"content":[{"inlineContent":[{"type":"text","text":"Nested functions are closures that have a name"},{"text":" ","type":"text"},{"type":"text","text":"and can capture values from their enclosing function."}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"text","text":"Closure expressions are unnamed closures written in a lightweight syntax"},{"type":"text","text":" "},{"type":"text","text":"that can capture values from their surrounding context."}],"type":"paragraph"}]}],"type":"unorderedList"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Swift’s closure expressions have a clean, clear style,"},{"text":" ","type":"text"},{"text":"with optimizations that encourage brief, clutter-free syntax in common scenarios.","type":"text"},{"type":"text","text":" "},{"text":"These optimizations include:","type":"text"}]},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Inferring parameter and return value types from context"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"Implicit returns from single-expression closures","type":"text"}]}]},{"content":[{"inlineContent":[{"type":"text","text":"Shorthand argument names"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"text":"Trailing closure syntax","type":"text"}],"type":"paragraph"}]}],"type":"unorderedList"},{"type":"heading","anchor":"Expresiones-clausura","text":"Expresiones clausura","level":2},{"type":"paragraph","inlineContent":[{"type":"text","text":"Nested functions, as introduced in "},{"type":"text","text":"doc:Functions#Funciones-anidadas"},{"text":",","type":"text"},{"type":"text","text":" "},{"type":"text","text":"are a convenient means of naming and defining self-contained blocks of code"},{"type":"text","text":" "},{"text":"as part of a larger function.","type":"text"},{"type":"text","text":" "},{"text":"However, it’s sometimes useful to write shorter versions of function-like constructs","type":"text"},{"type":"text","text":" "},{"text":"without a full declaration and name.","type":"text"},{"type":"text","text":" "},{"text":"This is particularly true when you work with functions or methods that take functions","type":"text"},{"text":" ","type":"text"},{"text":"as one or more of their arguments.","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"emphasis","inlineContent":[{"type":"text","text":"Closure expressions"}]},{"type":"text","text":" are a way to write inline closures in a brief, focused syntax."},{"text":" ","type":"text"},{"type":"text","text":"Closure expressions provide several syntax optimizations"},{"type":"text","text":" "},{"text":"for writing closures in a shortened form without loss of clarity or intent.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"The closure expression examples below illustrate these optimizations"},{"type":"text","text":" "},{"text":"by refining a single example of the ","type":"text"},{"code":"sorted(by:)","type":"codeVoice"},{"type":"text","text":" method over several iterations,"},{"text":" ","type":"text"},{"type":"text","text":"each of which expresses the same functionality in a more succinct way."}]},{"level":3,"text":"El método sorted","type":"heading","anchor":"El-m%C3%A9todo-sorted"},{"type":"paragraph","inlineContent":[{"text":"Swift’s standard library provides a method called ","type":"text"},{"code":"sorted(by:)","type":"codeVoice"},{"type":"text","text":","},{"text":" ","type":"text"},{"type":"text","text":"which sorts an array of values of a known type,"},{"type":"text","text":" "},{"type":"text","text":"based on the output of a sorting closure that you provide."},{"type":"text","text":" "},{"type":"text","text":"Once it completes the sorting process,"},{"type":"text","text":" "},{"type":"text","text":"the "},{"type":"codeVoice","code":"sorted(by:)"},{"type":"text","text":" method returns a new array of the same type and size as the old one,"},{"type":"text","text":" "},{"type":"text","text":"with its elements in the correct sorted order."},{"type":"text","text":" "},{"type":"text","text":"The original array isn’t modified by the "},{"type":"codeVoice","code":"sorted(by:)"},{"type":"text","text":" method."}]},{"inlineContent":[{"type":"text","text":"The closure expression examples below use the "},{"type":"codeVoice","code":"sorted(by:)"},{"type":"text","text":" method"},{"text":" ","type":"text"},{"type":"text","text":"to sort an array of "},{"type":"codeVoice","code":"String"},{"type":"text","text":" values in reverse alphabetical order."},{"type":"text","text":" "},{"text":"Here’s the initial array to be sorted:","type":"text"}],"type":"paragraph"},{"code":["let names = [\"Chris\", \"Alex\", \"Ewa\", \"Barry\", \"Daniella\"]"],"syntax":"swift","type":"codeListing"},{"type":"paragraph","inlineContent":[{"text":"The ","type":"text"},{"code":"sorted(by:)","type":"codeVoice"},{"type":"text","text":" method accepts a closure that takes two arguments"},{"type":"text","text":" "},{"type":"text","text":"of the same type as the array’s contents,"},{"text":" ","type":"text"},{"type":"text","text":"and returns a "},{"code":"Bool","type":"codeVoice"},{"text":" value to say whether the first value should appear","type":"text"},{"type":"text","text":" "},{"text":"before or after the second value once the values are sorted.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"The sorting closure needs to return "},{"type":"codeVoice","code":"true"},{"text":" ","type":"text"},{"type":"text","text":"if the first value should appear "},{"inlineContent":[{"type":"text","text":"before"}],"type":"emphasis"},{"type":"text","text":" the second value,"},{"type":"text","text":" "},{"type":"text","text":"and "},{"code":"false","type":"codeVoice"},{"text":" otherwise.","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"This example is sorting an array of ","type":"text"},{"type":"codeVoice","code":"String"},{"text":" values,","type":"text"},{"type":"text","text":" "},{"type":"text","text":"and so the sorting closure needs to be a function of type "},{"type":"codeVoice","code":"(String, String) -> Bool"},{"text":".","type":"text"}]},{"inlineContent":[{"text":"One way to provide the sorting closure is to write a normal function of the correct type,","type":"text"},{"type":"text","text":" "},{"type":"text","text":"and to pass it in as an argument to the "},{"code":"sorted(by:)","type":"codeVoice"},{"text":" method:","type":"text"}],"type":"paragraph"},{"type":"codeListing","code":["func backward(_ s1: String, _ s2: String) -> Bool {","    return s1 > s2","}","var reversedNames = names.sorted(by: backward)","\/\/ reversedNames is equal to [\"Ewa\", \"Daniella\", \"Chris\", \"Barry\", \"Alex\"]"],"syntax":"swift"},{"inlineContent":[{"type":"text","text":"If the first string ("},{"code":"s1","type":"codeVoice"},{"text":") is greater than the second string (","type":"text"},{"code":"s2","type":"codeVoice"},{"text":"),","type":"text"},{"text":" ","type":"text"},{"text":"the ","type":"text"},{"code":"backward(_:_:)","type":"codeVoice"},{"text":" function will return ","type":"text"},{"code":"true","type":"codeVoice"},{"text":",","type":"text"},{"type":"text","text":" "},{"type":"text","text":"indicating that "},{"code":"s1","type":"codeVoice"},{"type":"text","text":" should appear before "},{"code":"s2","type":"codeVoice"},{"text":" in the sorted array.","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"For characters in strings,"},{"type":"text","text":" "},{"type":"text","text":"“greater than” means “appears later in the alphabet than”."},{"type":"text","text":" "},{"text":"This means that the letter ","type":"text"},{"type":"codeVoice","code":"\"B\""},{"text":" is “greater than” the letter ","type":"text"},{"code":"\"A\"","type":"codeVoice"},{"type":"text","text":","},{"text":" ","type":"text"},{"type":"text","text":"and the string "},{"type":"codeVoice","code":"\"Tom\""},{"text":" is greater than the string ","type":"text"},{"type":"codeVoice","code":"\"Tim\""},{"text":".","type":"text"},{"text":" ","type":"text"},{"text":"This gives a reverse alphabetical sort,","type":"text"},{"type":"text","text":" "},{"type":"text","text":"with "},{"type":"codeVoice","code":"\"Barry\""},{"type":"text","text":" being placed before "},{"code":"\"Alex\"","type":"codeVoice"},{"text":", and so on.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"However, this is a rather long-winded way to write","type":"text"},{"text":" ","type":"text"},{"text":"what is essentially a single-expression function (","type":"text"},{"code":"a > b","type":"codeVoice"},{"text":").","type":"text"},{"type":"text","text":" "},{"type":"text","text":"In this example, it would be preferable to write the sorting closure inline,"},{"type":"text","text":" "},{"type":"text","text":"using closure expression syntax."}],"type":"paragraph"},{"level":3,"type":"heading","text":"Sintaxis de expresiones clausura","anchor":"Sintaxis-de-expresiones-clausura"},{"type":"paragraph","inlineContent":[{"text":"Closure expression syntax has the following general form:","type":"text"}]},{"code":["{ (<#parameters#>) -> <#return type#> in","   <#statements#>","}"],"type":"codeListing","syntax":"swift"},{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"inlineContent":[{"type":"text","text":"parameters"}],"type":"emphasis"},{"text":" in closure expression syntax","type":"text"},{"type":"text","text":" "},{"type":"text","text":"can be in-out parameters,"},{"type":"text","text":" "},{"type":"text","text":"but they can’t have a default value."},{"text":" ","type":"text"},{"type":"text","text":"Variadic parameters can be used if you name the variadic parameter."},{"type":"text","text":" "},{"type":"text","text":"Tuples can also be used as parameter types and return types."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The example below shows a closure expression version of the "},{"code":"backward(_:_:)","type":"codeVoice"},{"text":" function","type":"text"},{"type":"text","text":" "},{"text":"from above:","type":"text"}]},{"code":["reversedNames = names.sorted(by: { (s1: String, s2: String) -> Bool in","    return s1 > s2","})"],"syntax":"swift","type":"codeListing"},{"type":"paragraph","inlineContent":[{"text":"Note that the declaration of parameters and return type for this inline closure","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"is identical to the declaration from the "},{"type":"codeVoice","code":"backward(_:_:)"},{"text":" function.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"In both cases, it’s written as "},{"code":"(s1: String, s2: String) -> Bool","type":"codeVoice"},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"However, for the inline closure expression,"},{"text":" ","type":"text"},{"type":"text","text":"the parameters and return type are written "},{"inlineContent":[{"text":"inside","type":"text"}],"type":"emphasis"},{"type":"text","text":" the curly braces,"},{"text":" ","type":"text"},{"text":"not outside of them.","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"The start of the closure’s body is introduced by the ","type":"text"},{"type":"codeVoice","code":"in"},{"text":" keyword.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"This keyword indicates that"},{"text":" ","type":"text"},{"text":"the definition of the closure’s parameters and return type has finished,","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"and the body of the closure is about to begin."}]},{"inlineContent":[{"type":"text","text":"Because the body of the closure is so short,"},{"text":" ","type":"text"},{"type":"text","text":"it can even be written on a single line:"}],"type":"paragraph"},{"type":"codeListing","syntax":"swift","code":["reversedNames = names.sorted(by: { (s1: String, s2: String) -> Bool in return s1 > s2 } )"]},{"type":"paragraph","inlineContent":[{"text":"This illustrates that the overall call to the ","type":"text"},{"type":"codeVoice","code":"sorted(by:)"},{"text":" method has remained the same.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"A pair of parentheses still wrap the entire argument for the method."},{"type":"text","text":" "},{"text":"However, that argument is now an inline closure.","type":"text"}]},{"text":"Inferencia de tipos a partir del contexto","type":"heading","level":3,"anchor":"Inferencia-de-tipos-a-partir-del-contexto"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Because the sorting closure is passed as an argument to a method,"},{"text":" ","type":"text"},{"text":"Swift can infer the types of its parameters","type":"text"},{"type":"text","text":" "},{"text":"and the type of the value it returns.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"The "},{"type":"codeVoice","code":"sorted(by:)"},{"text":" method is being called on an array of strings,","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"so its argument must be a function of type "},{"code":"(String, String) -> Bool","type":"codeVoice"},{"text":".","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"This means that the "},{"code":"(String, String)","type":"codeVoice"},{"type":"text","text":" and "},{"type":"codeVoice","code":"Bool"},{"text":" types don’t need to be written","type":"text"},{"type":"text","text":" "},{"text":"as part of the closure expression’s definition.","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"Because all of the types can be inferred,"},{"type":"text","text":" "},{"type":"text","text":"the return arrow ("},{"code":"->","type":"codeVoice"},{"type":"text","text":") and the parentheses around the names of the parameters"},{"type":"text","text":" "},{"type":"text","text":"can also be omitted:"}]},{"type":"codeListing","syntax":"swift","code":["reversedNames = names.sorted(by: { s1, s2 in return s1 > s2 } )"]},{"inlineContent":[{"text":"It’s always possible to infer the parameter types and return type","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"when passing a closure to a function or method as an inline closure expression."},{"text":" ","type":"text"},{"type":"text","text":"As a result, you never need to write an inline closure in its fullest form"},{"text":" ","type":"text"},{"text":"when the closure is used as a function or method argument.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"Nonetheless, you can still make the types explicit if you wish,"},{"text":" ","type":"text"},{"type":"text","text":"and doing so is encouraged if it avoids ambiguity for readers of your code."},{"text":" ","type":"text"},{"type":"text","text":"In the case of the "},{"type":"codeVoice","code":"sorted(by:)"},{"type":"text","text":" method,"},{"type":"text","text":" "},{"type":"text","text":"the purpose of the closure is clear from the fact that sorting is taking place,"},{"text":" ","type":"text"},{"text":"and it’s safe for a reader to assume that","type":"text"},{"text":" ","type":"text"},{"text":"the closure is likely to be working with ","type":"text"},{"code":"String","type":"codeVoice"},{"text":" values,","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"because it’s assisting with the sorting of an array of strings."}],"type":"paragraph"},{"text":"Devolución implícita desde clausuras de una sola expresión","level":3,"anchor":"Devoluci%C3%B3n-impl%C3%ADcita-desde-clausuras-de-una-sola-expresi%C3%B3n","type":"heading"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Single-expression closures can implicitly return the result of their single expression"},{"text":" ","type":"text"},{"type":"text","text":"by omitting the "},{"type":"codeVoice","code":"return"},{"text":" keyword from their declaration,","type":"text"},{"text":" ","type":"text"},{"text":"as in this version of the previous example:","type":"text"}]},{"syntax":"swift","code":["reversedNames = names.sorted(by: { s1, s2 in s1 > s2 } )"],"type":"codeListing"},{"inlineContent":[{"type":"text","text":"Here, the function type of the "},{"type":"codeVoice","code":"sorted(by:)"},{"text":" method’s argument","type":"text"},{"text":" ","type":"text"},{"text":"makes it clear that a ","type":"text"},{"code":"Bool","type":"codeVoice"},{"type":"text","text":" value must be returned by the closure."},{"text":" ","type":"text"},{"text":"Because the closure’s body contains a single expression (","type":"text"},{"type":"codeVoice","code":"s1 > s2"},{"type":"text","text":")"},{"text":" ","type":"text"},{"type":"text","text":"that returns a "},{"code":"Bool","type":"codeVoice"},{"text":" value,","type":"text"},{"type":"text","text":" "},{"text":"there’s no ambiguity, and the ","type":"text"},{"type":"codeVoice","code":"return"},{"text":" keyword can be omitted.","type":"text"}],"type":"paragraph"},{"level":3,"anchor":"Nombres-de-argumentos-concisos","type":"heading","text":"Nombres de argumentos concisos"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Swift automatically provides shorthand argument names to inline closures,"},{"type":"text","text":" "},{"type":"text","text":"which can be used to refer to the values of the closure’s arguments"},{"type":"text","text":" "},{"type":"text","text":"by the names "},{"code":"$0","type":"codeVoice"},{"type":"text","text":", "},{"type":"codeVoice","code":"$1"},{"type":"text","text":", "},{"code":"$2","type":"codeVoice"},{"type":"text","text":", and so on."}]},{"inlineContent":[{"type":"text","text":"If you use these shorthand argument names within your closure expression,"},{"type":"text","text":" "},{"type":"text","text":"you can omit the closure’s argument list from its definition."},{"text":" ","type":"text"},{"text":"The type of the shorthand argument names","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"is inferred from the expected function type,"},{"text":" ","type":"text"},{"text":"and the highest numbered shorthand argument you use","type":"text"},{"text":" ","type":"text"},{"text":"determines the number of arguments that the closure takes.","type":"text"},{"type":"text","text":" "},{"text":"The ","type":"text"},{"type":"codeVoice","code":"in"},{"text":" keyword can also be omitted,","type":"text"},{"type":"text","text":" "},{"text":"because the closure expression is made up entirely of its body:","type":"text"}],"type":"paragraph"},{"type":"codeListing","syntax":"swift","code":["reversedNames = names.sorted(by: { $0 > $1 } )"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Here, "},{"type":"codeVoice","code":"$0"},{"type":"text","text":" and "},{"type":"codeVoice","code":"$1"},{"text":" refer to the closure’s first and second ","type":"text"},{"type":"codeVoice","code":"String"},{"type":"text","text":" arguments."},{"type":"text","text":" "},{"text":"Because ","type":"text"},{"code":"$1","type":"codeVoice"},{"text":" is the shorthand argument with highest number,","type":"text"},{"type":"text","text":" "},{"type":"text","text":"the closure is understood to take two arguments."},{"text":" ","type":"text"},{"type":"text","text":"Because the "},{"type":"codeVoice","code":"sorted(by:)"},{"type":"text","text":" function here expects a closure"},{"text":" ","type":"text"},{"type":"text","text":"whose arguments are both strings,"},{"type":"text","text":" "},{"type":"text","text":"the shorthand arguments "},{"type":"codeVoice","code":"$0"},{"type":"text","text":" and "},{"type":"codeVoice","code":"$1"},{"text":" are both of type ","type":"text"},{"type":"codeVoice","code":"String"},{"type":"text","text":"."}]},{"anchor":"M%C3%A9todos-operadores","level":3,"text":"Métodos operadores","type":"heading"},{"inlineContent":[{"text":"There’s actually an even ","type":"text"},{"inlineContent":[{"type":"text","text":"shorter"}],"type":"emphasis"},{"type":"text","text":" way to write the closure expression above."},{"type":"text","text":" "},{"text":"Swift’s ","type":"text"},{"type":"codeVoice","code":"String"},{"text":" type defines its string-specific implementation of","type":"text"},{"type":"text","text":" "},{"text":"the greater-than operator (","type":"text"},{"code":">","type":"codeVoice"},{"text":")","type":"text"},{"type":"text","text":" "},{"text":"as a method that has two parameters of type ","type":"text"},{"code":"String","type":"codeVoice"},{"text":",","type":"text"},{"type":"text","text":" "},{"text":"and returns a value of type ","type":"text"},{"code":"Bool","type":"codeVoice"},{"type":"text","text":"."},{"type":"text","text":" "},{"text":"This exactly matches the method type needed by the ","type":"text"},{"code":"sorted(by:)","type":"codeVoice"},{"text":" method.","type":"text"},{"text":" ","type":"text"},{"text":"Therefore, you can simply pass in the greater-than operator,","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"and Swift will infer that you want to use its string-specific implementation:"}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["reversedNames = names.sorted(by: >)"]},{"inlineContent":[{"text":"For more about operator methods, see ","type":"text"},{"type":"reference","identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/AdvancedOperators#M%C3%A9todos-operadores","isActive":true},{"type":"text","text":"."}],"type":"paragraph"},{"type":"heading","text":"Clausuras colgantes","level":2,"anchor":"Clausuras-colgantes"},{"inlineContent":[{"type":"text","text":"If you need to pass a closure expression to a function as the function’s final argument"},{"type":"text","text":" "},{"text":"and the closure expression is long,","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"it can be useful to write it as a "},{"inlineContent":[{"type":"text","text":"trailing closure"}],"type":"emphasis"},{"text":" instead.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"You write a trailing closure after the function call’s parentheses,"},{"type":"text","text":" "},{"text":"even though the trailing closure is still an argument to the function.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"When you use the trailing closure syntax,"},{"text":" ","type":"text"},{"text":"you don’t write the argument label for the first closure","type":"text"},{"type":"text","text":" "},{"type":"text","text":"as part of the function call."},{"type":"text","text":" "},{"type":"text","text":"A function call can include multiple trailing closures;"},{"type":"text","text":" "},{"type":"text","text":"however, the first few examples below use a single trailing closure."}],"type":"paragraph"},{"syntax":"swift","code":["func someFunctionThatTakesAClosure(closure: () -> Void) {","    \/\/ function body goes here","}","","\/\/ Here's how you call this function without using a trailing closure:","","someFunctionThatTakesAClosure(closure: {","    \/\/ closure's body goes here","})","","\/\/ Here's how you call this function with a trailing closure instead:","","someFunctionThatTakesAClosure() {","    \/\/ trailing closure's body goes here","}"],"type":"codeListing"},{"inlineContent":[{"type":"text","text":"The string-sorting closure from the "},{"isActive":true,"type":"reference","identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Closures#Sintaxis-de-expresiones-clausura"},{"type":"text","text":" section above"},{"type":"text","text":" "},{"text":"can be written outside of the ","type":"text"},{"code":"sorted(by:)","type":"codeVoice"},{"type":"text","text":" method’s parentheses as a trailing closure:"}],"type":"paragraph"},{"code":["reversedNames = names.sorted() { $0 > $1 }"],"type":"codeListing","syntax":"swift"},{"type":"paragraph","inlineContent":[{"type":"text","text":"If a closure expression is provided as the function’s or method’s only argument"},{"type":"text","text":" "},{"type":"text","text":"and you provide that expression as a trailing closure,"},{"text":" ","type":"text"},{"text":"you don’t need to write a pair of parentheses ","type":"text"},{"code":"()","type":"codeVoice"},{"type":"text","text":" "},{"text":"after the function or method’s name when you call the function:","type":"text"}]},{"type":"codeListing","code":["reversedNames = names.sorted { $0 > $1 }"],"syntax":"swift"},{"inlineContent":[{"text":"Trailing closures are most useful when the closure is sufficiently long that","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"it isn’t possible to write it inline on a single line."},{"text":" ","type":"text"},{"type":"text","text":"As an example, Swift’s "},{"code":"Array","type":"codeVoice"},{"type":"text","text":" type has a "},{"type":"codeVoice","code":"map(_:)"},{"text":" method,","type":"text"},{"type":"text","text":" "},{"text":"which takes a closure expression as its single argument.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"The closure is called once for each item in the array,"},{"type":"text","text":" "},{"type":"text","text":"and returns an alternative mapped value (possibly of some other type) for that item."},{"type":"text","text":" "},{"text":"You specify","type":"text"},{"type":"text","text":" "},{"text":"the nature of the mapping and the type of the returned value","type":"text"},{"type":"text","text":" "},{"type":"text","text":"by writing code in the closure that you pass to "},{"type":"codeVoice","code":"map(_:)"},{"text":".","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"After applying the provided closure to each array element,"},{"type":"text","text":" "},{"type":"text","text":"the "},{"code":"map(_:)","type":"codeVoice"},{"type":"text","text":" method returns a new array containing all of the new mapped values,"},{"text":" ","type":"text"},{"type":"text","text":"in the same order as their corresponding values in the original array."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Here’s how you can use the "},{"type":"codeVoice","code":"map(_:)"},{"type":"text","text":" method with a trailing closure"},{"type":"text","text":" "},{"text":"to convert an array of ","type":"text"},{"code":"Int","type":"codeVoice"},{"type":"text","text":" values into an array of "},{"type":"codeVoice","code":"String"},{"type":"text","text":" values."},{"text":" ","type":"text"},{"type":"text","text":"The array "},{"code":"[16, 58, 510]","type":"codeVoice"},{"type":"text","text":" is used to create the new array"},{"type":"text","text":" "},{"type":"codeVoice","code":"[\"OneSix\", \"FiveEight\", \"FiveOneZero\"]"},{"type":"text","text":":"}]},{"code":["let digitNames = [","    0: \"Zero\", 1: \"One\", 2: \"Two\",   3: \"Three\", 4: \"Four\",","    5: \"Five\", 6: \"Six\", 7: \"Seven\", 8: \"Eight\", 9: \"Nine\"","]","let numbers = [16, 58, 510]"],"syntax":"swift","type":"codeListing"},{"type":"paragraph","inlineContent":[{"type":"text","text":"The code above creates a dictionary of mappings between"},{"type":"text","text":" "},{"text":"the integer digits and English-language versions of their names.","type":"text"},{"type":"text","text":" "},{"text":"It also defines an array of integers, ready to be converted into strings.","type":"text"}]},{"inlineContent":[{"type":"text","text":"You can now use the "},{"code":"numbers","type":"codeVoice"},{"text":" array to create an array of ","type":"text"},{"code":"String","type":"codeVoice"},{"type":"text","text":" values,"},{"text":" ","type":"text"},{"type":"text","text":"by passing a closure expression to the array’s "},{"code":"map(_:)","type":"codeVoice"},{"type":"text","text":" method as a trailing closure:"}],"type":"paragraph"},{"code":["let strings = numbers.map { (number) -> String in","    var number = number","    var output = \"\"","    repeat {","        output = digitNames[number % 10]! + output","        number \/= 10","    } while number > 0","    return output","}","\/\/ strings is inferred to be of type [String]","\/\/ its value is [\"OneSix\", \"FiveEight\", \"FiveOneZero\"]"],"syntax":"swift","type":"codeListing"},{"inlineContent":[{"type":"text","text":"The "},{"type":"codeVoice","code":"map(_:)"},{"type":"text","text":" method calls the closure expression once for each item in the array."},{"type":"text","text":" "},{"type":"text","text":"You don’t need to specify the type of the closure’s input parameter, "},{"code":"number","type":"codeVoice"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"because the type can be inferred from the values in the array to be mapped."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"text":"In this example,","type":"text"},{"type":"text","text":" "},{"type":"text","text":"the variable "},{"code":"number","type":"codeVoice"},{"text":" is initialized with the value of the closure’s ","type":"text"},{"code":"number","type":"codeVoice"},{"type":"text","text":" parameter,"},{"text":" ","type":"text"},{"type":"text","text":"so that the value can be modified within the closure body."},{"type":"text","text":" "},{"type":"text","text":"(The parameters to functions and closures are always constants.)"},{"type":"text","text":" "},{"type":"text","text":"The closure expression also specifies a return type of "},{"type":"codeVoice","code":"String"},{"type":"text","text":","},{"text":" ","type":"text"},{"text":"to indicate the type that will be stored in the mapped output array.","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The closure expression builds a string called "},{"type":"codeVoice","code":"output"},{"text":" each time it’s called.","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"It calculates the last digit of "},{"code":"number","type":"codeVoice"},{"type":"text","text":" by using the remainder operator ("},{"code":"number % 10","type":"codeVoice"},{"type":"text","text":"),"},{"type":"text","text":" "},{"text":"and uses this digit to look up an appropriate string in the ","type":"text"},{"code":"digitNames","type":"codeVoice"},{"text":" dictionary.","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"The closure can be used to create a string representation of any integer greater than zero."}]},{"style":"note","name":"Note","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"The call to the "},{"code":"digitNames","type":"codeVoice"},{"type":"text","text":" dictionary’s subscript"},{"type":"text","text":" "},{"type":"text","text":"is followed by an exclamation point ("},{"code":"!","type":"codeVoice"},{"text":"),","type":"text"},{"text":" ","type":"text"},{"text":"because dictionary subscripts return an optional value","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"to indicate that the dictionary lookup can fail if the key doesn’t exist."},{"text":" ","type":"text"},{"text":"In the example above, it’s guaranteed that ","type":"text"},{"code":"number % 10","type":"codeVoice"},{"text":" ","type":"text"},{"text":"will always be a valid subscript key for the ","type":"text"},{"type":"codeVoice","code":"digitNames"},{"type":"text","text":" dictionary,"},{"type":"text","text":" "},{"text":"and so an exclamation point is used to force-unwrap the ","type":"text"},{"type":"codeVoice","code":"String"},{"type":"text","text":" value"},{"type":"text","text":" "},{"type":"text","text":"stored in the subscript’s optional return value."}]}],"type":"aside"},{"type":"paragraph","inlineContent":[{"type":"text","text":"The string retrieved from the "},{"code":"digitNames","type":"codeVoice"},{"type":"text","text":" dictionary"},{"text":" ","type":"text"},{"type":"text","text":"is added to the "},{"inlineContent":[{"text":"front","type":"text"}],"type":"emphasis"},{"text":" of ","type":"text"},{"code":"output","type":"codeVoice"},{"type":"text","text":","},{"text":" ","type":"text"},{"text":"effectively building a string version of the number in reverse.","type":"text"},{"type":"text","text":" "},{"text":"(The expression ","type":"text"},{"type":"codeVoice","code":"number % 10"},{"type":"text","text":" gives a value of"},{"text":" ","type":"text"},{"type":"codeVoice","code":"6"},{"type":"text","text":" for "},{"type":"codeVoice","code":"16"},{"type":"text","text":", "},{"code":"8","type":"codeVoice"},{"type":"text","text":" for "},{"code":"58","type":"codeVoice"},{"text":", and ","type":"text"},{"type":"codeVoice","code":"0"},{"type":"text","text":" for "},{"code":"510","type":"codeVoice"},{"type":"text","text":".)"}]},{"inlineContent":[{"type":"text","text":"The "},{"type":"codeVoice","code":"number"},{"type":"text","text":" variable is then divided by "},{"type":"codeVoice","code":"10"},{"text":".","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"Because it’s an integer, it’s rounded down during the division,"},{"text":" ","type":"text"},{"text":"so ","type":"text"},{"code":"16","type":"codeVoice"},{"type":"text","text":" becomes "},{"type":"codeVoice","code":"1"},{"type":"text","text":", "},{"code":"58","type":"codeVoice"},{"type":"text","text":" becomes "},{"code":"5","type":"codeVoice"},{"text":", and ","type":"text"},{"type":"codeVoice","code":"510"},{"type":"text","text":" becomes "},{"type":"codeVoice","code":"51"},{"text":".","type":"text"}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"The process is repeated until "},{"type":"codeVoice","code":"number"},{"text":" is equal to ","type":"text"},{"code":"0","type":"codeVoice"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"at which point the "},{"type":"codeVoice","code":"output"},{"type":"text","text":" string is returned by the closure,"},{"text":" ","type":"text"},{"text":"and is added to the output array by the ","type":"text"},{"code":"map(_:)","type":"codeVoice"},{"type":"text","text":" method."}]},{"type":"paragraph","inlineContent":[{"text":"The use of trailing closure syntax in the example above","type":"text"},{"type":"text","text":" "},{"text":"neatly encapsulates the closure’s functionality","type":"text"},{"type":"text","text":" "},{"type":"text","text":"immediately after the function that closure supports,"},{"type":"text","text":" "},{"type":"text","text":"without needing to wrap the entire closure within"},{"text":" ","type":"text"},{"type":"text","text":"the "},{"code":"map(_:)","type":"codeVoice"},{"type":"text","text":" method’s outer parentheses."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"If a function takes multiple closures,"},{"text":" ","type":"text"},{"type":"text","text":"you omit the argument label for the first trailing closure"},{"text":" ","type":"text"},{"text":"and you label the remaining trailing closures.","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"For example,"},{"type":"text","text":" "},{"text":"the function below loads a picture for a photo gallery:","type":"text"}]},{"code":["func loadPicture(from server: Server, completion: (Picture) -> Void, onFailure: () -> Void) {","    if let picture = download(\"photo.jpg\", from: server) {","        completion(picture)","    } else {","        onFailure()","    }","}"],"syntax":"swift","type":"codeListing"},{"type":"paragraph","inlineContent":[{"type":"text","text":"When you call this function to load a picture,"},{"text":" ","type":"text"},{"type":"text","text":"you provide two closures."},{"text":" ","type":"text"},{"text":"The first closure is a completion handler","type":"text"},{"text":" ","type":"text"},{"text":"that displays a picture after a successful download.","type":"text"},{"text":" ","type":"text"},{"text":"The second closure is an error handler","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"that displays an error to the user."}]},{"type":"codeListing","syntax":"swift","code":["loadPicture(from: someServer) { picture in","    someView.currentPicture = picture","} onFailure: {","    print(\"Couldn't download the next picture.\")","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"In this example,"},{"type":"text","text":" "},{"type":"text","text":"the "},{"type":"codeVoice","code":"loadPicture(from:completion:onFailure:)"},{"type":"text","text":" function"},{"type":"text","text":" "},{"type":"text","text":"dispatches its network task into the background,"},{"type":"text","text":" "},{"type":"text","text":"and calls one of the two completion handlers when the network task finishes."},{"type":"text","text":" "},{"text":"Writing the function this way lets you cleanly separate the code","type":"text"},{"type":"text","text":" "},{"text":"that’s responsible for handling a network failure","type":"text"},{"text":" ","type":"text"},{"text":"from the code that updates the user interface after a successful download,","type":"text"},{"type":"text","text":" "},{"type":"text","text":"instead of using just one closure that handles both circumstances."}]},{"style":"note","content":[{"type":"paragraph","inlineContent":[{"text":"Completion handlers can become hard to read,","type":"text"},{"type":"text","text":" "},{"type":"text","text":"especially when you have to nest multiple handlers."},{"text":" ","type":"text"},{"text":"An alternate approach is to use asynchronous code,","type":"text"},{"type":"text","text":" "},{"text":"as described in ","type":"text"},{"type":"reference","identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Concurrency","isActive":true},{"text":".","type":"text"}]}],"type":"aside","name":"Note"},{"level":2,"text":"Captura de valores","type":"heading","anchor":"Captura-de-valores"},{"type":"paragraph","inlineContent":[{"text":"A closure can ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"capture","type":"text"}]},{"text":" constants and variables","type":"text"},{"type":"text","text":" "},{"text":"from the surrounding context in which it’s defined.","type":"text"},{"text":" ","type":"text"},{"text":"The closure can then refer to and modify","type":"text"},{"text":" ","type":"text"},{"text":"the values of those constants and variables from within its body,","type":"text"},{"type":"text","text":" "},{"text":"even if the original scope that defined the constants and variables no longer exists.","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"In Swift, the simplest form of a closure that can capture values is a nested function,"},{"type":"text","text":" "},{"type":"text","text":"written within the body of another function."},{"type":"text","text":" "},{"type":"text","text":"A nested function can capture any of its outer function’s arguments"},{"type":"text","text":" "},{"type":"text","text":"and can also capture any constants and variables defined within the outer function."}]},{"inlineContent":[{"text":"Here’s an example of a function called ","type":"text"},{"code":"makeIncrementer","type":"codeVoice"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"which contains a nested function called "},{"type":"codeVoice","code":"incrementer"},{"type":"text","text":"."},{"type":"text","text":" "},{"text":"The nested ","type":"text"},{"code":"incrementer()","type":"codeVoice"},{"type":"text","text":" function captures two values,"},{"type":"text","text":" "},{"type":"codeVoice","code":"runningTotal"},{"type":"text","text":" and "},{"code":"amount","type":"codeVoice"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"from its surrounding context."},{"type":"text","text":" "},{"type":"text","text":"After capturing these values,"},{"type":"text","text":" "},{"code":"incrementer","type":"codeVoice"},{"type":"text","text":" is returned by "},{"type":"codeVoice","code":"makeIncrementer"},{"text":" as a closure","type":"text"},{"type":"text","text":" "},{"type":"text","text":"that increments "},{"type":"codeVoice","code":"runningTotal"},{"type":"text","text":" by "},{"type":"codeVoice","code":"amount"},{"type":"text","text":" each time it’s called."}],"type":"paragraph"},{"code":["func makeIncrementer(forIncrement amount: Int) -> () -> Int {","    var runningTotal = 0","    func incrementer() -> Int {","        runningTotal += amount","        return runningTotal","    }","    return incrementer","}"],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"text":"The return type of ","type":"text"},{"type":"codeVoice","code":"makeIncrementer"},{"text":" is ","type":"text"},{"type":"codeVoice","code":"() -> Int"},{"type":"text","text":"."},{"type":"text","text":" "},{"text":"This means that it returns a ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"function","type":"text"}]},{"type":"text","text":", rather than a simple value."},{"text":" ","type":"text"},{"type":"text","text":"The function it returns has no parameters,"},{"text":" ","type":"text"},{"text":"and returns an ","type":"text"},{"code":"Int","type":"codeVoice"},{"type":"text","text":" value each time it’s called."},{"text":" ","type":"text"},{"type":"text","text":"To learn how functions can return other functions,"},{"text":" ","type":"text"},{"text":"see ","type":"text"},{"type":"text","text":"doc:Functions#Tipos-de-funciones-como-tipos-de-devolución"},{"type":"text","text":"."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"The "},{"type":"codeVoice","code":"makeIncrementer(forIncrement:)"},{"text":" function defines an integer variable called ","type":"text"},{"code":"runningTotal","type":"codeVoice"},{"text":",","type":"text"},{"type":"text","text":" "},{"type":"text","text":"to store the current running total of the incrementer that will be returned."},{"type":"text","text":" "},{"type":"text","text":"This variable is initialized with a value of "},{"type":"codeVoice","code":"0"},{"type":"text","text":"."}],"type":"paragraph"},{"inlineContent":[{"text":"The ","type":"text"},{"code":"makeIncrementer(forIncrement:)","type":"codeVoice"},{"type":"text","text":" function has a single "},{"code":"Int","type":"codeVoice"},{"text":" parameter","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"with an argument label of "},{"code":"forIncrement","type":"codeVoice"},{"text":", and a parameter name of ","type":"text"},{"type":"codeVoice","code":"amount"},{"text":".","type":"text"},{"type":"text","text":" "},{"type":"text","text":"The argument value passed to this parameter specifies"},{"type":"text","text":" "},{"text":"how much ","type":"text"},{"type":"codeVoice","code":"runningTotal"},{"type":"text","text":" should be incremented by"},{"type":"text","text":" "},{"text":"each time the returned incrementer function is called.","type":"text"},{"text":" ","type":"text"},{"text":"The ","type":"text"},{"type":"codeVoice","code":"makeIncrementer"},{"text":" function defines a nested function called ","type":"text"},{"type":"codeVoice","code":"incrementer"},{"type":"text","text":","},{"type":"text","text":" "},{"text":"which performs the actual incrementing.","type":"text"},{"text":" ","type":"text"},{"text":"This function simply adds ","type":"text"},{"code":"amount","type":"codeVoice"},{"text":" to ","type":"text"},{"code":"runningTotal","type":"codeVoice"},{"type":"text","text":", and returns the result."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"When considered in isolation,"},{"text":" ","type":"text"},{"type":"text","text":"the nested "},{"type":"codeVoice","code":"incrementer()"},{"text":" function might seem unusual:","type":"text"}]},{"type":"codeListing","code":["func incrementer() -> Int {","    runningTotal += amount","    return runningTotal","}"],"syntax":"swift"},{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"type":"codeVoice","code":"incrementer()"},{"type":"text","text":" function doesn’t have any parameters,"},{"type":"text","text":" "},{"text":"and yet it refers to ","type":"text"},{"code":"runningTotal","type":"codeVoice"},{"text":" and ","type":"text"},{"code":"amount","type":"codeVoice"},{"type":"text","text":" from within its function body."},{"text":" ","type":"text"},{"text":"It does this by capturing a ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"reference","type":"text"}]},{"type":"text","text":" to "},{"type":"codeVoice","code":"runningTotal"},{"type":"text","text":" and "},{"code":"amount","type":"codeVoice"},{"text":" ","type":"text"},{"type":"text","text":"from the surrounding function and using them within its own function body."},{"type":"text","text":" "},{"type":"text","text":"Capturing by reference ensures that "},{"code":"runningTotal","type":"codeVoice"},{"type":"text","text":" and "},{"code":"amount","type":"codeVoice"},{"type":"text","text":" don’t disappear"},{"type":"text","text":" "},{"text":"when the call to ","type":"text"},{"type":"codeVoice","code":"makeIncrementer"},{"type":"text","text":" ends,"},{"type":"text","text":" "},{"type":"text","text":"and also ensures that "},{"type":"codeVoice","code":"runningTotal"},{"type":"text","text":" is available"},{"text":" ","type":"text"},{"type":"text","text":"the next time the "},{"code":"incrementer","type":"codeVoice"},{"type":"text","text":" function is called."}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"As an optimization,","type":"text"},{"type":"text","text":" "},{"type":"text","text":"Swift may instead capture and store a "},{"inlineContent":[{"text":"copy","type":"text"}],"type":"emphasis"},{"text":" of a value","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"if that value isn’t mutated by a closure,"},{"type":"text","text":" "},{"text":"and if the value isn’t mutated after the closure is created.","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Swift also handles all memory management involved in disposing of"},{"type":"text","text":" "},{"text":"variables when they’re no longer needed.","type":"text"}]}],"name":"Note","style":"note","type":"aside"},{"inlineContent":[{"type":"text","text":"Here’s an example of "},{"code":"makeIncrementer","type":"codeVoice"},{"text":" in action:","type":"text"}],"type":"paragraph"},{"code":["let incrementByTen = makeIncrementer(forIncrement: 10)"],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"type":"text","text":"This example sets a constant called "},{"code":"incrementByTen","type":"codeVoice"},{"type":"text","text":" "},{"text":"to refer to an incrementer function that adds ","type":"text"},{"type":"codeVoice","code":"10"},{"text":" to","type":"text"},{"type":"text","text":" "},{"type":"text","text":"its "},{"code":"runningTotal","type":"codeVoice"},{"text":" variable each time it’s called.","type":"text"},{"type":"text","text":" "},{"text":"Calling the function multiple times shows this behavior in action:","type":"text"}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["incrementByTen()","\/\/ returns a value of 10","incrementByTen()","\/\/ returns a value of 20","incrementByTen()","\/\/ returns a value of 30"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"If you create a second incrementer,"},{"type":"text","text":" "},{"type":"text","text":"it will have its own stored reference to a new, separate "},{"type":"codeVoice","code":"runningTotal"},{"text":" variable:","type":"text"}]},{"syntax":"swift","type":"codeListing","code":["let incrementBySeven = makeIncrementer(forIncrement: 7)","incrementBySeven()","\/\/ returns a value of 7"]},{"inlineContent":[{"type":"text","text":"Calling the original incrementer ("},{"type":"codeVoice","code":"incrementByTen"},{"type":"text","text":") again"},{"text":" ","type":"text"},{"text":"continues to increment its own ","type":"text"},{"type":"codeVoice","code":"runningTotal"},{"text":" variable,","type":"text"},{"text":" ","type":"text"},{"text":"and doesn’t affect the variable captured by ","type":"text"},{"type":"codeVoice","code":"incrementBySeven"},{"type":"text","text":":"}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["incrementByTen()","\/\/ returns a value of 40"]},{"type":"aside","style":"note","content":[{"inlineContent":[{"text":"If you assign a closure to a property of a class instance,","type":"text"},{"text":" ","type":"text"},{"text":"and the closure captures that instance by referring to the instance or its members,","type":"text"},{"type":"text","text":" "},{"type":"text","text":"you will create a strong reference cycle between the closure and the instance."},{"text":" ","type":"text"},{"type":"text","text":"Swift uses "},{"type":"emphasis","inlineContent":[{"type":"text","text":"capture lists"}]},{"text":" to break these strong reference cycles.","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"For more information, see "},{"isActive":true,"type":"reference","identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/AutomaticReferenceCounting#Ciclos-de-referencias-fuertes-para-clausuras"},{"type":"text","text":"."}],"type":"paragraph"}],"name":"Note"},{"level":2,"type":"heading","text":"Las clausuras son tipos de referencia","anchor":"Las-clausuras-son-tipos-de-referencia"},{"type":"paragraph","inlineContent":[{"type":"text","text":"In the example above,"},{"type":"text","text":" "},{"code":"incrementBySeven","type":"codeVoice"},{"type":"text","text":" and "},{"type":"codeVoice","code":"incrementByTen"},{"text":" are constants,","type":"text"},{"type":"text","text":" "},{"type":"text","text":"but the closures these constants refer to are still able to increment"},{"text":" ","type":"text"},{"text":"the ","type":"text"},{"type":"codeVoice","code":"runningTotal"},{"text":" variables that they have captured.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"This is because functions and closures are "},{"type":"emphasis","inlineContent":[{"text":"reference types","type":"text"}]},{"type":"text","text":"."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Whenever you assign a function or a closure to a constant or a variable,"},{"text":" ","type":"text"},{"text":"you are actually setting that constant or variable to be","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"a "},{"type":"emphasis","inlineContent":[{"type":"text","text":"reference"}]},{"text":" to the function or closure.","type":"text"},{"text":" ","type":"text"},{"text":"In the example above,","type":"text"},{"type":"text","text":" "},{"type":"text","text":"it’s the choice of closure that "},{"type":"codeVoice","code":"incrementByTen"},{"type":"text","text":" "},{"inlineContent":[{"type":"text","text":"refers to"}],"type":"emphasis"},{"text":" that’s constant,","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"and not the contents of the closure itself."}]},{"type":"paragraph","inlineContent":[{"text":"This also means that if you assign a closure to two different constants or variables,","type":"text"},{"type":"text","text":" "},{"type":"text","text":"both of those constants or variables refer to the same closure."}]},{"type":"codeListing","syntax":"swift","code":["let alsoIncrementByTen = incrementByTen","alsoIncrementByTen()","\/\/ returns a value of 50","","incrementByTen()","\/\/ returns a value of 60"]},{"type":"paragraph","inlineContent":[{"text":"The example above shows that calling ","type":"text"},{"code":"alsoIncrementByTen","type":"codeVoice"},{"text":" ","type":"text"},{"type":"text","text":"is the same as calling "},{"type":"codeVoice","code":"incrementByTen"},{"type":"text","text":"."},{"text":" ","type":"text"},{"type":"text","text":"Because both of them refer to the same closure,"},{"type":"text","text":" "},{"type":"text","text":"they both increment and return the same running total."}]},{"text":"Clausuras que escapan","level":2,"type":"heading","anchor":"Clausuras-que-escapan"},{"inlineContent":[{"text":"A closure is said to ","type":"text"},{"inlineContent":[{"text":"escape","type":"text"}],"type":"emphasis"},{"type":"text","text":" a function"},{"text":" ","type":"text"},{"text":"when the closure is passed as an argument to the function,","type":"text"},{"text":" ","type":"text"},{"text":"but is called after the function returns.","type":"text"},{"text":" ","type":"text"},{"text":"When you declare a function that takes a closure as one of its parameters,","type":"text"},{"type":"text","text":" "},{"type":"text","text":"you can write "},{"type":"codeVoice","code":"@escaping"},{"type":"text","text":" before the parameter’s type"},{"type":"text","text":" "},{"type":"text","text":"to indicate that the closure is allowed to escape."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"One way that a closure can escape"},{"type":"text","text":" "},{"text":"is by being stored in a variable that’s defined outside the function.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"As an example,"},{"type":"text","text":" "},{"type":"text","text":"many functions that start an asynchronous operation"},{"type":"text","text":" "},{"type":"text","text":"take a closure argument as a completion handler."},{"text":" ","type":"text"},{"text":"The function returns after it starts the operation,","type":"text"},{"type":"text","text":" "},{"type":"text","text":"but the closure isn’t called until the operation is completed —"},{"type":"text","text":" "},{"type":"text","text":"the closure needs to escape, to be called later."},{"text":" ","type":"text"},{"type":"text","text":"For example:"}]},{"type":"codeListing","code":["var completionHandlers: [() -> Void] = []","func someFunctionWithEscapingClosure(completionHandler: @escaping () -> Void) {","    completionHandlers.append(completionHandler)","}"],"syntax":"swift"},{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"type":"codeVoice","code":"someFunctionWithEscapingClosure(_:)"},{"text":" function takes a closure as its argument","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"and adds it to an array that’s declared outside the function."},{"text":" ","type":"text"},{"type":"text","text":"If you didn’t mark the parameter of this function with "},{"code":"@escaping","type":"codeVoice"},{"text":",","type":"text"},{"type":"text","text":" "},{"type":"text","text":"you would get a compile-time error."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"An escaping closure that refers to "},{"code":"self","type":"codeVoice"},{"type":"text","text":" "},{"type":"text","text":"needs special consideration if "},{"code":"self","type":"codeVoice"},{"text":" refers to an instance of a class.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"Capturing "},{"type":"codeVoice","code":"self"},{"text":" in an escaping closure","type":"text"},{"type":"text","text":" "},{"text":"makes it easy to accidentally create a strong reference cycle.","type":"text"},{"type":"text","text":" "},{"text":"For information about reference cycles,","type":"text"},{"type":"text","text":" "},{"text":"see ","type":"text"},{"isActive":true,"type":"reference","identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/AutomaticReferenceCounting"},{"text":".","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"Normally, a closure captures variables implicitly","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"by using them in the body of the closure,"},{"type":"text","text":" "},{"type":"text","text":"but in this case you need to be explicit."},{"type":"text","text":" "},{"text":"If you want to capture ","type":"text"},{"code":"self","type":"codeVoice"},{"type":"text","text":","},{"type":"text","text":" "},{"text":"write ","type":"text"},{"type":"codeVoice","code":"self"},{"type":"text","text":" explicitly when you use it,"},{"text":" ","type":"text"},{"text":"or include ","type":"text"},{"code":"self","type":"codeVoice"},{"type":"text","text":" in the closure’s capture list."},{"text":" ","type":"text"},{"text":"Writing ","type":"text"},{"type":"codeVoice","code":"self"},{"text":" explicitly lets you express your intent,","type":"text"},{"type":"text","text":" "},{"text":"and reminds you to confirm that there isn’t a reference cycle.","type":"text"},{"text":" ","type":"text"},{"text":"For example, in the code below,","type":"text"},{"type":"text","text":" "},{"type":"text","text":"the closure passed to "},{"code":"someFunctionWithEscapingClosure(_:)","type":"codeVoice"},{"text":" ","type":"text"},{"text":"refers to ","type":"text"},{"code":"self","type":"codeVoice"},{"type":"text","text":" explicitly."},{"type":"text","text":" "},{"text":"In contrast, the closure passed to ","type":"text"},{"type":"codeVoice","code":"someFunctionWithNonescapingClosure(_:)"},{"type":"text","text":" "},{"text":"is a nonescaping closure, which means it can refer to ","type":"text"},{"type":"codeVoice","code":"self"},{"type":"text","text":" implicitly."}]},{"code":["func someFunctionWithNonescapingClosure(closure: () -> Void) {","    closure()","}","","class SomeClass {","    var x = 10","    func doSomething() {","        someFunctionWithEscapingClosure { self.x = 100 }","        someFunctionWithNonescapingClosure { x = 200 }","    }","}","","let instance = SomeClass()","instance.doSomething()","print(instance.x)","\/\/ Prints \"200\"","","completionHandlers.first?()","print(instance.x)","\/\/ Prints \"100\""],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"text":"Here’s a version of ","type":"text"},{"code":"doSomething()","type":"codeVoice"},{"text":" that captures ","type":"text"},{"type":"codeVoice","code":"self"},{"type":"text","text":" "},{"type":"text","text":"by including it in the closure’s capture list,"},{"text":" ","type":"text"},{"type":"text","text":"and then refers to "},{"type":"codeVoice","code":"self"},{"type":"text","text":" implicitly:"}],"type":"paragraph"},{"type":"codeListing","syntax":"swift","code":["class SomeOtherClass {","    var x = 10","    func doSomething() {","        someFunctionWithEscapingClosure { [self] in x = 100 }","        someFunctionWithNonescapingClosure { x = 200 }","    }","}"]},{"inlineContent":[{"text":"If ","type":"text"},{"code":"self","type":"codeVoice"},{"type":"text","text":" is an instance of a structure or an enumeration,"},{"type":"text","text":" "},{"type":"text","text":"you can always refer to "},{"type":"codeVoice","code":"self"},{"text":" implicitly.","type":"text"},{"type":"text","text":" "},{"text":"However,","type":"text"},{"type":"text","text":" "},{"text":"an escaping closure can’t capture a mutable reference to ","type":"text"},{"type":"codeVoice","code":"self"},{"type":"text","text":" "},{"type":"text","text":"when "},{"type":"codeVoice","code":"self"},{"text":" is an instance of a structure or an enumeration.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"Structures and enumerations don’t allow shared mutability,"},{"text":" ","type":"text"},{"text":"as discussed in ","type":"text"},{"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/ClassesAndStructures#Las-estructuras-y-las-enumeraciones-son-tipos-de-valor","type":"reference","isActive":true},{"text":".","type":"text"}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["struct SomeStruct {","    var x = 10","    mutating func doSomething() {","        someFunctionWithNonescapingClosure { x = 200 }  \/\/ Ok","        someFunctionWithEscapingClosure { x = 100 }     \/\/ Error","    }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The call to the "},{"type":"codeVoice","code":"someFunctionWithEscapingClosure"},{"text":" function","type":"text"},{"type":"text","text":" "},{"type":"text","text":"in the example above is an error"},{"text":" ","type":"text"},{"text":"because it’s inside a mutating method,","type":"text"},{"type":"text","text":" "},{"type":"text","text":"so "},{"code":"self","type":"codeVoice"},{"type":"text","text":" is mutable."},{"type":"text","text":" "},{"text":"That violates the rule that escaping closures can’t capture","type":"text"},{"type":"text","text":" "},{"type":"text","text":"a mutable reference to "},{"type":"codeVoice","code":"self"},{"type":"text","text":" for structures."}]},{"type":"heading","level":2,"text":"Autoclausuras","anchor":"Autoclausuras"},{"type":"paragraph","inlineContent":[{"text":"An ","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"autoclosure"}]},{"type":"text","text":" is a closure that’s automatically created"},{"text":" ","type":"text"},{"text":"to wrap an expression that’s being passed as an argument to a function.","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"It doesn’t take any arguments,"},{"type":"text","text":" "},{"type":"text","text":"and when it’s called, it returns the value"},{"type":"text","text":" "},{"text":"of the expression that’s wrapped inside of it.","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"This syntactic convenience lets you omit braces around a function’s parameter"},{"text":" ","type":"text"},{"type":"text","text":"by writing a normal expression instead of an explicit closure."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"It’s common to "},{"inlineContent":[{"type":"text","text":"call"}],"type":"emphasis"},{"type":"text","text":" functions that take autoclosures,"},{"type":"text","text":" "},{"type":"text","text":"but it’s not common to "},{"inlineContent":[{"type":"text","text":"implement"}],"type":"emphasis"},{"text":" that kind of function.","type":"text"},{"type":"text","text":" "},{"text":"For example,","type":"text"},{"type":"text","text":" "},{"type":"text","text":"the "},{"type":"codeVoice","code":"assert(condition:message:file:line:)"},{"type":"text","text":" function"},{"text":" ","type":"text"},{"type":"text","text":"takes an autoclosure for its "},{"type":"codeVoice","code":"condition"},{"type":"text","text":" and "},{"type":"codeVoice","code":"message"},{"text":" parameters;","type":"text"},{"text":" ","type":"text"},{"text":"its ","type":"text"},{"type":"codeVoice","code":"condition"},{"text":" parameter is evaluated only in debug builds","type":"text"},{"text":" ","type":"text"},{"text":"and its ","type":"text"},{"type":"codeVoice","code":"message"},{"type":"text","text":" parameter is evaluated only if "},{"type":"codeVoice","code":"condition"},{"type":"text","text":" is "},{"type":"codeVoice","code":"false"},{"type":"text","text":"."}]},{"type":"paragraph","inlineContent":[{"text":"An autoclosure lets you delay evaluation,","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"because the code inside isn’t run until you call the closure."},{"text":" ","type":"text"},{"type":"text","text":"Delaying evaluation is useful for code"},{"type":"text","text":" "},{"type":"text","text":"that has side effects or is computationally expensive,"},{"text":" ","type":"text"},{"text":"because it lets you control when that code is evaluated.","type":"text"},{"text":" ","type":"text"},{"text":"The code below shows how a closure delays evaluation.","type":"text"}]},{"type":"codeListing","syntax":"swift","code":["var customersInLine = [\"Chris\", \"Alex\", \"Ewa\", \"Barry\", \"Daniella\"]","print(customersInLine.count)","\/\/ Prints \"5\"","","let customerProvider = { customersInLine.remove(at: 0) }","print(customersInLine.count)","\/\/ Prints \"5\"","","print(\"Now serving \\(customerProvider())!\")","\/\/ Prints \"Now serving Chris!\"","print(customersInLine.count)","\/\/ Prints \"4\""]},{"inlineContent":[{"type":"text","text":"Even though the first element of the "},{"type":"codeVoice","code":"customersInLine"},{"text":" array is removed","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"by the code inside the closure,"},{"type":"text","text":" "},{"text":"the array element isn’t removed until the closure is actually called.","type":"text"},{"type":"text","text":" "},{"text":"If the closure is never called,","type":"text"},{"type":"text","text":" "},{"type":"text","text":"the expression inside the closure is never evaluated,"},{"type":"text","text":" "},{"text":"which means the array element is never removed.","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"Note that the type of "},{"code":"customerProvider","type":"codeVoice"},{"text":" isn’t ","type":"text"},{"type":"codeVoice","code":"String"},{"text":" ","type":"text"},{"text":"but ","type":"text"},{"type":"codeVoice","code":"() -> String"},{"type":"text","text":" —"},{"type":"text","text":" "},{"text":"a function with no parameters that returns a string.","type":"text"}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"text":"You get the same behavior of delayed evaluation","type":"text"},{"type":"text","text":" "},{"text":"when you pass a closure as an argument to a function.","type":"text"}]},{"code":["\/\/ customersInLine is [\"Alex\", \"Ewa\", \"Barry\", \"Daniella\"]","func serve(customer customerProvider: () -> String) {","    print(\"Now serving \\(customerProvider())!\")","}","serve(customer: { customersInLine.remove(at: 0) } )","\/\/ Prints \"Now serving Alex!\""],"type":"codeListing","syntax":"swift"},{"type":"paragraph","inlineContent":[{"text":"The ","type":"text"},{"type":"codeVoice","code":"serve(customer:)"},{"type":"text","text":" function in the listing above"},{"text":" ","type":"text"},{"text":"takes an explicit closure that returns a customer’s name.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"The version of "},{"type":"codeVoice","code":"serve(customer:)"},{"text":" below","type":"text"},{"type":"text","text":" "},{"type":"text","text":"performs the same operation but, instead of taking an explicit closure,"},{"type":"text","text":" "},{"text":"it takes an autoclosure","type":"text"},{"type":"text","text":" "},{"text":"by marking its parameter’s type with the ","type":"text"},{"type":"codeVoice","code":"@autoclosure"},{"text":" attribute.","type":"text"},{"type":"text","text":" "},{"text":"Now you can call the function","type":"text"},{"type":"text","text":" "},{"text":"as if it took a ","type":"text"},{"type":"codeVoice","code":"String"},{"type":"text","text":" argument instead of a closure."},{"text":" ","type":"text"},{"type":"text","text":"The argument is automatically converted to a closure,"},{"text":" ","type":"text"},{"type":"text","text":"because the "},{"type":"codeVoice","code":"customerProvider"},{"type":"text","text":" parameter’s type is marked"},{"type":"text","text":" "},{"type":"text","text":"with the "},{"type":"codeVoice","code":"@autoclosure"},{"text":" attribute.","type":"text"}]},{"syntax":"swift","type":"codeListing","code":["\/\/ customersInLine is [\"Ewa\", \"Barry\", \"Daniella\"]","func serve(customer customerProvider: @autoclosure () -> String) {","    print(\"Now serving \\(customerProvider())!\")","}","serve(customer: customersInLine.remove(at: 0))","\/\/ Prints \"Now serving Ewa!\""]},{"style":"note","name":"Note","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Overusing autoclosures can make your code hard to understand."},{"type":"text","text":" "},{"type":"text","text":"The context and function name should make it clear"},{"text":" ","type":"text"},{"type":"text","text":"that evaluation is being deferred."}]}],"type":"aside"},{"type":"paragraph","inlineContent":[{"type":"text","text":"If you want an autoclosure that’s allowed to escape,"},{"type":"text","text":" "},{"text":"use both the ","type":"text"},{"type":"codeVoice","code":"@autoclosure"},{"text":" and ","type":"text"},{"code":"@escaping","type":"codeVoice"},{"type":"text","text":" attributes."},{"text":" ","type":"text"},{"type":"text","text":"The "},{"type":"codeVoice","code":"@escaping"},{"text":" attribute is described above in ","type":"text"},{"isActive":true,"type":"reference","identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Closures#Clausuras-que-escapan"},{"text":".","type":"text"}]},{"code":["\/\/ customersInLine is [\"Barry\", \"Daniella\"]","var customerProviders: [() -> String] = []","func collectCustomerProviders(_ customerProvider: @autoclosure @escaping () -> String) {","    customerProviders.append(customerProvider)","}","collectCustomerProviders(customersInLine.remove(at: 0))","collectCustomerProviders(customersInLine.remove(at: 0))","","print(\"Collected \\(customerProviders.count) closures.\")","\/\/ Prints \"Collected 2 closures.\"","for customerProvider in customerProviders {","    print(\"Now serving \\(customerProvider())!\")","}","\/\/ Prints \"Now serving Barry!\"","\/\/ Prints \"Now serving Daniella!\""],"syntax":"swift","type":"codeListing"},{"inlineContent":[{"type":"text","text":"In the code above,"},{"text":" ","type":"text"},{"text":"instead of calling the closure passed to it","type":"text"},{"text":" ","type":"text"},{"text":"as its ","type":"text"},{"type":"codeVoice","code":"customerProvider"},{"type":"text","text":" argument,"},{"type":"text","text":" "},{"text":"the ","type":"text"},{"code":"collectCustomerProviders(_:)","type":"codeVoice"},{"type":"text","text":" function"},{"type":"text","text":" "},{"type":"text","text":"appends the closure to the "},{"type":"codeVoice","code":"customerProviders"},{"text":" array.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"The array is declared outside the scope of the function,"},{"text":" ","type":"text"},{"text":"which means the closures in the array can be executed after the function returns.","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"As a result,"},{"type":"text","text":" "},{"type":"text","text":"the value of the "},{"type":"codeVoice","code":"customerProvider"},{"text":" argument","type":"text"},{"type":"text","text":" "},{"type":"text","text":"must be allowed to escape the function’s scope."}],"type":"paragraph"},{"style":"note","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":""}]},{"inlineContent":[{"type":"text","text":"Esta documentación contiene información preliminar sobre una API o tecnología en desarrollo. Esta información está sujeta a cambios, y todo software implementado en conformidad con esta documentación debe ser testeado con el software final del sistema operativo."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Conoce más acerca del uso del "},{"identifier":"https:\/\/developer.apple.com\/es\/support\/beta-software\/","type":"reference","isActive":true},{"type":"text","text":"."}]}],"name":"Software Beta","type":"aside"}],"kind":"content"}],"hierarchy":{"paths":[["doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language"]]},"abstract":[{"type":"text","text":"Group code that executes together, without creating a named function."}],"sections":[],"metadata":{"title":"Clausuras"},"schemaVersion":{"major":0,"minor":3,"patch":0},"references":{"https://developer.apple.com/es/support/beta-software/":{"identifier":"https:\/\/developer.apple.com\/es\/support\/beta-software\/","titleInlineContent":[{"type":"text","text":"software beta de Apple"}],"title":"software beta de Apple","type":"link","url":"https:\/\/developer.apple.com\/es\/support\/beta-software\/"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Concurrency":{"title":"Concurrencia","identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Concurrency","abstract":[{"type":"text","text":"Perform asynchronous operations."}],"type":"topic","url":"\/documentation\/the-swift-programming-language\/concurrency","kind":"article","role":"article"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Closures#Captura-de-valores":{"title":"Captura de valores","type":"topic","abstract":[],"kind":"section","identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Closures#Captura-de-valores","url":"\/documentation\/the-swift-programming-language\/closures#Captura-de-valores"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/AdvancedOperators#M%C3%A9todos-operadores":{"abstract":[],"kind":"section","identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/AdvancedOperators#M%C3%A9todos-operadores","title":"Métodos operadores","type":"topic","url":"\/documentation\/the-swift-programming-language\/advancedoperators#M%C3%A9todos-operadores"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/ClassesAndStructures#Las-estructuras-y-las-enumeraciones-son-tipos-de-valor":{"title":"Las estructuras y las enumeraciones son tipos de valor","type":"topic","abstract":[],"kind":"section","identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/ClassesAndStructures#Las-estructuras-y-las-enumeraciones-son-tipos-de-valor","url":"\/documentation\/the-swift-programming-language\/classesandstructures#Las-estructuras-y-las-enumeraciones-son-tipos-de-valor"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/AutomaticReferenceCounting#Ciclos-de-referencias-fuertes-para-clausuras":{"abstract":[],"kind":"section","identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/AutomaticReferenceCounting#Ciclos-de-referencias-fuertes-para-clausuras","title":"Ciclos de referencias fuertes para clausuras","type":"topic","url":"\/documentation\/the-swift-programming-language\/automaticreferencecounting#Ciclos-de-referencias-fuertes-para-clausuras"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/AutomaticReferenceCounting":{"title":"Conteo automático de referencias","identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/AutomaticReferenceCounting","abstract":[{"type":"text","text":"Model the lifetime of objects and their relationships."}],"type":"topic","url":"\/documentation\/the-swift-programming-language\/automaticreferencecounting","kind":"article","role":"article"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Closures#Sintaxis-de-expresiones-clausura":{"title":"Sintaxis de expresiones clausura","type":"topic","abstract":[],"kind":"section","identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Closures#Sintaxis-de-expresiones-clausura","url":"\/documentation\/the-swift-programming-language\/closures#Sintaxis-de-expresiones-clausura"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Functions":{"role":"article","title":"Funciones","kind":"article","identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Functions","type":"topic","abstract":[{"type":"text","text":"Define and call functions, label their arguments, and use their return values."}],"url":"\/documentation\/the-swift-programming-language\/functions"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Closures#Clausuras-que-escapan":{"abstract":[],"kind":"section","identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Closures#Clausuras-que-escapan","title":"Clausuras que escapan","type":"topic","url":"\/documentation\/the-swift-programming-language\/closures#Clausuras-que-escapan"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language":{"role":"collection","type":"topic","url":"\/documentation\/the-swift-programming-language","abstract":[],"title":"The Swift Programming Language (6)","identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language","kind":"article"}}}
>>>>>>> 2fa5d86d (yet one more fix attempt)
