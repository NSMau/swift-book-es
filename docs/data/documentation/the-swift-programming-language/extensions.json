<<<<<<< HEAD
{"hierarchy":{"paths":[["doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language"]]},"identifier":{"interfaceLanguage":"swift","url":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Extensions"},"schemaVersion":{"patch":0,"minor":3,"major":0},"metadata":{"title":"Extensiones"},"sections":[],"abstract":[{"text":"Add functionality to an existing type.","type":"text"}],"primaryContentSections":[{"kind":"content","content":[{"inlineContent":[{"inlineContent":[{"type":"text","text":"Extensions"}],"type":"emphasis"},{"type":"text","text":" add new functionality to an existing"},{"text":" ","type":"text"},{"text":"class, structure, enumeration, or protocol type.","type":"text"},{"type":"text","text":" "},{"text":"This includes the ability to extend types","type":"text"},{"text":" ","type":"text"},{"text":"for which you don’t have access to the original source code","type":"text"},{"text":" ","type":"text"},{"text":"(known as ","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"retroactive modeling"}]},{"text":").","type":"text"},{"type":"text","text":" "},{"type":"text","text":"Extensions are similar to categories in Objective-C."},{"type":"text","text":" "},{"text":"(Unlike Objective-C categories, Swift extensions don’t have names.)","type":"text"}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Extensions in Swift can:"}]},{"items":[{"content":[{"inlineContent":[{"text":"Add computed instance properties and computed type properties","type":"text"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Define instance methods and type methods"}]}]},{"content":[{"inlineContent":[{"text":"Provide new initializers","type":"text"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Define subscripts"}]}]},{"content":[{"inlineContent":[{"text":"Define and use new nested types","type":"text"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"text":"Make an existing type conform to a protocol","type":"text"}],"type":"paragraph"}]}],"type":"unorderedList"},{"type":"paragraph","inlineContent":[{"text":"In Swift,","type":"text"},{"text":" ","type":"text"},{"text":"you can even extend a protocol to provide implementations of its requirements","type":"text"},{"type":"text","text":" "},{"text":"or add additional functionality that conforming types can take advantage of.","type":"text"},{"type":"text","text":" "},{"text":"For more details, see ","type":"text"},{"text":"doc:Protocols#Extensión-de-protocolos","type":"text"},{"text":".","type":"text"}]},{"name":"Note","type":"aside","style":"note","content":[{"type":"paragraph","inlineContent":[{"text":"Extensions can add new functionality to a type,","type":"text"},{"type":"text","text":" "},{"type":"text","text":"but they can’t override existing functionality."}]}]},{"type":"heading","level":2,"anchor":"Sintaxis-de-una-extensi%C3%B3n","text":"Sintaxis de una extensión"},{"inlineContent":[{"type":"text","text":"Declare extensions with the "},{"type":"codeVoice","code":"extension"},{"type":"text","text":" keyword:"}],"type":"paragraph"},{"syntax":"swift","code":["extension SomeType {","    \/\/ new functionality to add to SomeType goes here","}"],"type":"codeListing"},{"inlineContent":[{"text":"An extension can extend an existing type to make it adopt one or more protocols.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"To add protocol conformance,"},{"text":" ","type":"text"},{"type":"text","text":"you write the protocol names"},{"type":"text","text":" "},{"text":"the same way as you write them for a class or structure:","type":"text"}],"type":"paragraph"},{"type":"codeListing","syntax":"swift","code":["extension SomeType: SomeProtocol, AnotherProtocol {","    \/\/ implementation of protocol requirements goes here","}"]},{"inlineContent":[{"type":"text","text":"Adding protocol conformance in this way is described in"},{"type":"text","text":" "},{"text":"doc:Protocols#Agregar-conformidad-protocolaria-mediante-una-extensión","type":"text"},{"type":"text","text":"."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"An extension can be used to extend an existing generic type,"},{"text":" ","type":"text"},{"text":"as described in ","type":"text"},{"type":"text","text":"doc:Generics#Extendiendo-un-tipo-genérico"},{"type":"text","text":"."},{"text":" ","type":"text"},{"type":"text","text":"You can also extend a generic type to conditionally add functionality,"},{"text":" ","type":"text"},{"type":"text","text":"as described in "},{"type":"text","text":"doc:Generics#Extensiones-con-una-cláusula-where-genérica"},{"text":".","type":"text"}]},{"style":"note","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"If you define an extension to add new functionality to an existing type,"},{"text":" ","type":"text"},{"type":"text","text":"the new functionality will be available on all existing instances of that type,"},{"type":"text","text":" "},{"type":"text","text":"even if they were created before the extension was defined."}]}],"type":"aside","name":"Note"},{"anchor":"Propiedades-computadas","level":2,"type":"heading","text":"Propiedades computadas"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Extensions can add computed instance properties and computed type properties to existing types."},{"type":"text","text":" "},{"type":"text","text":"This example adds five computed instance properties to Swift’s built-in "},{"type":"codeVoice","code":"Double"},{"type":"text","text":" type,"},{"text":" ","type":"text"},{"type":"text","text":"to provide basic support for working with distance units:"}]},{"type":"codeListing","syntax":"swift","code":["extension Double {","    var km: Double { return self * 1_000.0 }","    var m: Double { return self }","    var cm: Double { return self \/ 100.0 }","    var mm: Double { return self \/ 1_000.0 }","    var ft: Double { return self \/ 3.28084 }","}","let oneInch = 25.4.mm","print(\"One inch is \\(oneInch) meters\")","\/\/ Prints \"One inch is 0.0254 meters\"","let threeFeet = 3.ft","print(\"Three feet is \\(threeFeet) meters\")","\/\/ Prints \"Three feet is 0.914399970739201 meters\""]},{"type":"paragraph","inlineContent":[{"type":"text","text":"These computed properties express that a "},{"type":"codeVoice","code":"Double"},{"type":"text","text":" value"},{"type":"text","text":" "},{"text":"should be considered as a certain unit of length.","type":"text"},{"type":"text","text":" "},{"text":"Although they’re implemented as computed properties,","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"the names of these properties can be appended to"},{"text":" ","type":"text"},{"type":"text","text":"a floating-point literal value with dot syntax,"},{"type":"text","text":" "},{"text":"as a way to use that literal value to perform distance conversions.","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"In this example, a "},{"type":"codeVoice","code":"Double"},{"text":" value of ","type":"text"},{"code":"1.0","type":"codeVoice"},{"text":" is considered to represent “one meter”.","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"This is why the "},{"type":"codeVoice","code":"m"},{"type":"text","text":" computed property returns "},{"type":"codeVoice","code":"self"},{"type":"text","text":" —"},{"type":"text","text":" "},{"type":"text","text":"the expression "},{"code":"1.m","type":"codeVoice"},{"type":"text","text":" is considered to calculate a "},{"type":"codeVoice","code":"Double"},{"text":" value of ","type":"text"},{"code":"1.0","type":"codeVoice"},{"text":".","type":"text"}]},{"inlineContent":[{"type":"text","text":"Other units require some conversion to be expressed as a value measured in meters."},{"type":"text","text":" "},{"type":"text","text":"One kilometer is the same as 1,000 meters,"},{"type":"text","text":" "},{"text":"so the ","type":"text"},{"code":"km","type":"codeVoice"},{"type":"text","text":" computed property multiplies the value by "},{"type":"codeVoice","code":"1_000.00"},{"type":"text","text":" "},{"text":"to convert into a number expressed in meters.","type":"text"},{"type":"text","text":" "},{"text":"Similarly, there are 3.28084 feet in a meter,","type":"text"},{"type":"text","text":" "},{"text":"and so the ","type":"text"},{"type":"codeVoice","code":"ft"},{"text":" computed property divides the underlying ","type":"text"},{"type":"codeVoice","code":"Double"},{"type":"text","text":" value"},{"text":" ","type":"text"},{"type":"text","text":"by "},{"code":"3.28084","type":"codeVoice"},{"type":"text","text":", to convert it from feet to meters."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"text":"These properties are read-only computed properties,","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"and so they’re expressed without the "},{"type":"codeVoice","code":"get"},{"type":"text","text":" keyword, for brevity."},{"type":"text","text":" "},{"type":"text","text":"Their return value is of type "},{"code":"Double","type":"codeVoice"},{"text":",","type":"text"},{"type":"text","text":" "},{"text":"and can be used within mathematical calculations wherever a ","type":"text"},{"type":"codeVoice","code":"Double"},{"type":"text","text":" is accepted:"}]},{"syntax":"swift","type":"codeListing","code":["let aMarathon = 42.km + 195.m","print(\"A marathon is \\(aMarathon) meters long\")","\/\/ Prints \"A marathon is 42195.0 meters long\""]},{"type":"aside","name":"Note","content":[{"inlineContent":[{"type":"text","text":"Extensions can add new computed properties, but they can’t add stored properties,"},{"type":"text","text":" "},{"type":"text","text":"or add property observers to existing properties."}],"type":"paragraph"}],"style":"note"},{"level":2,"type":"heading","anchor":"Inicializadores","text":"Inicializadores"},{"inlineContent":[{"text":"Extensions can add new initializers to existing types.","type":"text"},{"type":"text","text":" "},{"text":"This enables you to extend other types to accept","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"your own custom types as initializer parameters,"},{"text":" ","type":"text"},{"type":"text","text":"or to provide additional initialization options"},{"type":"text","text":" "},{"type":"text","text":"that were not included as part of the type’s original implementation."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Extensions can add new convenience initializers to a class,"},{"type":"text","text":" "},{"type":"text","text":"but they can’t add new designated initializers or deinitializers to a class."},{"text":" ","type":"text"},{"text":"Designated initializers and deinitializers","type":"text"},{"text":" ","type":"text"},{"text":"must always be provided by the original class implementation.","type":"text"}]},{"inlineContent":[{"text":"If you use an extension to add an initializer to a value type that provides","type":"text"},{"text":" ","type":"text"},{"text":"default values for all of its stored properties","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"and doesn’t define any custom initializers,"},{"text":" ","type":"text"},{"text":"you can call the default initializer and memberwise initializer for that value type","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"from within your extension’s initializer."},{"text":" ","type":"text"},{"type":"text","text":"This wouldn’t be the case if you had written the initializer"},{"text":" ","type":"text"},{"text":"as part of the value type’s original implementation,","type":"text"},{"text":" ","type":"text"},{"text":"as described in ","type":"text"},{"type":"reference","identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Initialization#Delegaci%C3%B3n-de-inicializadores-para-tipos-de-valor","isActive":true},{"type":"text","text":"."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"text":"If you use an extension to add an initializer to a structure","type":"text"},{"type":"text","text":" "},{"type":"text","text":"that was declared in another module,"},{"type":"text","text":" "},{"type":"text","text":"the new initializer can’t access "},{"code":"self","type":"codeVoice"},{"text":" until it calls","type":"text"},{"type":"text","text":" "},{"text":"an initializer from the defining module.","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"The example below defines a custom ","type":"text"},{"code":"Rect","type":"codeVoice"},{"type":"text","text":" structure to represent a geometric rectangle."},{"type":"text","text":" "},{"type":"text","text":"The example also defines two supporting structures called "},{"code":"Size","type":"codeVoice"},{"type":"text","text":" and "},{"code":"Point","type":"codeVoice"},{"type":"text","text":","},{"text":" ","type":"text"},{"text":"both of which provide default values of ","type":"text"},{"type":"codeVoice","code":"0.0"},{"text":" for all of their properties:","type":"text"}]},{"type":"codeListing","syntax":"swift","code":["struct Size {","    var width = 0.0, height = 0.0","}","struct Point {","    var x = 0.0, y = 0.0","}","struct Rect {","    var origin = Point()","    var size = Size()","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Because the "},{"code":"Rect","type":"codeVoice"},{"type":"text","text":" structure provides default values for all of its properties,"},{"type":"text","text":" "},{"text":"it receives a default initializer and a memberwise initializer automatically,","type":"text"},{"type":"text","text":" "},{"text":"as described in ","type":"text"},{"isActive":true,"type":"reference","identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Initialization#Inicializadores-predeterminados"},{"text":".","type":"text"},{"type":"text","text":" "},{"type":"text","text":"These initializers can be used to create new "},{"type":"codeVoice","code":"Rect"},{"type":"text","text":" instances:"}]},{"type":"codeListing","code":["let defaultRect = Rect()","let memberwiseRect = Rect(origin: Point(x: 2.0, y: 2.0),","    size: Size(width: 5.0, height: 5.0))"],"syntax":"swift"},{"inlineContent":[{"type":"text","text":"You can extend the "},{"code":"Rect","type":"codeVoice"},{"type":"text","text":" structure to provide an additional initializer"},{"text":" ","type":"text"},{"type":"text","text":"that takes a specific center point and size:"}],"type":"paragraph"},{"type":"codeListing","syntax":"swift","code":["extension Rect {","    init(center: Point, size: Size) {","        let originX = center.x - (size.width \/ 2)","        let originY = center.y - (size.height \/ 2)","        self.init(origin: Point(x: originX, y: originY), size: size)","    }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"This new initializer starts by calculating an appropriate origin point based on"},{"text":" ","type":"text"},{"text":"the provided ","type":"text"},{"code":"center","type":"codeVoice"},{"type":"text","text":" point and "},{"type":"codeVoice","code":"size"},{"text":" value.","type":"text"},{"type":"text","text":" "},{"text":"The initializer then calls the structure’s automatic memberwise initializer","type":"text"},{"type":"text","text":" "},{"code":"init(origin:size:)","type":"codeVoice"},{"type":"text","text":", which stores the new origin and size values"},{"type":"text","text":" "},{"type":"text","text":"in the appropriate properties:"}]},{"syntax":"swift","code":["let centerRect = Rect(center: Point(x: 4.0, y: 4.0),","    size: Size(width: 3.0, height: 3.0))","\/\/ centerRect's origin is (2.5, 2.5) and its size is (3.0, 3.0)"],"type":"codeListing"},{"style":"note","content":[{"inlineContent":[{"type":"text","text":"If you provide a new initializer with an extension,"},{"text":" ","type":"text"},{"type":"text","text":"you are still responsible for making sure that each instance is fully initialized"},{"text":" ","type":"text"},{"text":"once the initializer completes.","type":"text"}],"type":"paragraph"}],"name":"Note","type":"aside"},{"anchor":"M%C3%A9todos","text":"Métodos","level":2,"type":"heading"},{"inlineContent":[{"text":"Extensions can add new instance methods and type methods to existing types.","type":"text"},{"type":"text","text":" "},{"text":"The following example adds a new instance method called ","type":"text"},{"type":"codeVoice","code":"repetitions"},{"text":" to the ","type":"text"},{"type":"codeVoice","code":"Int"},{"text":" type:","type":"text"}],"type":"paragraph"},{"type":"codeListing","code":["extension Int {","    func repetitions(task: () -> Void) {","        for _ in 0..<self {","            task()","        }","    }","}"],"syntax":"swift"},{"type":"paragraph","inlineContent":[{"text":"The ","type":"text"},{"type":"codeVoice","code":"repetitions(task:)"},{"type":"text","text":" method takes a single argument of type "},{"type":"codeVoice","code":"() -> Void"},{"type":"text","text":","},{"text":" ","type":"text"},{"type":"text","text":"which indicates a function that has no parameters and doesn’t return a value."}]},{"inlineContent":[{"type":"text","text":"After defining this extension,"},{"text":" ","type":"text"},{"text":"you can call the ","type":"text"},{"type":"codeVoice","code":"repetitions(task:)"},{"type":"text","text":" method on any integer"},{"text":" ","type":"text"},{"text":"to perform a task that many number of times:","type":"text"}],"type":"paragraph"},{"type":"codeListing","syntax":"swift","code":["3.repetitions {","    print(\"Hello!\")","}","\/\/ Hello!","\/\/ Hello!","\/\/ Hello!"]},{"type":"heading","text":"Métodos de instancia modificadores","level":3,"anchor":"M%C3%A9todos-de-instancia-modificadores"},{"type":"paragraph","inlineContent":[{"text":"Instance methods added with an extension can also modify (or ","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"mutate"}]},{"type":"text","text":") the instance itself."},{"type":"text","text":" "},{"text":"Structure and enumeration methods that modify ","type":"text"},{"code":"self","type":"codeVoice"},{"type":"text","text":" or its properties"},{"type":"text","text":" "},{"type":"text","text":"must mark the instance method as "},{"code":"mutating","type":"codeVoice"},{"text":",","type":"text"},{"type":"text","text":" "},{"text":"just like mutating methods from an original implementation.","type":"text"}]},{"inlineContent":[{"type":"text","text":"The example below adds a new mutating method called "},{"type":"codeVoice","code":"square"},{"type":"text","text":" to Swift’s "},{"code":"Int","type":"codeVoice"},{"type":"text","text":" type,"},{"text":" ","type":"text"},{"text":"which squares the original value:","type":"text"}],"type":"paragraph"},{"type":"codeListing","syntax":"swift","code":["extension Int {","    mutating func square() {","        self = self * self","    }","}","var someInt = 3","someInt.square()","\/\/ someInt is now 9"]},{"type":"heading","text":"Subíndices","level":2,"anchor":"Sub%C3%ADndices"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Extensions can add new subscripts to an existing type."},{"type":"text","text":" "},{"text":"This example adds an integer subscript to Swift’s built-in ","type":"text"},{"code":"Int","type":"codeVoice"},{"type":"text","text":" type."},{"type":"text","text":" "},{"type":"text","text":"This subscript "},{"type":"codeVoice","code":"[n]"},{"type":"text","text":" returns the decimal digit "},{"code":"n","type":"codeVoice"},{"type":"text","text":" places in"},{"text":" ","type":"text"},{"text":"from the right of the number:","type":"text"}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"123456789[0]"},{"text":" returns ","type":"text"},{"code":"9","type":"codeVoice"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"123456789[1]"},{"text":" returns ","type":"text"},{"code":"8","type":"codeVoice"}]}]}]},{"type":"paragraph","inlineContent":[{"text":"…and so on:","type":"text"}]},{"code":["extension Int {","    subscript(digitIndex: Int) -> Int {","        var decimalBase = 1","        for _ in 0..<digitIndex {","            decimalBase *= 10","        }","        return (self \/ decimalBase) % 10","    }","}","746381295[0]","\/\/ returns 5","746381295[1]","\/\/ returns 9","746381295[2]","\/\/ returns 2","746381295[8]","\/\/ returns 7"],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"type":"text","text":"If the "},{"code":"Int","type":"codeVoice"},{"text":" value doesn’t have enough digits for the requested index,","type":"text"},{"text":" ","type":"text"},{"text":"the subscript implementation returns ","type":"text"},{"code":"0","type":"codeVoice"},{"type":"text","text":","},{"text":" ","type":"text"},{"text":"as if the number had been padded with zeros to the left:","type":"text"}],"type":"paragraph"},{"syntax":"swift","code":["746381295[9]","\/\/ returns 0, as if you had requested:","0746381295[9]"],"type":"codeListing"},{"anchor":"Tipos-anidados","text":"Tipos anidados","level":2,"type":"heading"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Extensions can add new nested types to existing classes, structures, and enumerations:"}]},{"type":"codeListing","syntax":"swift","code":["extension Int {","    enum Kind {","        case negative, zero, positive","    }","    var kind: Kind {","        switch self {","        case 0:","            return .zero","        case let x where x > 0:","            return .positive","        default:","            return .negative","        }","    }","}"]},{"type":"paragraph","inlineContent":[{"text":"This example adds a new nested enumeration to ","type":"text"},{"type":"codeVoice","code":"Int"},{"type":"text","text":"."},{"text":" ","type":"text"},{"type":"text","text":"This enumeration, called "},{"type":"codeVoice","code":"Kind"},{"type":"text","text":","},{"text":" ","type":"text"},{"type":"text","text":"expresses the kind of number that a particular integer represents."},{"text":" ","type":"text"},{"text":"Specifically, it expresses whether the number is","type":"text"},{"type":"text","text":" "},{"text":"negative, zero, or positive.","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"This example also adds a new computed instance property to ","type":"text"},{"code":"Int","type":"codeVoice"},{"text":",","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"called "},{"type":"codeVoice","code":"kind"},{"type":"text","text":","},{"text":" ","type":"text"},{"type":"text","text":"which returns the appropriate "},{"code":"Kind","type":"codeVoice"},{"type":"text","text":" enumeration case for that integer."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The nested enumeration can now be used with any "},{"type":"codeVoice","code":"Int"},{"text":" value:","type":"text"}]},{"syntax":"swift","code":["func printIntegerKinds(_ numbers: [Int]) {","    for number in numbers {","        switch number.kind {","        case .negative:","            print(\"- \", terminator: \"\")","        case .zero:","            print(\"0 \", terminator: \"\")","        case .positive:","            print(\"+ \", terminator: \"\")","        }","    }","    print(\"\")","}","printIntegerKinds([3, 19, -27, 0, -6, 0, 7])","\/\/ Prints \"+ + - 0 - 0 + \""],"type":"codeListing"},{"inlineContent":[{"type":"text","text":"This function, "},{"code":"printIntegerKinds(_:)","type":"codeVoice"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"takes an input array of "},{"type":"codeVoice","code":"Int"},{"text":" values and iterates over those values in turn.","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"For each integer in the array,"},{"type":"text","text":" "},{"text":"the function considers the ","type":"text"},{"type":"codeVoice","code":"kind"},{"text":" computed property for that integer,","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"and prints an appropriate description."}],"type":"paragraph"},{"name":"Note","content":[{"type":"paragraph","inlineContent":[{"text":"","type":"text"},{"type":"codeVoice","code":"number.kind"},{"type":"text","text":" is already known to be of type "},{"code":"Int.Kind","type":"codeVoice"},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"Because of this, all of the "},{"code":"Int.Kind","type":"codeVoice"},{"text":" case values","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"can be written in shorthand form inside the "},{"code":"switch","type":"codeVoice"},{"text":" statement,","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"such as "},{"type":"codeVoice","code":".negative"},{"type":"text","text":" rather than "},{"type":"codeVoice","code":"Int.Kind.negative"},{"type":"text","text":"."}]}],"type":"aside","style":"note"},{"name":"Software Beta","style":"note","type":"aside","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":""}]},{"inlineContent":[{"type":"text","text":"Esta documentación contiene información preliminar sobre una API o tecnología en desarrollo. Esta información está sujeta a cambios, y todo software implementado en conformidad con esta documentación debe ser testeado con el software final del sistema operativo."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"Conoce más acerca del uso del "},{"type":"reference","isActive":true,"identifier":"https:\/\/developer.apple.com\/es\/support\/beta-software\/"},{"text":".","type":"text"}],"type":"paragraph"}]}]}],"kind":"article","references":{"doc://org.swift.tspl/documentation/The-Swift-Programming-Language":{"role":"collection","kind":"article","identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language","url":"\/documentation\/the-swift-programming-language","title":"The Swift Programming Language (6)","abstract":[],"type":"topic"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Initialization#Inicializadores-predeterminados":{"kind":"section","abstract":[],"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Initialization#Inicializadores-predeterminados","type":"topic","url":"\/documentation\/the-swift-programming-language\/initialization#Inicializadores-predeterminados","title":"Inicializadores predeterminados"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Initialization#Delegaci%C3%B3n-de-inicializadores-para-tipos-de-valor":{"title":"Delegación de inicializadores para tipos de valor","type":"topic","url":"\/documentation\/the-swift-programming-language\/initialization#Delegaci%C3%B3n-de-inicializadores-para-tipos-de-valor","identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Initialization#Delegaci%C3%B3n-de-inicializadores-para-tipos-de-valor","abstract":[],"kind":"section"},"https://developer.apple.com/es/support/beta-software/":{"title":"software beta de Apple","type":"link","titleInlineContent":[{"type":"text","text":"software beta de Apple"}],"identifier":"https:\/\/developer.apple.com\/es\/support\/beta-software\/","url":"https:\/\/developer.apple.com\/es\/support\/beta-software\/"}}}
||||||| parent of 2fa5d86d (yet one more fix attempt)
{"abstract":[{"type":"text","text":"Add functionality to an existing type."}],"identifier":{"interfaceLanguage":"swift","url":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Extensions"},"sections":[],"hierarchy":{"paths":[["doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language"]]},"primaryContentSections":[{"kind":"content","content":[{"type":"paragraph","inlineContent":[{"inlineContent":[{"text":"Extensions","type":"text"}],"type":"emphasis"},{"text":" add new functionality to an existing","type":"text"},{"text":" ","type":"text"},{"text":"class, structure, enumeration, or protocol type.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"This includes the ability to extend types"},{"text":" ","type":"text"},{"type":"text","text":"for which you don’t have access to the original source code"},{"text":" ","type":"text"},{"type":"text","text":"(known as "},{"inlineContent":[{"text":"retroactive modeling","type":"text"}],"type":"emphasis"},{"text":").","type":"text"},{"type":"text","text":" "},{"type":"text","text":"Extensions are similar to categories in Objective-C."},{"text":" ","type":"text"},{"type":"text","text":"(Unlike Objective-C categories, Swift extensions don’t have names.)"}]},{"inlineContent":[{"type":"text","text":"Extensions in Swift can:"}],"type":"paragraph"},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"Add computed instance properties and computed type properties","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"Define instance methods and type methods","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Provide new initializers"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Define subscripts"}]}]},{"content":[{"inlineContent":[{"text":"Define and use new nested types","type":"text"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Make an existing type conform to a protocol"}]}]}]},{"inlineContent":[{"text":"In Swift,","type":"text"},{"type":"text","text":" "},{"text":"you can even extend a protocol to provide implementations of its requirements","type":"text"},{"type":"text","text":" "},{"text":"or add additional functionality that conforming types can take advantage of.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"For more details, see "},{"type":"text","text":"doc:Protocols#Extensión-de-protocolos"},{"type":"text","text":"."}],"type":"paragraph"},{"style":"note","type":"aside","name":"Note","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Extensions can add new functionality to a type,"},{"text":" ","type":"text"},{"text":"but they can’t override existing functionality.","type":"text"}]}]},{"type":"heading","level":2,"text":"Sintaxis de una extensión","anchor":"Sintaxis-de-una-extensi%C3%B3n"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Declare extensions with the "},{"type":"codeVoice","code":"extension"},{"text":" keyword:","type":"text"}]},{"code":["extension SomeType {","    \/\/ new functionality to add to SomeType goes here","}"],"type":"codeListing","syntax":"swift"},{"type":"paragraph","inlineContent":[{"text":"An extension can extend an existing type to make it adopt one or more protocols.","type":"text"},{"type":"text","text":" "},{"text":"To add protocol conformance,","type":"text"},{"text":" ","type":"text"},{"text":"you write the protocol names","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"the same way as you write them for a class or structure:"}]},{"type":"codeListing","syntax":"swift","code":["extension SomeType: SomeProtocol, AnotherProtocol {","    \/\/ implementation of protocol requirements goes here","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Adding protocol conformance in this way is described in"},{"type":"text","text":" "},{"type":"text","text":"doc:Protocols#Agregar-conformidad-protocolaria-mediante-una-extensión"},{"text":".","type":"text"}]},{"inlineContent":[{"text":"An extension can be used to extend an existing generic type,","type":"text"},{"text":" ","type":"text"},{"text":"as described in ","type":"text"},{"type":"text","text":"doc:Generics#Extendiendo-un-tipo-genérico"},{"text":".","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"You can also extend a generic type to conditionally add functionality,"},{"text":" ","type":"text"},{"type":"text","text":"as described in "},{"type":"text","text":"doc:Generics#Extensiones-con-una-cláusula-where-genérica"},{"type":"text","text":"."}],"type":"paragraph"},{"content":[{"inlineContent":[{"type":"text","text":"If you define an extension to add new functionality to an existing type,"},{"text":" ","type":"text"},{"text":"the new functionality will be available on all existing instances of that type,","type":"text"},{"type":"text","text":" "},{"type":"text","text":"even if they were created before the extension was defined."}],"type":"paragraph"}],"style":"note","name":"Note","type":"aside"},{"level":2,"text":"Propiedades computadas","anchor":"Propiedades-computadas","type":"heading"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Extensions can add computed instance properties and computed type properties to existing types."},{"type":"text","text":" "},{"type":"text","text":"This example adds five computed instance properties to Swift’s built-in "},{"code":"Double","type":"codeVoice"},{"text":" type,","type":"text"},{"type":"text","text":" "},{"text":"to provide basic support for working with distance units:","type":"text"}]},{"code":["extension Double {","    var km: Double { return self * 1_000.0 }","    var m: Double { return self }","    var cm: Double { return self \/ 100.0 }","    var mm: Double { return self \/ 1_000.0 }","    var ft: Double { return self \/ 3.28084 }","}","let oneInch = 25.4.mm","print(\"One inch is \\(oneInch) meters\")","\/\/ Prints \"One inch is 0.0254 meters\"","let threeFeet = 3.ft","print(\"Three feet is \\(threeFeet) meters\")","\/\/ Prints \"Three feet is 0.914399970739201 meters\""],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"text":"These computed properties express that a ","type":"text"},{"code":"Double","type":"codeVoice"},{"type":"text","text":" value"},{"text":" ","type":"text"},{"text":"should be considered as a certain unit of length.","type":"text"},{"text":" ","type":"text"},{"text":"Although they’re implemented as computed properties,","type":"text"},{"text":" ","type":"text"},{"text":"the names of these properties can be appended to","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"a floating-point literal value with dot syntax,"},{"type":"text","text":" "},{"text":"as a way to use that literal value to perform distance conversions.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"In this example, a ","type":"text"},{"code":"Double","type":"codeVoice"},{"type":"text","text":" value of "},{"type":"codeVoice","code":"1.0"},{"type":"text","text":" is considered to represent “one meter”."},{"text":" ","type":"text"},{"text":"This is why the ","type":"text"},{"type":"codeVoice","code":"m"},{"text":" computed property returns ","type":"text"},{"code":"self","type":"codeVoice"},{"text":" —","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"the expression "},{"type":"codeVoice","code":"1.m"},{"text":" is considered to calculate a ","type":"text"},{"code":"Double","type":"codeVoice"},{"type":"text","text":" value of "},{"type":"codeVoice","code":"1.0"},{"type":"text","text":"."}],"type":"paragraph"},{"inlineContent":[{"text":"Other units require some conversion to be expressed as a value measured in meters.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"One kilometer is the same as 1,000 meters,"},{"text":" ","type":"text"},{"text":"so the ","type":"text"},{"code":"km","type":"codeVoice"},{"text":" computed property multiplies the value by ","type":"text"},{"code":"1_000.00","type":"codeVoice"},{"text":" ","type":"text"},{"type":"text","text":"to convert into a number expressed in meters."},{"type":"text","text":" "},{"text":"Similarly, there are 3.28084 feet in a meter,","type":"text"},{"type":"text","text":" "},{"text":"and so the ","type":"text"},{"code":"ft","type":"codeVoice"},{"type":"text","text":" computed property divides the underlying "},{"type":"codeVoice","code":"Double"},{"type":"text","text":" value"},{"type":"text","text":" "},{"text":"by ","type":"text"},{"type":"codeVoice","code":"3.28084"},{"type":"text","text":", to convert it from feet to meters."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"These properties are read-only computed properties,"},{"type":"text","text":" "},{"type":"text","text":"and so they’re expressed without the "},{"code":"get","type":"codeVoice"},{"type":"text","text":" keyword, for brevity."},{"text":" ","type":"text"},{"text":"Their return value is of type ","type":"text"},{"type":"codeVoice","code":"Double"},{"text":",","type":"text"},{"type":"text","text":" "},{"type":"text","text":"and can be used within mathematical calculations wherever a "},{"code":"Double","type":"codeVoice"},{"type":"text","text":" is accepted:"}]},{"code":["let aMarathon = 42.km + 195.m","print(\"A marathon is \\(aMarathon) meters long\")","\/\/ Prints \"A marathon is 42195.0 meters long\""],"syntax":"swift","type":"codeListing"},{"type":"aside","style":"note","name":"Note","content":[{"inlineContent":[{"type":"text","text":"Extensions can add new computed properties, but they can’t add stored properties,"},{"type":"text","text":" "},{"type":"text","text":"or add property observers to existing properties."}],"type":"paragraph"}]},{"level":2,"type":"heading","anchor":"Inicializadores","text":"Inicializadores"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Extensions can add new initializers to existing types."},{"text":" ","type":"text"},{"type":"text","text":"This enables you to extend other types to accept"},{"type":"text","text":" "},{"type":"text","text":"your own custom types as initializer parameters,"},{"text":" ","type":"text"},{"type":"text","text":"or to provide additional initialization options"},{"text":" ","type":"text"},{"text":"that were not included as part of the type’s original implementation.","type":"text"}]},{"inlineContent":[{"type":"text","text":"Extensions can add new convenience initializers to a class,"},{"text":" ","type":"text"},{"text":"but they can’t add new designated initializers or deinitializers to a class.","type":"text"},{"text":" ","type":"text"},{"text":"Designated initializers and deinitializers","type":"text"},{"type":"text","text":" "},{"text":"must always be provided by the original class implementation.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"If you use an extension to add an initializer to a value type that provides","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"default values for all of its stored properties"},{"type":"text","text":" "},{"type":"text","text":"and doesn’t define any custom initializers,"},{"type":"text","text":" "},{"type":"text","text":"you can call the default initializer and memberwise initializer for that value type"},{"type":"text","text":" "},{"text":"from within your extension’s initializer.","type":"text"},{"type":"text","text":" "},{"text":"This wouldn’t be the case if you had written the initializer","type":"text"},{"text":" ","type":"text"},{"text":"as part of the value type’s original implementation,","type":"text"},{"type":"text","text":" "},{"type":"text","text":"as described in "},{"type":"reference","isActive":true,"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Initialization#Delegaci%C3%B3n-de-inicializadores-para-tipos-de-valor"},{"text":".","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"If you use an extension to add an initializer to a structure"},{"text":" ","type":"text"},{"text":"that was declared in another module,","type":"text"},{"text":" ","type":"text"},{"text":"the new initializer can’t access ","type":"text"},{"type":"codeVoice","code":"self"},{"text":" until it calls","type":"text"},{"text":" ","type":"text"},{"text":"an initializer from the defining module.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"The example below defines a custom "},{"type":"codeVoice","code":"Rect"},{"type":"text","text":" structure to represent a geometric rectangle."},{"type":"text","text":" "},{"type":"text","text":"The example also defines two supporting structures called "},{"code":"Size","type":"codeVoice"},{"type":"text","text":" and "},{"code":"Point","type":"codeVoice"},{"type":"text","text":","},{"text":" ","type":"text"},{"type":"text","text":"both of which provide default values of "},{"code":"0.0","type":"codeVoice"},{"type":"text","text":" for all of their properties:"}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["struct Size {","    var width = 0.0, height = 0.0","}","struct Point {","    var x = 0.0, y = 0.0","}","struct Rect {","    var origin = Point()","    var size = Size()","}"]},{"inlineContent":[{"text":"Because the ","type":"text"},{"type":"codeVoice","code":"Rect"},{"type":"text","text":" structure provides default values for all of its properties,"},{"text":" ","type":"text"},{"type":"text","text":"it receives a default initializer and a memberwise initializer automatically,"},{"text":" ","type":"text"},{"type":"text","text":"as described in "},{"type":"reference","identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Initialization#Inicializadores-predeterminados","isActive":true},{"type":"text","text":"."},{"text":" ","type":"text"},{"type":"text","text":"These initializers can be used to create new "},{"type":"codeVoice","code":"Rect"},{"text":" instances:","type":"text"}],"type":"paragraph"},{"type":"codeListing","syntax":"swift","code":["let defaultRect = Rect()","let memberwiseRect = Rect(origin: Point(x: 2.0, y: 2.0),","    size: Size(width: 5.0, height: 5.0))"]},{"type":"paragraph","inlineContent":[{"text":"You can extend the ","type":"text"},{"code":"Rect","type":"codeVoice"},{"text":" structure to provide an additional initializer","type":"text"},{"type":"text","text":" "},{"type":"text","text":"that takes a specific center point and size:"}]},{"type":"codeListing","code":["extension Rect {","    init(center: Point, size: Size) {","        let originX = center.x - (size.width \/ 2)","        let originY = center.y - (size.height \/ 2)","        self.init(origin: Point(x: originX, y: originY), size: size)","    }","}"],"syntax":"swift"},{"type":"paragraph","inlineContent":[{"type":"text","text":"This new initializer starts by calculating an appropriate origin point based on"},{"type":"text","text":" "},{"text":"the provided ","type":"text"},{"type":"codeVoice","code":"center"},{"type":"text","text":" point and "},{"code":"size","type":"codeVoice"},{"text":" value.","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"The initializer then calls the structure’s automatic memberwise initializer"},{"text":" ","type":"text"},{"code":"init(origin:size:)","type":"codeVoice"},{"type":"text","text":", which stores the new origin and size values"},{"text":" ","type":"text"},{"type":"text","text":"in the appropriate properties:"}]},{"type":"codeListing","syntax":"swift","code":["let centerRect = Rect(center: Point(x: 4.0, y: 4.0),","    size: Size(width: 3.0, height: 3.0))","\/\/ centerRect's origin is (2.5, 2.5) and its size is (3.0, 3.0)"]},{"name":"Note","type":"aside","style":"note","content":[{"inlineContent":[{"text":"If you provide a new initializer with an extension,","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"you are still responsible for making sure that each instance is fully initialized"},{"text":" ","type":"text"},{"text":"once the initializer completes.","type":"text"}],"type":"paragraph"}]},{"text":"Métodos","level":2,"anchor":"M%C3%A9todos","type":"heading"},{"inlineContent":[{"type":"text","text":"Extensions can add new instance methods and type methods to existing types."},{"type":"text","text":" "},{"text":"The following example adds a new instance method called ","type":"text"},{"code":"repetitions","type":"codeVoice"},{"type":"text","text":" to the "},{"code":"Int","type":"codeVoice"},{"text":" type:","type":"text"}],"type":"paragraph"},{"code":["extension Int {","    func repetitions(task: () -> Void) {","        for _ in 0..<self {","            task()","        }","    }","}"],"type":"codeListing","syntax":"swift"},{"type":"paragraph","inlineContent":[{"text":"The ","type":"text"},{"code":"repetitions(task:)","type":"codeVoice"},{"type":"text","text":" method takes a single argument of type "},{"type":"codeVoice","code":"() -> Void"},{"type":"text","text":","},{"type":"text","text":" "},{"text":"which indicates a function that has no parameters and doesn’t return a value.","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"After defining this extension,","type":"text"},{"type":"text","text":" "},{"type":"text","text":"you can call the "},{"code":"repetitions(task:)","type":"codeVoice"},{"text":" method on any integer","type":"text"},{"type":"text","text":" "},{"text":"to perform a task that many number of times:","type":"text"}]},{"code":["3.repetitions {","    print(\"Hello!\")","}","\/\/ Hello!","\/\/ Hello!","\/\/ Hello!"],"type":"codeListing","syntax":"swift"},{"anchor":"M%C3%A9todos-de-instancia-modificadores","text":"Métodos de instancia modificadores","level":3,"type":"heading"},{"inlineContent":[{"text":"Instance methods added with an extension can also modify (or ","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"mutate"}]},{"type":"text","text":") the instance itself."},{"text":" ","type":"text"},{"type":"text","text":"Structure and enumeration methods that modify "},{"type":"codeVoice","code":"self"},{"type":"text","text":" or its properties"},{"text":" ","type":"text"},{"type":"text","text":"must mark the instance method as "},{"type":"codeVoice","code":"mutating"},{"type":"text","text":","},{"text":" ","type":"text"},{"type":"text","text":"just like mutating methods from an original implementation."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"The example below adds a new mutating method called "},{"type":"codeVoice","code":"square"},{"type":"text","text":" to Swift’s "},{"type":"codeVoice","code":"Int"},{"type":"text","text":" type,"},{"type":"text","text":" "},{"text":"which squares the original value:","type":"text"}],"type":"paragraph"},{"code":["extension Int {","    mutating func square() {","        self = self * self","    }","}","var someInt = 3","someInt.square()","\/\/ someInt is now 9"],"type":"codeListing","syntax":"swift"},{"level":2,"text":"Subíndices","type":"heading","anchor":"Sub%C3%ADndices"},{"type":"paragraph","inlineContent":[{"text":"Extensions can add new subscripts to an existing type.","type":"text"},{"type":"text","text":" "},{"text":"This example adds an integer subscript to Swift’s built-in ","type":"text"},{"code":"Int","type":"codeVoice"},{"type":"text","text":" type."},{"type":"text","text":" "},{"type":"text","text":"This subscript "},{"code":"[n]","type":"codeVoice"},{"text":" returns the decimal digit ","type":"text"},{"code":"n","type":"codeVoice"},{"text":" places in","type":"text"},{"type":"text","text":" "},{"text":"from the right of the number:","type":"text"}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"code":"123456789[0]","type":"codeVoice"},{"text":" returns ","type":"text"},{"type":"codeVoice","code":"9"}]}]},{"content":[{"inlineContent":[{"type":"codeVoice","code":"123456789[1]"},{"type":"text","text":" returns "},{"type":"codeVoice","code":"8"}],"type":"paragraph"}]}]},{"type":"paragraph","inlineContent":[{"text":"…and so on:","type":"text"}]},{"type":"codeListing","syntax":"swift","code":["extension Int {","    subscript(digitIndex: Int) -> Int {","        var decimalBase = 1","        for _ in 0..<digitIndex {","            decimalBase *= 10","        }","        return (self \/ decimalBase) % 10","    }","}","746381295[0]","\/\/ returns 5","746381295[1]","\/\/ returns 9","746381295[2]","\/\/ returns 2","746381295[8]","\/\/ returns 7"]},{"type":"paragraph","inlineContent":[{"text":"If the ","type":"text"},{"type":"codeVoice","code":"Int"},{"type":"text","text":" value doesn’t have enough digits for the requested index,"},{"text":" ","type":"text"},{"text":"the subscript implementation returns ","type":"text"},{"code":"0","type":"codeVoice"},{"text":",","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"as if the number had been padded with zeros to the left:"}]},{"code":["746381295[9]","\/\/ returns 0, as if you had requested:","0746381295[9]"],"type":"codeListing","syntax":"swift"},{"text":"Tipos anidados","level":2,"anchor":"Tipos-anidados","type":"heading"},{"type":"paragraph","inlineContent":[{"text":"Extensions can add new nested types to existing classes, structures, and enumerations:","type":"text"}]},{"syntax":"swift","type":"codeListing","code":["extension Int {","    enum Kind {","        case negative, zero, positive","    }","    var kind: Kind {","        switch self {","        case 0:","            return .zero","        case let x where x > 0:","            return .positive","        default:","            return .negative","        }","    }","}"]},{"inlineContent":[{"type":"text","text":"This example adds a new nested enumeration to "},{"code":"Int","type":"codeVoice"},{"text":".","type":"text"},{"type":"text","text":" "},{"type":"text","text":"This enumeration, called "},{"code":"Kind","type":"codeVoice"},{"text":",","type":"text"},{"type":"text","text":" "},{"text":"expresses the kind of number that a particular integer represents.","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"Specifically, it expresses whether the number is"},{"type":"text","text":" "},{"text":"negative, zero, or positive.","type":"text"}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"This example also adds a new computed instance property to "},{"type":"codeVoice","code":"Int"},{"type":"text","text":","},{"text":" ","type":"text"},{"type":"text","text":"called "},{"type":"codeVoice","code":"kind"},{"text":",","type":"text"},{"text":" ","type":"text"},{"text":"which returns the appropriate ","type":"text"},{"type":"codeVoice","code":"Kind"},{"type":"text","text":" enumeration case for that integer."}]},{"inlineContent":[{"text":"The nested enumeration can now be used with any ","type":"text"},{"type":"codeVoice","code":"Int"},{"type":"text","text":" value:"}],"type":"paragraph"},{"type":"codeListing","code":["func printIntegerKinds(_ numbers: [Int]) {","    for number in numbers {","        switch number.kind {","        case .negative:","            print(\"- \", terminator: \"\")","        case .zero:","            print(\"0 \", terminator: \"\")","        case .positive:","            print(\"+ \", terminator: \"\")","        }","    }","    print(\"\")","}","printIntegerKinds([3, 19, -27, 0, -6, 0, 7])","\/\/ Prints \"+ + - 0 - 0 + \""],"syntax":"swift"},{"type":"paragraph","inlineContent":[{"type":"text","text":"This function, "},{"code":"printIntegerKinds(_:)","type":"codeVoice"},{"type":"text","text":","},{"type":"text","text":" "},{"text":"takes an input array of ","type":"text"},{"type":"codeVoice","code":"Int"},{"text":" values and iterates over those values in turn.","type":"text"},{"text":" ","type":"text"},{"text":"For each integer in the array,","type":"text"},{"type":"text","text":" "},{"text":"the function considers the ","type":"text"},{"code":"kind","type":"codeVoice"},{"text":" computed property for that integer,","type":"text"},{"type":"text","text":" "},{"text":"and prints an appropriate description.","type":"text"}]},{"name":"Note","style":"note","content":[{"type":"paragraph","inlineContent":[{"text":"","type":"text"},{"code":"number.kind","type":"codeVoice"},{"text":" is already known to be of type ","type":"text"},{"type":"codeVoice","code":"Int.Kind"},{"text":".","type":"text"},{"type":"text","text":" "},{"type":"text","text":"Because of this, all of the "},{"code":"Int.Kind","type":"codeVoice"},{"text":" case values","type":"text"},{"text":" ","type":"text"},{"text":"can be written in shorthand form inside the ","type":"text"},{"type":"codeVoice","code":"switch"},{"type":"text","text":" statement,"},{"type":"text","text":" "},{"type":"text","text":"such as "},{"type":"codeVoice","code":".negative"},{"type":"text","text":" rather than "},{"code":"Int.Kind.negative","type":"codeVoice"},{"type":"text","text":"."}]}],"type":"aside"},{"type":"aside","name":"Software Beta","style":"note","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":""}]},{"inlineContent":[{"type":"text","text":"Esta documentación contiene información preliminar sobre una API o tecnología en desarrollo. Esta información está sujeta a cambios, y todo software implementado en conformidad con esta documentación debe ser testeado con el software final del sistema operativo."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Conoce más acerca del uso del "},{"identifier":"https:\/\/developer.apple.com\/es\/support\/beta-software\/","type":"reference","isActive":true},{"type":"text","text":"."}]}]}]}],"kind":"article","schemaVersion":{"minor":3,"major":0,"patch":0},"metadata":{"title":"Extensiones"},"references":{"doc://org.swift.tspl/documentation/The-Swift-Programming-Language":{"kind":"article","role":"collection","url":"\/documentation\/the-swift-programming-language","abstract":[],"title":"The Swift Programming Language (6)","type":"topic","identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Initialization#Inicializadores-predeterminados":{"kind":"section","title":"Inicializadores predeterminados","type":"topic","url":"\/documentation\/the-swift-programming-language\/initialization#Inicializadores-predeterminados","identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Initialization#Inicializadores-predeterminados","abstract":[]},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Initialization#Delegaci%C3%B3n-de-inicializadores-para-tipos-de-valor":{"kind":"section","identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Initialization#Delegaci%C3%B3n-de-inicializadores-para-tipos-de-valor","url":"\/documentation\/the-swift-programming-language\/initialization#Delegaci%C3%B3n-de-inicializadores-para-tipos-de-valor","type":"topic","abstract":[],"title":"Delegación de inicializadores para tipos de valor"},"https://developer.apple.com/es/support/beta-software/":{"titleInlineContent":[{"type":"text","text":"software beta de Apple"}],"identifier":"https:\/\/developer.apple.com\/es\/support\/beta-software\/","url":"https:\/\/developer.apple.com\/es\/support\/beta-software\/","type":"link","title":"software beta de Apple"}}}
=======
{"kind":"article","sections":[],"schemaVersion":{"minor":3,"major":0,"patch":0},"metadata":{"title":"Extensiones"},"abstract":[{"type":"text","text":"Add functionality to an existing type."}],"identifier":{"url":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Extensions","interfaceLanguage":"swift"},"primaryContentSections":[{"content":[{"inlineContent":[{"type":"emphasis","inlineContent":[{"type":"text","text":"Extensions"}]},{"text":" add new functionality to an existing","type":"text"},{"type":"text","text":" "},{"type":"text","text":"class, structure, enumeration, or protocol type."},{"type":"text","text":" "},{"type":"text","text":"This includes the ability to extend types"},{"type":"text","text":" "},{"text":"for which you don’t have access to the original source code","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"(known as "},{"inlineContent":[{"text":"retroactive modeling","type":"text"}],"type":"emphasis"},{"text":").","type":"text"},{"type":"text","text":" "},{"type":"text","text":"Extensions are similar to categories in Objective-C."},{"type":"text","text":" "},{"text":"(Unlike Objective-C categories, Swift extensions don’t have names.)","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"Extensions in Swift can:"}],"type":"paragraph"},{"items":[{"content":[{"inlineContent":[{"type":"text","text":"Add computed instance properties and computed type properties"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"Define instance methods and type methods","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"Provide new initializers","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Define subscripts"}]}]},{"content":[{"inlineContent":[{"type":"text","text":"Define and use new nested types"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"text":"Make an existing type conform to a protocol","type":"text"}],"type":"paragraph"}]}],"type":"unorderedList"},{"type":"paragraph","inlineContent":[{"type":"text","text":"In Swift,"},{"type":"text","text":" "},{"type":"text","text":"you can even extend a protocol to provide implementations of its requirements"},{"text":" ","type":"text"},{"text":"or add additional functionality that conforming types can take advantage of.","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"For more details, see "},{"type":"text","text":"doc:Protocols#Extensión-de-protocolos"},{"type":"text","text":"."}]},{"type":"aside","name":"Note","style":"note","content":[{"inlineContent":[{"type":"text","text":"Extensions can add new functionality to a type,"},{"text":" ","type":"text"},{"text":"but they can’t override existing functionality.","type":"text"}],"type":"paragraph"}]},{"anchor":"Sintaxis-de-una-extensi%C3%B3n","level":2,"text":"Sintaxis de una extensión","type":"heading"},{"inlineContent":[{"type":"text","text":"Declare extensions with the "},{"type":"codeVoice","code":"extension"},{"text":" keyword:","type":"text"}],"type":"paragraph"},{"type":"codeListing","syntax":"swift","code":["extension SomeType {","    \/\/ new functionality to add to SomeType goes here","}"]},{"inlineContent":[{"text":"An extension can extend an existing type to make it adopt one or more protocols.","type":"text"},{"type":"text","text":" "},{"text":"To add protocol conformance,","type":"text"},{"type":"text","text":" "},{"text":"you write the protocol names","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"the same way as you write them for a class or structure:"}],"type":"paragraph"},{"code":["extension SomeType: SomeProtocol, AnotherProtocol {","    \/\/ implementation of protocol requirements goes here","}"],"type":"codeListing","syntax":"swift"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Adding protocol conformance in this way is described in"},{"type":"text","text":" "},{"text":"doc:Protocols#Agregar-conformidad-protocolaria-mediante-una-extensión","type":"text"},{"text":".","type":"text"}]},{"inlineContent":[{"type":"text","text":"An extension can be used to extend an existing generic type,"},{"type":"text","text":" "},{"type":"text","text":"as described in "},{"type":"text","text":"doc:Generics#Extendiendo-un-tipo-genérico"},{"text":".","type":"text"},{"text":" ","type":"text"},{"text":"You can also extend a generic type to conditionally add functionality,","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"as described in "},{"type":"text","text":"doc:Generics#Extensiones-con-una-cláusula-where-genérica"},{"text":".","type":"text"}],"type":"paragraph"},{"style":"note","name":"Note","content":[{"type":"paragraph","inlineContent":[{"text":"If you define an extension to add new functionality to an existing type,","type":"text"},{"type":"text","text":" "},{"type":"text","text":"the new functionality will be available on all existing instances of that type,"},{"text":" ","type":"text"},{"text":"even if they were created before the extension was defined.","type":"text"}]}],"type":"aside"},{"anchor":"Propiedades-computadas","text":"Propiedades computadas","type":"heading","level":2},{"type":"paragraph","inlineContent":[{"text":"Extensions can add computed instance properties and computed type properties to existing types.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"This example adds five computed instance properties to Swift’s built-in "},{"type":"codeVoice","code":"Double"},{"text":" type,","type":"text"},{"type":"text","text":" "},{"type":"text","text":"to provide basic support for working with distance units:"}]},{"type":"codeListing","code":["extension Double {","    var km: Double { return self * 1_000.0 }","    var m: Double { return self }","    var cm: Double { return self \/ 100.0 }","    var mm: Double { return self \/ 1_000.0 }","    var ft: Double { return self \/ 3.28084 }","}","let oneInch = 25.4.mm","print(\"One inch is \\(oneInch) meters\")","\/\/ Prints \"One inch is 0.0254 meters\"","let threeFeet = 3.ft","print(\"Three feet is \\(threeFeet) meters\")","\/\/ Prints \"Three feet is 0.914399970739201 meters\""],"syntax":"swift"},{"type":"paragraph","inlineContent":[{"text":"These computed properties express that a ","type":"text"},{"code":"Double","type":"codeVoice"},{"type":"text","text":" value"},{"text":" ","type":"text"},{"type":"text","text":"should be considered as a certain unit of length."},{"text":" ","type":"text"},{"text":"Although they’re implemented as computed properties,","type":"text"},{"type":"text","text":" "},{"text":"the names of these properties can be appended to","type":"text"},{"type":"text","text":" "},{"text":"a floating-point literal value with dot syntax,","type":"text"},{"type":"text","text":" "},{"type":"text","text":"as a way to use that literal value to perform distance conversions."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"In this example, a "},{"type":"codeVoice","code":"Double"},{"type":"text","text":" value of "},{"code":"1.0","type":"codeVoice"},{"type":"text","text":" is considered to represent “one meter”."},{"text":" ","type":"text"},{"type":"text","text":"This is why the "},{"code":"m","type":"codeVoice"},{"type":"text","text":" computed property returns "},{"code":"self","type":"codeVoice"},{"type":"text","text":" —"},{"text":" ","type":"text"},{"text":"the expression ","type":"text"},{"type":"codeVoice","code":"1.m"},{"text":" is considered to calculate a ","type":"text"},{"code":"Double","type":"codeVoice"},{"text":" value of ","type":"text"},{"code":"1.0","type":"codeVoice"},{"type":"text","text":"."}]},{"inlineContent":[{"type":"text","text":"Other units require some conversion to be expressed as a value measured in meters."},{"text":" ","type":"text"},{"text":"One kilometer is the same as 1,000 meters,","type":"text"},{"type":"text","text":" "},{"type":"text","text":"so the "},{"code":"km","type":"codeVoice"},{"text":" computed property multiplies the value by ","type":"text"},{"code":"1_000.00","type":"codeVoice"},{"type":"text","text":" "},{"type":"text","text":"to convert into a number expressed in meters."},{"type":"text","text":" "},{"type":"text","text":"Similarly, there are 3.28084 feet in a meter,"},{"type":"text","text":" "},{"type":"text","text":"and so the "},{"type":"codeVoice","code":"ft"},{"text":" computed property divides the underlying ","type":"text"},{"type":"codeVoice","code":"Double"},{"text":" value","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"by "},{"type":"codeVoice","code":"3.28084"},{"text":", to convert it from feet to meters.","type":"text"}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"These properties are read-only computed properties,"},{"text":" ","type":"text"},{"text":"and so they’re expressed without the ","type":"text"},{"type":"codeVoice","code":"get"},{"text":" keyword, for brevity.","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"Their return value is of type "},{"type":"codeVoice","code":"Double"},{"text":",","type":"text"},{"type":"text","text":" "},{"text":"and can be used within mathematical calculations wherever a ","type":"text"},{"code":"Double","type":"codeVoice"},{"type":"text","text":" is accepted:"}]},{"code":["let aMarathon = 42.km + 195.m","print(\"A marathon is \\(aMarathon) meters long\")","\/\/ Prints \"A marathon is 42195.0 meters long\""],"type":"codeListing","syntax":"swift"},{"style":"note","type":"aside","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Extensions can add new computed properties, but they can’t add stored properties,"},{"text":" ","type":"text"},{"text":"or add property observers to existing properties.","type":"text"}]}],"name":"Note"},{"anchor":"Inicializadores","text":"Inicializadores","type":"heading","level":2},{"inlineContent":[{"type":"text","text":"Extensions can add new initializers to existing types."},{"type":"text","text":" "},{"type":"text","text":"This enables you to extend other types to accept"},{"text":" ","type":"text"},{"text":"your own custom types as initializer parameters,","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"or to provide additional initialization options"},{"text":" ","type":"text"},{"type":"text","text":"that were not included as part of the type’s original implementation."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"text":"Extensions can add new convenience initializers to a class,","type":"text"},{"text":" ","type":"text"},{"text":"but they can’t add new designated initializers or deinitializers to a class.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"Designated initializers and deinitializers"},{"type":"text","text":" "},{"type":"text","text":"must always be provided by the original class implementation."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"If you use an extension to add an initializer to a value type that provides"},{"text":" ","type":"text"},{"type":"text","text":"default values for all of its stored properties"},{"text":" ","type":"text"},{"type":"text","text":"and doesn’t define any custom initializers,"},{"text":" ","type":"text"},{"type":"text","text":"you can call the default initializer and memberwise initializer for that value type"},{"text":" ","type":"text"},{"type":"text","text":"from within your extension’s initializer."},{"type":"text","text":" "},{"type":"text","text":"This wouldn’t be the case if you had written the initializer"},{"text":" ","type":"text"},{"type":"text","text":"as part of the value type’s original implementation,"},{"text":" ","type":"text"},{"type":"text","text":"as described in "},{"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Initialization#Delegaci%C3%B3n-de-inicializadores-para-tipos-de-valor","type":"reference","isActive":true},{"type":"text","text":"."}]},{"type":"paragraph","inlineContent":[{"text":"If you use an extension to add an initializer to a structure","type":"text"},{"type":"text","text":" "},{"type":"text","text":"that was declared in another module,"},{"text":" ","type":"text"},{"text":"the new initializer can’t access ","type":"text"},{"type":"codeVoice","code":"self"},{"text":" until it calls","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"an initializer from the defining module."}]},{"inlineContent":[{"type":"text","text":"The example below defines a custom "},{"type":"codeVoice","code":"Rect"},{"type":"text","text":" structure to represent a geometric rectangle."},{"type":"text","text":" "},{"text":"The example also defines two supporting structures called ","type":"text"},{"type":"codeVoice","code":"Size"},{"type":"text","text":" and "},{"type":"codeVoice","code":"Point"},{"text":",","type":"text"},{"text":" ","type":"text"},{"text":"both of which provide default values of ","type":"text"},{"code":"0.0","type":"codeVoice"},{"type":"text","text":" for all of their properties:"}],"type":"paragraph"},{"type":"codeListing","code":["struct Size {","    var width = 0.0, height = 0.0","}","struct Point {","    var x = 0.0, y = 0.0","}","struct Rect {","    var origin = Point()","    var size = Size()","}"],"syntax":"swift"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Because the "},{"type":"codeVoice","code":"Rect"},{"text":" structure provides default values for all of its properties,","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"it receives a default initializer and a memberwise initializer automatically,"},{"type":"text","text":" "},{"type":"text","text":"as described in "},{"type":"reference","identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Initialization#Inicializadores-predeterminados","isActive":true},{"type":"text","text":"."},{"type":"text","text":" "},{"text":"These initializers can be used to create new ","type":"text"},{"code":"Rect","type":"codeVoice"},{"type":"text","text":" instances:"}]},{"code":["let defaultRect = Rect()","let memberwiseRect = Rect(origin: Point(x: 2.0, y: 2.0),","    size: Size(width: 5.0, height: 5.0))"],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"text":"You can extend the ","type":"text"},{"type":"codeVoice","code":"Rect"},{"text":" structure to provide an additional initializer","type":"text"},{"type":"text","text":" "},{"text":"that takes a specific center point and size:","type":"text"}],"type":"paragraph"},{"syntax":"swift","code":["extension Rect {","    init(center: Point, size: Size) {","        let originX = center.x - (size.width \/ 2)","        let originY = center.y - (size.height \/ 2)","        self.init(origin: Point(x: originX, y: originY), size: size)","    }","}"],"type":"codeListing"},{"type":"paragraph","inlineContent":[{"type":"text","text":"This new initializer starts by calculating an appropriate origin point based on"},{"type":"text","text":" "},{"type":"text","text":"the provided "},{"code":"center","type":"codeVoice"},{"text":" point and ","type":"text"},{"type":"codeVoice","code":"size"},{"type":"text","text":" value."},{"type":"text","text":" "},{"text":"The initializer then calls the structure’s automatic memberwise initializer","type":"text"},{"type":"text","text":" "},{"code":"init(origin:size:)","type":"codeVoice"},{"text":", which stores the new origin and size values","type":"text"},{"text":" ","type":"text"},{"text":"in the appropriate properties:","type":"text"}]},{"syntax":"swift","type":"codeListing","code":["let centerRect = Rect(center: Point(x: 4.0, y: 4.0),","    size: Size(width: 3.0, height: 3.0))","\/\/ centerRect's origin is (2.5, 2.5) and its size is (3.0, 3.0)"]},{"content":[{"inlineContent":[{"type":"text","text":"If you provide a new initializer with an extension,"},{"type":"text","text":" "},{"text":"you are still responsible for making sure that each instance is fully initialized","type":"text"},{"type":"text","text":" "},{"text":"once the initializer completes.","type":"text"}],"type":"paragraph"}],"style":"note","type":"aside","name":"Note"},{"type":"heading","level":2,"anchor":"M%C3%A9todos","text":"Métodos"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Extensions can add new instance methods and type methods to existing types."},{"type":"text","text":" "},{"type":"text","text":"The following example adds a new instance method called "},{"code":"repetitions","type":"codeVoice"},{"type":"text","text":" to the "},{"code":"Int","type":"codeVoice"},{"text":" type:","type":"text"}]},{"syntax":"swift","type":"codeListing","code":["extension Int {","    func repetitions(task: () -> Void) {","        for _ in 0..<self {","            task()","        }","    }","}"]},{"inlineContent":[{"text":"The ","type":"text"},{"type":"codeVoice","code":"repetitions(task:)"},{"type":"text","text":" method takes a single argument of type "},{"code":"() -> Void","type":"codeVoice"},{"text":",","type":"text"},{"type":"text","text":" "},{"type":"text","text":"which indicates a function that has no parameters and doesn’t return a value."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"text":"After defining this extension,","type":"text"},{"type":"text","text":" "},{"type":"text","text":"you can call the "},{"type":"codeVoice","code":"repetitions(task:)"},{"text":" method on any integer","type":"text"},{"type":"text","text":" "},{"text":"to perform a task that many number of times:","type":"text"}]},{"code":["3.repetitions {","    print(\"Hello!\")","}","\/\/ Hello!","\/\/ Hello!","\/\/ Hello!"],"syntax":"swift","type":"codeListing"},{"level":3,"anchor":"M%C3%A9todos-de-instancia-modificadores","text":"Métodos de instancia modificadores","type":"heading"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Instance methods added with an extension can also modify (or "},{"type":"emphasis","inlineContent":[{"text":"mutate","type":"text"}]},{"text":") the instance itself.","type":"text"},{"type":"text","text":" "},{"text":"Structure and enumeration methods that modify ","type":"text"},{"code":"self","type":"codeVoice"},{"type":"text","text":" or its properties"},{"text":" ","type":"text"},{"text":"must mark the instance method as ","type":"text"},{"type":"codeVoice","code":"mutating"},{"type":"text","text":","},{"type":"text","text":" "},{"text":"just like mutating methods from an original implementation.","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The example below adds a new mutating method called "},{"type":"codeVoice","code":"square"},{"type":"text","text":" to Swift’s "},{"type":"codeVoice","code":"Int"},{"text":" type,","type":"text"},{"type":"text","text":" "},{"text":"which squares the original value:","type":"text"}]},{"code":["extension Int {","    mutating func square() {","        self = self * self","    }","}","var someInt = 3","someInt.square()","\/\/ someInt is now 9"],"type":"codeListing","syntax":"swift"},{"anchor":"Sub%C3%ADndices","text":"Subíndices","level":2,"type":"heading"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Extensions can add new subscripts to an existing type."},{"text":" ","type":"text"},{"type":"text","text":"This example adds an integer subscript to Swift’s built-in "},{"type":"codeVoice","code":"Int"},{"text":" type.","type":"text"},{"text":" ","type":"text"},{"text":"This subscript ","type":"text"},{"type":"codeVoice","code":"[n]"},{"text":" returns the decimal digit ","type":"text"},{"code":"n","type":"codeVoice"},{"type":"text","text":" places in"},{"type":"text","text":" "},{"type":"text","text":"from the right of the number:"}]},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"123456789[0]"},{"text":" returns ","type":"text"},{"code":"9","type":"codeVoice"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"code":"123456789[1]","type":"codeVoice"},{"text":" returns ","type":"text"},{"code":"8","type":"codeVoice"}]}]}],"type":"unorderedList"},{"inlineContent":[{"text":"…and so on:","type":"text"}],"type":"paragraph"},{"syntax":"swift","code":["extension Int {","    subscript(digitIndex: Int) -> Int {","        var decimalBase = 1","        for _ in 0..<digitIndex {","            decimalBase *= 10","        }","        return (self \/ decimalBase) % 10","    }","}","746381295[0]","\/\/ returns 5","746381295[1]","\/\/ returns 9","746381295[2]","\/\/ returns 2","746381295[8]","\/\/ returns 7"],"type":"codeListing"},{"type":"paragraph","inlineContent":[{"type":"text","text":"If the "},{"code":"Int","type":"codeVoice"},{"type":"text","text":" value doesn’t have enough digits for the requested index,"},{"text":" ","type":"text"},{"type":"text","text":"the subscript implementation returns "},{"code":"0","type":"codeVoice"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"as if the number had been padded with zeros to the left:"}]},{"syntax":"swift","code":["746381295[9]","\/\/ returns 0, as if you had requested:","0746381295[9]"],"type":"codeListing"},{"anchor":"Tipos-anidados","level":2,"text":"Tipos anidados","type":"heading"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Extensions can add new nested types to existing classes, structures, and enumerations:"}]},{"type":"codeListing","syntax":"swift","code":["extension Int {","    enum Kind {","        case negative, zero, positive","    }","    var kind: Kind {","        switch self {","        case 0:","            return .zero","        case let x where x > 0:","            return .positive","        default:","            return .negative","        }","    }","}"]},{"type":"paragraph","inlineContent":[{"text":"This example adds a new nested enumeration to ","type":"text"},{"code":"Int","type":"codeVoice"},{"text":".","type":"text"},{"text":" ","type":"text"},{"text":"This enumeration, called ","type":"text"},{"type":"codeVoice","code":"Kind"},{"type":"text","text":","},{"type":"text","text":" "},{"text":"expresses the kind of number that a particular integer represents.","type":"text"},{"type":"text","text":" "},{"text":"Specifically, it expresses whether the number is","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"negative, zero, or positive."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"This example also adds a new computed instance property to "},{"type":"codeVoice","code":"Int"},{"type":"text","text":","},{"type":"text","text":" "},{"text":"called ","type":"text"},{"type":"codeVoice","code":"kind"},{"type":"text","text":","},{"text":" ","type":"text"},{"text":"which returns the appropriate ","type":"text"},{"code":"Kind","type":"codeVoice"},{"type":"text","text":" enumeration case for that integer."}]},{"inlineContent":[{"text":"The nested enumeration can now be used with any ","type":"text"},{"code":"Int","type":"codeVoice"},{"type":"text","text":" value:"}],"type":"paragraph"},{"type":"codeListing","code":["func printIntegerKinds(_ numbers: [Int]) {","    for number in numbers {","        switch number.kind {","        case .negative:","            print(\"- \", terminator: \"\")","        case .zero:","            print(\"0 \", terminator: \"\")","        case .positive:","            print(\"+ \", terminator: \"\")","        }","    }","    print(\"\")","}","printIntegerKinds([3, 19, -27, 0, -6, 0, 7])","\/\/ Prints \"+ + - 0 - 0 + \""],"syntax":"swift"},{"inlineContent":[{"type":"text","text":"This function, "},{"code":"printIntegerKinds(_:)","type":"codeVoice"},{"type":"text","text":","},{"text":" ","type":"text"},{"text":"takes an input array of ","type":"text"},{"type":"codeVoice","code":"Int"},{"type":"text","text":" values and iterates over those values in turn."},{"text":" ","type":"text"},{"type":"text","text":"For each integer in the array,"},{"text":" ","type":"text"},{"type":"text","text":"the function considers the "},{"code":"kind","type":"codeVoice"},{"type":"text","text":" computed property for that integer,"},{"type":"text","text":" "},{"text":"and prints an appropriate description.","type":"text"}],"type":"paragraph"},{"style":"note","name":"Note","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":""},{"type":"codeVoice","code":"number.kind"},{"type":"text","text":" is already known to be of type "},{"type":"codeVoice","code":"Int.Kind"},{"type":"text","text":"."},{"type":"text","text":" "},{"text":"Because of this, all of the ","type":"text"},{"type":"codeVoice","code":"Int.Kind"},{"type":"text","text":" case values"},{"type":"text","text":" "},{"type":"text","text":"can be written in shorthand form inside the "},{"code":"switch","type":"codeVoice"},{"type":"text","text":" statement,"},{"text":" ","type":"text"},{"type":"text","text":"such as "},{"code":".negative","type":"codeVoice"},{"text":" rather than ","type":"text"},{"code":"Int.Kind.negative","type":"codeVoice"},{"type":"text","text":"."}]}],"type":"aside"},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":""}]},{"inlineContent":[{"text":"Esta documentación contiene información preliminar sobre una API o tecnología en desarrollo. Esta información está sujeta a cambios, y todo software implementado en conformidad con esta documentación debe ser testeado con el software final del sistema operativo.","type":"text"}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Conoce más acerca del uso del "},{"isActive":true,"identifier":"https:\/\/developer.apple.com\/es\/support\/beta-software\/","type":"reference"},{"text":".","type":"text"}]}],"style":"note","name":"Software Beta","type":"aside"}],"kind":"content"}],"hierarchy":{"paths":[["doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language"]]},"references":{"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Initialization#Delegaci%C3%B3n-de-inicializadores-para-tipos-de-valor":{"identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Initialization#Delegaci%C3%B3n-de-inicializadores-para-tipos-de-valor","type":"topic","url":"\/documentation\/the-swift-programming-language\/initialization#Delegaci%C3%B3n-de-inicializadores-para-tipos-de-valor","abstract":[],"kind":"section","title":"Delegación de inicializadores para tipos de valor"},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language":{"role":"collection","type":"topic","url":"\/documentation\/the-swift-programming-language","abstract":[],"title":"The Swift Programming Language (6)","identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language","kind":"article"},"https://developer.apple.com/es/support/beta-software/":{"identifier":"https:\/\/developer.apple.com\/es\/support\/beta-software\/","type":"link","url":"https:\/\/developer.apple.com\/es\/support\/beta-software\/","title":"software beta de Apple","titleInlineContent":[{"type":"text","text":"software beta de Apple"}]},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language/Initialization#Inicializadores-predeterminados":{"url":"\/documentation\/the-swift-programming-language\/initialization#Inicializadores-predeterminados","type":"topic","title":"Inicializadores predeterminados","kind":"section","identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Initialization#Inicializadores-predeterminados","abstract":[]}}}
>>>>>>> 2fa5d86d (yet one more fix attempt)
