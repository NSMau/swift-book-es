<<<<<<< HEAD
{"metadata":{"title":"Patrones"},"sections":[],"hierarchy":{"paths":[["doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language"]]},"abstract":[{"text":"Match and destructure values.","type":"text"}],"kind":"article","schemaVersion":{"minor":3,"major":0,"patch":0},"primaryContentSections":[{"content":[{"inlineContent":[{"text":"A ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"pattern","type":"text"}]},{"type":"text","text":" represents the structure of a single value"},{"text":" ","type":"text"},{"text":"or a composite value.","type":"text"},{"type":"text","text":" "},{"text":"For example, the structure of a tuple ","type":"text"},{"type":"codeVoice","code":"(1, 2)"},{"type":"text","text":" is a comma-separated list of two"},{"type":"text","text":" "},{"text":"elements. Because patterns represent the structure of a value rather than any","type":"text"},{"type":"text","text":" "},{"text":"one particular value, you can match them with a variety of values.","type":"text"},{"type":"text","text":" "},{"text":"For instance, the pattern ","type":"text"},{"code":"(x, y)","type":"codeVoice"},{"type":"text","text":" matches the tuple "},{"code":"(1, 2)","type":"codeVoice"},{"type":"text","text":" and any other"},{"type":"text","text":" "},{"type":"text","text":"two-element tuple. In addition to matching a pattern with a value,"},{"type":"text","text":" "},{"type":"text","text":"you can extract part or all of a composite value and bind each part"},{"text":" ","type":"text"},{"type":"text","text":"to a constant or variable name."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"text":"In Swift, there are two basic kinds of patterns:","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"those that successfully match any kind of value,"},{"type":"text","text":" "},{"type":"text","text":"and those that may fail to match a specified value at runtime."}]},{"type":"paragraph","inlineContent":[{"text":"The first kind of pattern is used for destructuring values","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"in simple variable, constant, and optional bindings."},{"type":"text","text":" "},{"type":"text","text":"These include wildcard patterns, identifier patterns,"},{"text":" ","type":"text"},{"text":"and any value binding or tuple patterns containing","type":"text"},{"type":"text","text":" "},{"text":"them. You can specify a type annotation for these patterns","type":"text"},{"type":"text","text":" "},{"type":"text","text":"to constrain them to match only values of a certain type."}]},{"inlineContent":[{"type":"text","text":"The second kind of pattern is used for full pattern matching,"},{"type":"text","text":" "},{"type":"text","text":"where the values you’re trying to match against may not be there at runtime."},{"text":" ","type":"text"},{"type":"text","text":"These include enumeration case patterns, optional patterns, expression patterns,"},{"text":" ","type":"text"},{"type":"text","text":"and type-casting patterns. You use these patterns in a case label of a "},{"type":"codeVoice","code":"switch"},{"type":"text","text":" "},{"text":"statement, a ","type":"text"},{"type":"codeVoice","code":"catch"},{"type":"text","text":" clause of a "},{"type":"codeVoice","code":"do"},{"type":"text","text":" statement,"},{"text":" ","type":"text"},{"type":"text","text":"or in the case condition of an "},{"code":"if","type":"codeVoice"},{"text":", ","type":"text"},{"code":"while","type":"codeVoice"},{"text":",","type":"text"},{"text":" ","type":"text"},{"code":"guard","type":"codeVoice"},{"text":", or ","type":"text"},{"type":"codeVoice","code":"for"},{"type":"text","text":"-"},{"code":"in","type":"codeVoice"},{"type":"text","text":" statement."}],"type":"paragraph"},{"name":"Grammar of a pattern","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":""}]},{"type":"paragraph","inlineContent":[{"type":"emphasis","inlineContent":[{"text":"pattern","type":"text"}]},{"text":" → ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"wildcard-pattern","type":"text"}]},{"text":" ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"type-annotation","type":"text"}]},{"type":"emphasis","inlineContent":[{"type":"text","text":"?"}]}]},{"inlineContent":[{"type":"emphasis","inlineContent":[{"type":"text","text":"pattern"}]},{"text":" → ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"identifier-pattern","type":"text"}]},{"text":" ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"type-annotation","type":"text"}]},{"inlineContent":[{"text":"?","type":"text"}],"type":"emphasis"}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"emphasis","inlineContent":[{"type":"text","text":"pattern"}]},{"text":" → ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"value-binding-pattern","type":"text"}]}]},{"type":"paragraph","inlineContent":[{"inlineContent":[{"type":"text","text":"pattern"}],"type":"emphasis"},{"type":"text","text":" → "},{"type":"emphasis","inlineContent":[{"type":"text","text":"tuple-pattern"}]},{"text":" ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"type-annotation","type":"text"}]},{"type":"emphasis","inlineContent":[{"text":"?","type":"text"}]}]},{"type":"paragraph","inlineContent":[{"type":"emphasis","inlineContent":[{"text":"pattern","type":"text"}]},{"text":" → ","type":"text"},{"inlineContent":[{"type":"text","text":"enum-case-pattern"}],"type":"emphasis"}]},{"inlineContent":[{"inlineContent":[{"type":"text","text":"pattern"}],"type":"emphasis"},{"type":"text","text":" → "},{"inlineContent":[{"type":"text","text":"optional-pattern"}],"type":"emphasis"}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"inlineContent":[{"type":"text","text":"pattern"}],"type":"emphasis"},{"type":"text","text":" → "},{"inlineContent":[{"type":"text","text":"type-casting-pattern"}],"type":"emphasis"}]},{"type":"paragraph","inlineContent":[{"inlineContent":[{"type":"text","text":"pattern"}],"type":"emphasis"},{"type":"text","text":" → "},{"inlineContent":[{"type":"text","text":"expression-pattern"}],"type":"emphasis"}]}],"style":"note","type":"aside"},{"level":2,"text":"Patrón Comodín","type":"heading","anchor":"Patr%C3%B3n-Comod%C3%ADn"},{"type":"paragraph","inlineContent":[{"text":"A ","type":"text"},{"inlineContent":[{"text":"wildcard pattern","type":"text"}],"type":"emphasis"},{"text":" matches and ignores any value and consists of an underscore","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"("},{"code":"_","type":"codeVoice"},{"type":"text","text":"). Use a wildcard pattern when you don’t care about the values being"},{"type":"text","text":" "},{"type":"text","text":"matched against. For example, the following code iterates through the closed range "},{"code":"1...3","type":"codeVoice"},{"type":"text","text":","},{"text":" ","type":"text"},{"type":"text","text":"ignoring the current value of the range on each iteration of the loop:"}]},{"code":["for _ in 1...3 {","    \/\/ Do something three times.","}"],"type":"codeListing","syntax":"swift"},{"type":"aside","style":"note","name":"Grammar of a wildcard pattern","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":""}]},{"type":"paragraph","inlineContent":[{"inlineContent":[{"text":"wildcard-pattern","type":"text"}],"type":"emphasis"},{"type":"text","text":" → "},{"inlineContent":[{"code":"_","type":"codeVoice"}],"type":"strong"}]}]},{"text":"Patrón Identificador","anchor":"Patr%C3%B3n-Identificador","level":2,"type":"heading"},{"type":"paragraph","inlineContent":[{"type":"text","text":"An "},{"inlineContent":[{"type":"text","text":"identifier pattern"}],"type":"emphasis"},{"type":"text","text":" matches any value and binds the matched value to a"},{"type":"text","text":" "},{"text":"variable or constant name.","type":"text"},{"type":"text","text":" "},{"text":"For example, in the following constant declaration, ","type":"text"},{"code":"someValue","type":"codeVoice"},{"type":"text","text":" is an identifier pattern"},{"text":" ","type":"text"},{"type":"text","text":"that matches the value "},{"type":"codeVoice","code":"42"},{"text":" of type ","type":"text"},{"type":"codeVoice","code":"Int"},{"text":":","type":"text"}]},{"type":"codeListing","code":["let someValue = 42"],"syntax":"swift"},{"inlineContent":[{"text":"When the match succeeds, the value ","type":"text"},{"type":"codeVoice","code":"42"},{"text":" is bound (assigned)","type":"text"},{"type":"text","text":" "},{"type":"text","text":"to the constant name "},{"code":"someValue","type":"codeVoice"},{"text":".","type":"text"}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"When the pattern on the left-hand side of a variable or constant declaration"},{"type":"text","text":" "},{"type":"text","text":"is an identifier pattern,"},{"text":" ","type":"text"},{"type":"text","text":"the identifier pattern is implicitly a subpattern of a value-binding pattern."}]},{"content":[{"inlineContent":[{"type":"text","text":""}],"type":"paragraph"},{"inlineContent":[{"inlineContent":[{"text":"identifier-pattern","type":"text"}],"type":"emphasis"},{"text":" → ","type":"text"},{"inlineContent":[{"text":"identifier","type":"text"}],"type":"emphasis"}],"type":"paragraph"}],"type":"aside","style":"note","name":"Grammar of an identifier pattern"},{"text":"Patrón de Vinculación de Valores","anchor":"Patr%C3%B3n-de-Vinculaci%C3%B3n-de-Valores","type":"heading","level":2},{"inlineContent":[{"type":"text","text":"A "},{"type":"emphasis","inlineContent":[{"text":"value-binding pattern","type":"text"}]},{"type":"text","text":" binds matched values to variable or constant names."},{"type":"text","text":" "},{"text":"Value-binding patterns that bind a matched value to the name of a constant","type":"text"},{"text":" ","type":"text"},{"text":"begin with the ","type":"text"},{"code":"let","type":"codeVoice"},{"type":"text","text":" keyword; those that bind to the name of variable"},{"type":"text","text":" "},{"type":"text","text":"begin with the "},{"code":"var","type":"codeVoice"},{"type":"text","text":" keyword."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Identifiers patterns within a value-binding pattern"},{"type":"text","text":" "},{"text":"bind new named variables or constants to their matching values. For example,","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"you can decompose the elements of a tuple and bind the value of each element to a"},{"type":"text","text":" "},{"text":"corresponding identifier pattern.","type":"text"}]},{"code":["let point = (3, 2)","switch point {","\/\/ Bind x and y to the elements of point.","case let (x, y):","    print(\"The point is at (\\(x), \\(y)).\")","}","\/\/ Prints \"The point is at (3, 2).\""],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"type":"text","text":"In the example above, "},{"type":"codeVoice","code":"let"},{"type":"text","text":" distributes to each identifier pattern in the"},{"text":" ","type":"text"},{"text":"tuple pattern ","type":"text"},{"type":"codeVoice","code":"(x, y)"},{"text":". Because of this behavior, the ","type":"text"},{"code":"switch","type":"codeVoice"},{"text":" cases","type":"text"},{"type":"text","text":" "},{"type":"codeVoice","code":"case let (x, y):"},{"type":"text","text":" and "},{"code":"case (let x, let y):","type":"codeVoice"},{"type":"text","text":" match the same values."}],"type":"paragraph"},{"style":"note","content":[{"inlineContent":[{"type":"text","text":""}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"emphasis","inlineContent":[{"text":"value-binding-pattern","type":"text"}]},{"type":"text","text":" → "},{"inlineContent":[{"type":"codeVoice","code":"var"}],"type":"strong"},{"text":" ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"pattern","type":"text"}]},{"text":" | ","type":"text"},{"type":"strong","inlineContent":[{"type":"codeVoice","code":"let"}]},{"type":"text","text":" "},{"type":"emphasis","inlineContent":[{"text":"pattern","type":"text"}]}]}],"name":"Grammar of a value-binding pattern","type":"aside"},{"level":2,"anchor":"Patrones-Tupla","text":"Patrones Tupla","type":"heading"},{"inlineContent":[{"type":"text","text":"A "},{"type":"emphasis","inlineContent":[{"text":"tuple pattern","type":"text"}]},{"text":" is a comma-separated list of zero or more patterns, enclosed in","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"parentheses. Tuple patterns match values of corresponding tuple types."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"You can constrain a tuple pattern to match certain kinds of tuple types"},{"text":" ","type":"text"},{"text":"by using type annotations.","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"For example, the tuple pattern "},{"type":"codeVoice","code":"(x, y): (Int, Int)"},{"text":" in the constant declaration","type":"text"},{"text":" ","type":"text"},{"code":"let (x, y): (Int, Int) = (1, 2)","type":"codeVoice"},{"text":" matches only tuple types in which","type":"text"},{"type":"text","text":" "},{"text":"both elements are of type ","type":"text"},{"type":"codeVoice","code":"Int"},{"type":"text","text":"."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"When a tuple pattern is used as the pattern in a "},{"type":"codeVoice","code":"for"},{"text":"-","type":"text"},{"type":"codeVoice","code":"in"},{"text":" statement","type":"text"},{"type":"text","text":" "},{"text":"or in a variable or constant declaration, it can contain only wildcard patterns,","type":"text"},{"type":"text","text":" "},{"text":"identifier patterns, optional patterns, or other tuple patterns that contain those.","type":"text"},{"text":" ","type":"text"},{"text":"For example,","type":"text"},{"type":"text","text":" "},{"text":"the following code isn’t valid because the element ","type":"text"},{"type":"codeVoice","code":"0"},{"type":"text","text":" in the tuple pattern "},{"code":"(x, 0)","type":"codeVoice"},{"type":"text","text":" is"},{"text":" ","type":"text"},{"type":"text","text":"an expression pattern:"}]},{"syntax":"swift","type":"codeListing","code":["let points = [(0, 0), (1, 0), (1, 1), (2, 0), (2, 1)]","\/\/ This code isn't valid.","for (x, 0) in points {","    \/* ... *\/","}"]},{"inlineContent":[{"text":"The parentheses around a tuple pattern that contains a single element have no effect.","type":"text"},{"text":" ","type":"text"},{"text":"The pattern matches values of that single element’s type. For example, the following are","type":"text"},{"type":"text","text":" "},{"type":"text","text":"equivalent:"}],"type":"paragraph"},{"type":"codeListing","syntax":"swift","code":["let a = 2        \/\/ a: Int = 2","let (a) = 2      \/\/ a: Int = 2","let (a): Int = 2 \/\/ a: Int = 2"]},{"type":"aside","style":"note","name":"Grammar of a tuple pattern","content":[{"inlineContent":[{"type":"text","text":""}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"emphasis","inlineContent":[{"text":"tuple-pattern","type":"text"}]},{"type":"text","text":" → "},{"inlineContent":[{"type":"codeVoice","code":"("}],"type":"strong"},{"text":" ","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"tuple-pattern-element-list"}]},{"inlineContent":[{"type":"text","text":"?"}],"type":"emphasis"},{"type":"text","text":" "},{"type":"strong","inlineContent":[{"code":")","type":"codeVoice"}]}]},{"inlineContent":[{"type":"emphasis","inlineContent":[{"type":"text","text":"tuple-pattern-element-list"}]},{"text":" → ","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"tuple-pattern-element"}]},{"text":" | ","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"tuple-pattern-element"}]},{"type":"text","text":" "},{"type":"strong","inlineContent":[{"code":",","type":"codeVoice"}]},{"text":" ","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"tuple-pattern-element-list"}]}],"type":"paragraph"},{"inlineContent":[{"type":"emphasis","inlineContent":[{"text":"tuple-pattern-element","type":"text"}]},{"text":" → ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"pattern","type":"text"}]},{"text":" | ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"identifier","type":"text"}]},{"text":" ","type":"text"},{"inlineContent":[{"type":"codeVoice","code":":"}],"type":"strong"},{"text":" ","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"pattern"}]}],"type":"paragraph"}]},{"level":2,"anchor":"Patrones-de-Casos-de-Enumeraci%C3%B3n","type":"heading","text":"Patrones de Casos de Enumeración"},{"inlineContent":[{"type":"text","text":"An "},{"inlineContent":[{"text":"enumeration case pattern","type":"text"}],"type":"emphasis"},{"type":"text","text":" matches a case of an existing enumeration type."},{"text":" ","type":"text"},{"type":"text","text":"Enumeration case patterns appear in "},{"type":"codeVoice","code":"switch"},{"text":" statement","type":"text"},{"type":"text","text":" "},{"text":"case labels and in the case conditions of ","type":"text"},{"type":"codeVoice","code":"if"},{"text":", ","type":"text"},{"type":"codeVoice","code":"while"},{"text":", ","type":"text"},{"type":"codeVoice","code":"guard"},{"text":", and ","type":"text"},{"code":"for","type":"codeVoice"},{"type":"text","text":"-"},{"type":"codeVoice","code":"in"},{"type":"text","text":" "},{"type":"text","text":"statements."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"If the enumeration case you’re trying to match has any associated values,"},{"type":"text","text":" "},{"type":"text","text":"the corresponding enumeration case pattern must specify a tuple pattern that contains"},{"type":"text","text":" "},{"text":"one element for each associated value. For an example that uses a ","type":"text"},{"code":"switch","type":"codeVoice"},{"type":"text","text":" statement"},{"text":" ","type":"text"},{"type":"text","text":"to match enumeration cases containing associated values,"},{"text":" ","type":"text"},{"type":"text","text":"see "},{"text":"doc:Enumerations#Valores-Asociados","type":"text"},{"type":"text","text":"."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"An enumeration case pattern also matches"},{"text":" ","type":"text"},{"type":"text","text":"values of that case wrapped in an optional."},{"text":" ","type":"text"},{"type":"text","text":"This simplified syntax lets you omit an optional pattern."},{"type":"text","text":" "},{"type":"text","text":"Note that,"},{"type":"text","text":" "},{"type":"text","text":"because "},{"type":"codeVoice","code":"Optional"},{"text":" is implemented as an enumeration,","type":"text"},{"text":" ","type":"text"},{"type":"codeVoice","code":".none"},{"text":" and ","type":"text"},{"code":".some","type":"codeVoice"},{"text":" can appear","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"in the same switch as the cases of the enumeration type."}]},{"type":"codeListing","syntax":"swift","code":["enum SomeEnum { case left, right }","let x: SomeEnum? = .left","switch x {","case .left:","    print(\"Turn left\")","case .right:","    print(\"Turn right\")","case nil:","    print(\"Keep going straight\")","}","\/\/ Prints \"Turn left\""]},{"style":"note","type":"aside","content":[{"inlineContent":[{"text":"","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"emphasis","inlineContent":[{"type":"text","text":"enum-case-pattern"}]},{"type":"text","text":" → "},{"inlineContent":[{"type":"text","text":"type-identifier"}],"type":"emphasis"},{"inlineContent":[{"text":"?","type":"text"}],"type":"emphasis"},{"type":"text","text":" "},{"type":"strong","inlineContent":[{"code":".","type":"codeVoice"}]},{"type":"text","text":" "},{"inlineContent":[{"type":"text","text":"enum-case-name"}],"type":"emphasis"},{"text":" ","type":"text"},{"inlineContent":[{"type":"text","text":"tuple-pattern"}],"type":"emphasis"},{"type":"emphasis","inlineContent":[{"type":"text","text":"?"}]}],"type":"paragraph"}],"name":"Grammar of an enumeration case pattern"},{"text":"Patrón Opcional","type":"heading","level":2,"anchor":"Patr%C3%B3n-Opcional"},{"inlineContent":[{"text":"An ","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"optional pattern"}]},{"type":"text","text":" matches values wrapped in a "},{"code":"some(Wrapped)","type":"codeVoice"},{"text":" case","type":"text"},{"type":"text","text":" "},{"type":"text","text":"of an "},{"code":"Optional<Wrapped>","type":"codeVoice"},{"text":" enumeration.","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"Optional patterns consist of an identifier pattern followed immediately by a question mark"},{"text":" ","type":"text"},{"text":"and appear in the same places as enumeration case patterns.","type":"text"}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Because optional patterns are syntactic sugar for "},{"type":"codeVoice","code":"Optional"},{"type":"text","text":" "},{"type":"text","text":"enumeration case patterns,"},{"type":"text","text":" "},{"type":"text","text":"the following are equivalent:"}]},{"type":"codeListing","syntax":"swift","code":["let someOptional: Int? = 42","\/\/ Match using an enumeration case pattern.","if case .some(let x) = someOptional {","    print(x)","}","","\/\/ Match using an optional pattern.","if case let x? = someOptional {","    print(x)","}"]},{"inlineContent":[{"type":"text","text":"The optional pattern provides a convenient way to"},{"type":"text","text":" "},{"type":"text","text":"iterate over an array of optional values in a "},{"type":"codeVoice","code":"for"},{"type":"text","text":"-"},{"code":"in","type":"codeVoice"},{"type":"text","text":" statement,"},{"text":" ","type":"text"},{"type":"text","text":"executing the body of the loop only for non-"},{"code":"nil","type":"codeVoice"},{"text":" elements.","type":"text"}],"type":"paragraph"},{"type":"codeListing","syntax":"swift","code":["let arrayOfOptionalInts: [Int?] = [nil, 2, 3, nil, 5]","\/\/ Match only non-nil values.","for case let number? in arrayOfOptionalInts {","    print(\"Found a \\(number)\")","}","\/\/ Found a 2","\/\/ Found a 3","\/\/ Found a 5"]},{"type":"aside","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":""}]},{"inlineContent":[{"type":"emphasis","inlineContent":[{"type":"text","text":"optional-pattern"}]},{"text":" → ","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"identifier-pattern"}]},{"type":"text","text":" "},{"inlineContent":[{"type":"codeVoice","code":"?"}],"type":"strong"}],"type":"paragraph"}],"name":"Grammar of an optional pattern","style":"note"},{"level":2,"type":"heading","text":"Patrones de Conversión de Tipos","anchor":"Patrones-de-Conversi%C3%B3n-de-Tipos"},{"inlineContent":[{"text":"There are two type-casting patterns, the ","type":"text"},{"code":"is","type":"codeVoice"},{"type":"text","text":" pattern and the "},{"type":"codeVoice","code":"as"},{"text":" pattern.","type":"text"},{"text":" ","type":"text"},{"text":"The ","type":"text"},{"type":"codeVoice","code":"is"},{"text":" pattern appears only in ","type":"text"},{"code":"switch","type":"codeVoice"},{"text":" statement","type":"text"},{"type":"text","text":" "},{"type":"text","text":"case labels. The "},{"type":"codeVoice","code":"is"},{"type":"text","text":" and "},{"type":"codeVoice","code":"as"},{"text":" patterns have the following form:","type":"text"}],"type":"paragraph"},{"code":["is <#type#>","<#pattern#> as <#type#>"],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"text":"The ","type":"text"},{"code":"is","type":"codeVoice"},{"type":"text","text":" pattern matches a value if the type of that value at runtime is the same as"},{"text":" ","type":"text"},{"text":"the type specified in the right-hand side of the ","type":"text"},{"type":"codeVoice","code":"is"},{"type":"text","text":" pattern — or a subclass of that type."},{"text":" ","type":"text"},{"text":"The ","type":"text"},{"type":"codeVoice","code":"is"},{"text":" pattern behaves like the ","type":"text"},{"type":"codeVoice","code":"is"},{"type":"text","text":" operator in that they both perform a type cast"},{"type":"text","text":" "},{"type":"text","text":"but discard the returned type."}],"type":"paragraph"},{"inlineContent":[{"text":"The ","type":"text"},{"code":"as","type":"codeVoice"},{"type":"text","text":" pattern matches a value if the type of that value at runtime is the same as"},{"text":" ","type":"text"},{"text":"the type specified in the right-hand side of the ","type":"text"},{"code":"as","type":"codeVoice"},{"text":" pattern — or a subclass of that type.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"If the match succeeds,"},{"text":" ","type":"text"},{"type":"text","text":"the type of the matched value is cast to the "},{"inlineContent":[{"text":"pattern","type":"text"}],"type":"emphasis"},{"text":" specified in the right-hand side","type":"text"},{"type":"text","text":" "},{"text":"of the ","type":"text"},{"type":"codeVoice","code":"as"},{"type":"text","text":" pattern."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"For an example that uses a "},{"code":"switch","type":"codeVoice"},{"text":" statement","type":"text"},{"type":"text","text":" "},{"type":"text","text":"to match values with "},{"type":"codeVoice","code":"is"},{"type":"text","text":" and "},{"type":"codeVoice","code":"as"},{"type":"text","text":" patterns,"},{"text":" ","type":"text"},{"text":"see ","type":"text"},{"text":"doc:TypeCasting#Conversión-de-Tipos-Para-Any-y-AnyObject","type":"text"},{"type":"text","text":"."}]},{"style":"note","type":"aside","content":[{"type":"paragraph","inlineContent":[{"text":"","type":"text"}]},{"inlineContent":[{"type":"emphasis","inlineContent":[{"type":"text","text":"type-casting-pattern"}]},{"text":" → ","type":"text"},{"inlineContent":[{"text":"is-pattern","type":"text"}],"type":"emphasis"},{"type":"text","text":" | "},{"inlineContent":[{"text":"as-pattern","type":"text"}],"type":"emphasis"}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"inlineContent":[{"text":"is-pattern","type":"text"}],"type":"emphasis"},{"text":" → ","type":"text"},{"type":"strong","inlineContent":[{"type":"codeVoice","code":"is"}]},{"text":" ","type":"text"},{"inlineContent":[{"type":"text","text":"type"}],"type":"emphasis"}]},{"inlineContent":[{"inlineContent":[{"type":"text","text":"as-pattern"}],"type":"emphasis"},{"text":" → ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"pattern","type":"text"}]},{"type":"text","text":" "},{"type":"strong","inlineContent":[{"code":"as","type":"codeVoice"}]},{"text":" ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"type","type":"text"}]}],"type":"paragraph"}],"name":"Grammar of a type casting pattern"},{"type":"heading","anchor":"Patrones-Expresi%C3%B3n","level":2,"text":"Patrones Expresión"},{"type":"paragraph","inlineContent":[{"type":"text","text":"An "},{"inlineContent":[{"text":"expression pattern","type":"text"}],"type":"emphasis"},{"text":" represents the value of an expression.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"Expression patterns appear only in "},{"type":"codeVoice","code":"switch"},{"type":"text","text":" statement"},{"type":"text","text":" "},{"type":"text","text":"case labels."}]},{"inlineContent":[{"text":"The expression represented by the expression pattern","type":"text"},{"type":"text","text":" "},{"text":"is compared with the value of an input expression","type":"text"},{"type":"text","text":" "},{"type":"text","text":"using the Swift standard library "},{"type":"codeVoice","code":"~="},{"type":"text","text":" operator."},{"text":" ","type":"text"},{"text":"The matches succeeds","type":"text"},{"type":"text","text":" "},{"type":"text","text":"if the "},{"type":"codeVoice","code":"~="},{"text":" operator returns ","type":"text"},{"type":"codeVoice","code":"true"},{"text":". By default, the ","type":"text"},{"type":"codeVoice","code":"~="},{"type":"text","text":" operator compares"},{"type":"text","text":" "},{"type":"text","text":"two values of the same type using the "},{"type":"codeVoice","code":"=="},{"text":" operator.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"It can also match a value with a range of values,"},{"type":"text","text":" "},{"type":"text","text":"by checking whether the value is contained within the range,"},{"text":" ","type":"text"},{"text":"as the following example shows.","type":"text"}],"type":"paragraph"},{"code":["let point = (1, 2)","switch point {","case (0, 0):","    print(\"(0, 0) is at the origin.\")","case (-2...2, -2...2):","    print(\"(\\(point.0), \\(point.1)) is near the origin.\")","default:","    print(\"The point is at (\\(point.0), \\(point.1)).\")","}","\/\/ Prints \"(1, 2) is near the origin.\""],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"text":"You can overload the ","type":"text"},{"code":"~=","type":"codeVoice"},{"type":"text","text":" operator to provide custom expression matching behavior."},{"type":"text","text":" "},{"type":"text","text":"For example, you can rewrite the above example to compare the "},{"code":"point","type":"codeVoice"},{"type":"text","text":" expression"},{"type":"text","text":" "},{"type":"text","text":"with a string representations of points."}],"type":"paragraph"},{"code":["\/\/ Overload the ~= operator to match a string with an integer.","func ~= (pattern: String, value: Int) -> Bool {","    return pattern == \"\\(value)\"","}","switch point {","case (\"0\", \"0\"):","    print(\"(0, 0) is at the origin.\")","default:","    print(\"The point is at (\\(point.0), \\(point.1)).\")","}","\/\/ Prints \"The point is at (1, 2).\""],"syntax":"swift","type":"codeListing"},{"style":"note","type":"aside","content":[{"type":"paragraph","inlineContent":[{"text":"","type":"text"}]},{"type":"paragraph","inlineContent":[{"inlineContent":[{"text":"expression-pattern","type":"text"}],"type":"emphasis"},{"text":" → ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"expression","type":"text"}]}]}],"name":"Grammar of an expression pattern"},{"content":[{"inlineContent":[{"text":"","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"Esta documentación contiene información preliminar sobre una API o tecnología en desarrollo. Esta información está sujeta a cambios, y todo software implementado en conformidad con esta documentación debe ser testeado con el software final del sistema operativo."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"text":"Conoce más acerca del uso del ","type":"text"},{"isActive":true,"type":"reference","identifier":"https:\/\/developer.apple.com\/es\/support\/beta-software\/"},{"type":"text","text":"."}]}],"style":"note","name":"Software Beta","type":"aside"}],"kind":"content"}],"identifier":{"url":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Patterns","interfaceLanguage":"swift"},"references":{"https://developer.apple.com/es/support/beta-software/":{"identifier":"https:\/\/developer.apple.com\/es\/support\/beta-software\/","url":"https:\/\/developer.apple.com\/es\/support\/beta-software\/","title":"software beta de Apple","type":"link","titleInlineContent":[{"text":"software beta de Apple","type":"text"}]},"doc://org.swift.tspl/documentation/The-Swift-Programming-Language":{"role":"collection","kind":"article","identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language","url":"\/documentation\/the-swift-programming-language","title":"The Swift Programming Language (6)","abstract":[],"type":"topic"}}}
||||||| parent of 2fa5d86d (yet one more fix attempt)
{"abstract":[{"type":"text","text":"Match and destructure values."}],"hierarchy":{"paths":[["doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language"]]},"metadata":{"title":"Patrones"},"identifier":{"url":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Patterns","interfaceLanguage":"swift"},"kind":"article","sections":[],"schemaVersion":{"minor":3,"patch":0,"major":0},"primaryContentSections":[{"kind":"content","content":[{"inlineContent":[{"text":"A ","type":"text"},{"inlineContent":[{"text":"pattern","type":"text"}],"type":"emphasis"},{"text":" represents the structure of a single value","type":"text"},{"type":"text","text":" "},{"text":"or a composite value.","type":"text"},{"type":"text","text":" "},{"text":"For example, the structure of a tuple ","type":"text"},{"code":"(1, 2)","type":"codeVoice"},{"type":"text","text":" is a comma-separated list of two"},{"type":"text","text":" "},{"type":"text","text":"elements. Because patterns represent the structure of a value rather than any"},{"text":" ","type":"text"},{"text":"one particular value, you can match them with a variety of values.","type":"text"},{"type":"text","text":" "},{"text":"For instance, the pattern ","type":"text"},{"code":"(x, y)","type":"codeVoice"},{"text":" matches the tuple ","type":"text"},{"type":"codeVoice","code":"(1, 2)"},{"type":"text","text":" and any other"},{"type":"text","text":" "},{"type":"text","text":"two-element tuple. In addition to matching a pattern with a value,"},{"type":"text","text":" "},{"text":"you can extract part or all of a composite value and bind each part","type":"text"},{"text":" ","type":"text"},{"text":"to a constant or variable name.","type":"text"}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"In Swift, there are two basic kinds of patterns:"},{"type":"text","text":" "},{"text":"those that successfully match any kind of value,","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"and those that may fail to match a specified value at runtime."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The first kind of pattern is used for destructuring values"},{"type":"text","text":" "},{"type":"text","text":"in simple variable, constant, and optional bindings."},{"type":"text","text":" "},{"type":"text","text":"These include wildcard patterns, identifier patterns,"},{"text":" ","type":"text"},{"text":"and any value binding or tuple patterns containing","type":"text"},{"type":"text","text":" "},{"text":"them. You can specify a type annotation for these patterns","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"to constrain them to match only values of a certain type."}]},{"inlineContent":[{"type":"text","text":"The second kind of pattern is used for full pattern matching,"},{"type":"text","text":" "},{"text":"where the values you’re trying to match against may not be there at runtime.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"These include enumeration case patterns, optional patterns, expression patterns,"},{"text":" ","type":"text"},{"text":"and type-casting patterns. You use these patterns in a case label of a ","type":"text"},{"type":"codeVoice","code":"switch"},{"text":" ","type":"text"},{"type":"text","text":"statement, a "},{"type":"codeVoice","code":"catch"},{"type":"text","text":" clause of a "},{"code":"do","type":"codeVoice"},{"text":" statement,","type":"text"},{"text":" ","type":"text"},{"text":"or in the case condition of an ","type":"text"},{"type":"codeVoice","code":"if"},{"type":"text","text":", "},{"type":"codeVoice","code":"while"},{"type":"text","text":","},{"type":"text","text":" "},{"code":"guard","type":"codeVoice"},{"type":"text","text":", or "},{"code":"for","type":"codeVoice"},{"type":"text","text":"-"},{"type":"codeVoice","code":"in"},{"text":" statement.","type":"text"}],"type":"paragraph"},{"name":"Grammar of a pattern","content":[{"inlineContent":[{"type":"text","text":""}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"inlineContent":[{"text":"pattern","type":"text"}],"type":"emphasis"},{"type":"text","text":" → "},{"inlineContent":[{"type":"text","text":"wildcard-pattern"}],"type":"emphasis"},{"type":"text","text":" "},{"inlineContent":[{"text":"type-annotation","type":"text"}],"type":"emphasis"},{"type":"emphasis","inlineContent":[{"type":"text","text":"?"}]}]},{"type":"paragraph","inlineContent":[{"inlineContent":[{"type":"text","text":"pattern"}],"type":"emphasis"},{"type":"text","text":" → "},{"type":"emphasis","inlineContent":[{"type":"text","text":"identifier-pattern"}]},{"text":" ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"type-annotation","type":"text"}]},{"type":"emphasis","inlineContent":[{"text":"?","type":"text"}]}]},{"inlineContent":[{"inlineContent":[{"type":"text","text":"pattern"}],"type":"emphasis"},{"type":"text","text":" → "},{"inlineContent":[{"text":"value-binding-pattern","type":"text"}],"type":"emphasis"}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"emphasis","inlineContent":[{"type":"text","text":"pattern"}]},{"text":" → ","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"tuple-pattern"}]},{"text":" ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"type-annotation","type":"text"}]},{"type":"emphasis","inlineContent":[{"type":"text","text":"?"}]}]},{"type":"paragraph","inlineContent":[{"inlineContent":[{"text":"pattern","type":"text"}],"type":"emphasis"},{"text":" → ","type":"text"},{"inlineContent":[{"type":"text","text":"enum-case-pattern"}],"type":"emphasis"}]},{"type":"paragraph","inlineContent":[{"type":"emphasis","inlineContent":[{"text":"pattern","type":"text"}]},{"type":"text","text":" → "},{"inlineContent":[{"text":"optional-pattern","type":"text"}],"type":"emphasis"}]},{"inlineContent":[{"type":"emphasis","inlineContent":[{"type":"text","text":"pattern"}]},{"type":"text","text":" → "},{"inlineContent":[{"text":"type-casting-pattern","type":"text"}],"type":"emphasis"}],"type":"paragraph"},{"inlineContent":[{"type":"emphasis","inlineContent":[{"type":"text","text":"pattern"}]},{"text":" → ","type":"text"},{"inlineContent":[{"type":"text","text":"expression-pattern"}],"type":"emphasis"}],"type":"paragraph"}],"type":"aside","style":"note"},{"type":"heading","level":2,"text":"Patrón Comodín","anchor":"Patr%C3%B3n-Comod%C3%ADn"},{"type":"paragraph","inlineContent":[{"type":"text","text":"A "},{"type":"emphasis","inlineContent":[{"type":"text","text":"wildcard pattern"}]},{"type":"text","text":" matches and ignores any value and consists of an underscore"},{"type":"text","text":" "},{"text":"(","type":"text"},{"type":"codeVoice","code":"_"},{"type":"text","text":"). Use a wildcard pattern when you don’t care about the values being"},{"type":"text","text":" "},{"type":"text","text":"matched against. For example, the following code iterates through the closed range "},{"code":"1...3","type":"codeVoice"},{"type":"text","text":","},{"text":" ","type":"text"},{"type":"text","text":"ignoring the current value of the range on each iteration of the loop:"}]},{"type":"codeListing","syntax":"swift","code":["for _ in 1...3 {","    \/\/ Do something three times.","}"]},{"type":"aside","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":""}]},{"type":"paragraph","inlineContent":[{"inlineContent":[{"type":"text","text":"wildcard-pattern"}],"type":"emphasis"},{"text":" → ","type":"text"},{"type":"strong","inlineContent":[{"type":"codeVoice","code":"_"}]}]}],"name":"Grammar of a wildcard pattern","style":"note"},{"text":"Patrón Identificador","anchor":"Patr%C3%B3n-Identificador","type":"heading","level":2},{"type":"paragraph","inlineContent":[{"text":"An ","type":"text"},{"inlineContent":[{"text":"identifier pattern","type":"text"}],"type":"emphasis"},{"text":" matches any value and binds the matched value to a","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"variable or constant name."},{"text":" ","type":"text"},{"text":"For example, in the following constant declaration, ","type":"text"},{"type":"codeVoice","code":"someValue"},{"type":"text","text":" is an identifier pattern"},{"type":"text","text":" "},{"type":"text","text":"that matches the value "},{"type":"codeVoice","code":"42"},{"text":" of type ","type":"text"},{"type":"codeVoice","code":"Int"},{"type":"text","text":":"}]},{"code":["let someValue = 42"],"syntax":"swift","type":"codeListing"},{"inlineContent":[{"type":"text","text":"When the match succeeds, the value "},{"type":"codeVoice","code":"42"},{"text":" is bound (assigned)","type":"text"},{"type":"text","text":" "},{"type":"text","text":"to the constant name "},{"type":"codeVoice","code":"someValue"},{"text":".","type":"text"}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"text":"When the pattern on the left-hand side of a variable or constant declaration","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"is an identifier pattern,"},{"type":"text","text":" "},{"text":"the identifier pattern is implicitly a subpattern of a value-binding pattern.","type":"text"}]},{"style":"note","type":"aside","name":"Grammar of an identifier pattern","content":[{"inlineContent":[{"type":"text","text":""}],"type":"paragraph"},{"inlineContent":[{"type":"emphasis","inlineContent":[{"type":"text","text":"identifier-pattern"}]},{"type":"text","text":" → "},{"type":"emphasis","inlineContent":[{"text":"identifier","type":"text"}]}],"type":"paragraph"}]},{"text":"Patrón de Vinculación de Valores","anchor":"Patr%C3%B3n-de-Vinculaci%C3%B3n-de-Valores","level":2,"type":"heading"},{"type":"paragraph","inlineContent":[{"type":"text","text":"A "},{"inlineContent":[{"type":"text","text":"value-binding pattern"}],"type":"emphasis"},{"type":"text","text":" binds matched values to variable or constant names."},{"type":"text","text":" "},{"type":"text","text":"Value-binding patterns that bind a matched value to the name of a constant"},{"text":" ","type":"text"},{"text":"begin with the ","type":"text"},{"code":"let","type":"codeVoice"},{"type":"text","text":" keyword; those that bind to the name of variable"},{"type":"text","text":" "},{"text":"begin with the ","type":"text"},{"type":"codeVoice","code":"var"},{"type":"text","text":" keyword."}]},{"inlineContent":[{"type":"text","text":"Identifiers patterns within a value-binding pattern"},{"type":"text","text":" "},{"type":"text","text":"bind new named variables or constants to their matching values. For example,"},{"type":"text","text":" "},{"text":"you can decompose the elements of a tuple and bind the value of each element to a","type":"text"},{"type":"text","text":" "},{"text":"corresponding identifier pattern.","type":"text"}],"type":"paragraph"},{"syntax":"swift","code":["let point = (3, 2)","switch point {","\/\/ Bind x and y to the elements of point.","case let (x, y):","    print(\"The point is at (\\(x), \\(y)).\")","}","\/\/ Prints \"The point is at (3, 2).\""],"type":"codeListing"},{"inlineContent":[{"type":"text","text":"In the example above, "},{"code":"let","type":"codeVoice"},{"text":" distributes to each identifier pattern in the","type":"text"},{"type":"text","text":" "},{"text":"tuple pattern ","type":"text"},{"type":"codeVoice","code":"(x, y)"},{"type":"text","text":". Because of this behavior, the "},{"type":"codeVoice","code":"switch"},{"text":" cases","type":"text"},{"type":"text","text":" "},{"type":"codeVoice","code":"case let (x, y):"},{"type":"text","text":" and "},{"type":"codeVoice","code":"case (let x, let y):"},{"text":" match the same values.","type":"text"}],"type":"paragraph"},{"name":"Grammar of a value-binding pattern","content":[{"inlineContent":[{"text":"","type":"text"}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"inlineContent":[{"text":"value-binding-pattern","type":"text"}],"type":"emphasis"},{"type":"text","text":" → "},{"type":"strong","inlineContent":[{"type":"codeVoice","code":"var"}]},{"type":"text","text":" "},{"inlineContent":[{"text":"pattern","type":"text"}],"type":"emphasis"},{"text":" | ","type":"text"},{"inlineContent":[{"type":"codeVoice","code":"let"}],"type":"strong"},{"text":" ","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"pattern"}]}]}],"style":"note","type":"aside"},{"text":"Patrones Tupla","type":"heading","level":2,"anchor":"Patrones-Tupla"},{"type":"paragraph","inlineContent":[{"type":"text","text":"A "},{"type":"emphasis","inlineContent":[{"text":"tuple pattern","type":"text"}]},{"type":"text","text":" is a comma-separated list of zero or more patterns, enclosed in"},{"type":"text","text":" "},{"type":"text","text":"parentheses. Tuple patterns match values of corresponding tuple types."}]},{"inlineContent":[{"text":"You can constrain a tuple pattern to match certain kinds of tuple types","type":"text"},{"text":" ","type":"text"},{"text":"by using type annotations.","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"For example, the tuple pattern "},{"type":"codeVoice","code":"(x, y): (Int, Int)"},{"text":" in the constant declaration","type":"text"},{"text":" ","type":"text"},{"code":"let (x, y): (Int, Int) = (1, 2)","type":"codeVoice"},{"type":"text","text":" matches only tuple types in which"},{"text":" ","type":"text"},{"text":"both elements are of type ","type":"text"},{"type":"codeVoice","code":"Int"},{"text":".","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"When a tuple pattern is used as the pattern in a ","type":"text"},{"code":"for","type":"codeVoice"},{"type":"text","text":"-"},{"type":"codeVoice","code":"in"},{"text":" statement","type":"text"},{"type":"text","text":" "},{"type":"text","text":"or in a variable or constant declaration, it can contain only wildcard patterns,"},{"type":"text","text":" "},{"text":"identifier patterns, optional patterns, or other tuple patterns that contain those.","type":"text"},{"text":" ","type":"text"},{"text":"For example,","type":"text"},{"type":"text","text":" "},{"type":"text","text":"the following code isn’t valid because the element "},{"type":"codeVoice","code":"0"},{"type":"text","text":" in the tuple pattern "},{"type":"codeVoice","code":"(x, 0)"},{"text":" is","type":"text"},{"text":" ","type":"text"},{"text":"an expression pattern:","type":"text"}],"type":"paragraph"},{"code":["let points = [(0, 0), (1, 0), (1, 1), (2, 0), (2, 1)]","\/\/ This code isn't valid.","for (x, 0) in points {","    \/* ... *\/","}"],"type":"codeListing","syntax":"swift"},{"inlineContent":[{"type":"text","text":"The parentheses around a tuple pattern that contains a single element have no effect."},{"type":"text","text":" "},{"type":"text","text":"The pattern matches values of that single element’s type. For example, the following are"},{"text":" ","type":"text"},{"type":"text","text":"equivalent:"}],"type":"paragraph"},{"type":"codeListing","code":["let a = 2        \/\/ a: Int = 2","let (a) = 2      \/\/ a: Int = 2","let (a): Int = 2 \/\/ a: Int = 2"],"syntax":"swift"},{"content":[{"type":"paragraph","inlineContent":[{"text":"","type":"text"}]},{"inlineContent":[{"type":"emphasis","inlineContent":[{"type":"text","text":"tuple-pattern"}]},{"type":"text","text":" → "},{"inlineContent":[{"type":"codeVoice","code":"("}],"type":"strong"},{"type":"text","text":" "},{"type":"emphasis","inlineContent":[{"type":"text","text":"tuple-pattern-element-list"}]},{"type":"emphasis","inlineContent":[{"type":"text","text":"?"}]},{"type":"text","text":" "},{"inlineContent":[{"type":"codeVoice","code":")"}],"type":"strong"}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"emphasis","inlineContent":[{"type":"text","text":"tuple-pattern-element-list"}]},{"type":"text","text":" → "},{"type":"emphasis","inlineContent":[{"text":"tuple-pattern-element","type":"text"}]},{"text":" | ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"tuple-pattern-element","type":"text"}]},{"text":" ","type":"text"},{"type":"strong","inlineContent":[{"code":",","type":"codeVoice"}]},{"type":"text","text":" "},{"type":"emphasis","inlineContent":[{"text":"tuple-pattern-element-list","type":"text"}]}]},{"type":"paragraph","inlineContent":[{"type":"emphasis","inlineContent":[{"text":"tuple-pattern-element","type":"text"}]},{"type":"text","text":" → "},{"type":"emphasis","inlineContent":[{"text":"pattern","type":"text"}]},{"text":" | ","type":"text"},{"inlineContent":[{"type":"text","text":"identifier"}],"type":"emphasis"},{"text":" ","type":"text"},{"inlineContent":[{"type":"codeVoice","code":":"}],"type":"strong"},{"type":"text","text":" "},{"type":"emphasis","inlineContent":[{"type":"text","text":"pattern"}]}]}],"style":"note","name":"Grammar of a tuple pattern","type":"aside"},{"level":2,"anchor":"Patrones-de-Casos-de-Enumeraci%C3%B3n","text":"Patrones de Casos de Enumeración","type":"heading"},{"type":"paragraph","inlineContent":[{"type":"text","text":"An "},{"inlineContent":[{"type":"text","text":"enumeration case pattern"}],"type":"emphasis"},{"text":" matches a case of an existing enumeration type.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"Enumeration case patterns appear in "},{"type":"codeVoice","code":"switch"},{"text":" statement","type":"text"},{"type":"text","text":" "},{"type":"text","text":"case labels and in the case conditions of "},{"type":"codeVoice","code":"if"},{"type":"text","text":", "},{"type":"codeVoice","code":"while"},{"text":", ","type":"text"},{"type":"codeVoice","code":"guard"},{"type":"text","text":", and "},{"code":"for","type":"codeVoice"},{"text":"-","type":"text"},{"code":"in","type":"codeVoice"},{"text":" ","type":"text"},{"text":"statements.","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"If the enumeration case you’re trying to match has any associated values,","type":"text"},{"type":"text","text":" "},{"text":"the corresponding enumeration case pattern must specify a tuple pattern that contains","type":"text"},{"text":" ","type":"text"},{"text":"one element for each associated value. For an example that uses a ","type":"text"},{"code":"switch","type":"codeVoice"},{"type":"text","text":" statement"},{"text":" ","type":"text"},{"text":"to match enumeration cases containing associated values,","type":"text"},{"type":"text","text":" "},{"text":"see ","type":"text"},{"text":"doc:Enumerations#Valores-Asociados","type":"text"},{"type":"text","text":"."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"An enumeration case pattern also matches"},{"type":"text","text":" "},{"type":"text","text":"values of that case wrapped in an optional."},{"text":" ","type":"text"},{"type":"text","text":"This simplified syntax lets you omit an optional pattern."},{"text":" ","type":"text"},{"type":"text","text":"Note that,"},{"text":" ","type":"text"},{"text":"because ","type":"text"},{"type":"codeVoice","code":"Optional"},{"type":"text","text":" is implemented as an enumeration,"},{"text":" ","type":"text"},{"code":".none","type":"codeVoice"},{"type":"text","text":" and "},{"type":"codeVoice","code":".some"},{"type":"text","text":" can appear"},{"text":" ","type":"text"},{"type":"text","text":"in the same switch as the cases of the enumeration type."}]},{"type":"codeListing","syntax":"swift","code":["enum SomeEnum { case left, right }","let x: SomeEnum? = .left","switch x {","case .left:","    print(\"Turn left\")","case .right:","    print(\"Turn right\")","case nil:","    print(\"Keep going straight\")","}","\/\/ Prints \"Turn left\""]},{"style":"note","name":"Grammar of an enumeration case pattern","type":"aside","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":""}]},{"type":"paragraph","inlineContent":[{"type":"emphasis","inlineContent":[{"text":"enum-case-pattern","type":"text"}]},{"type":"text","text":" → "},{"type":"emphasis","inlineContent":[{"type":"text","text":"type-identifier"}]},{"type":"emphasis","inlineContent":[{"text":"?","type":"text"}]},{"type":"text","text":" "},{"inlineContent":[{"type":"codeVoice","code":"."}],"type":"strong"},{"type":"text","text":" "},{"inlineContent":[{"type":"text","text":"enum-case-name"}],"type":"emphasis"},{"text":" ","type":"text"},{"inlineContent":[{"text":"tuple-pattern","type":"text"}],"type":"emphasis"},{"inlineContent":[{"text":"?","type":"text"}],"type":"emphasis"}]}]},{"type":"heading","anchor":"Patr%C3%B3n-Opcional","level":2,"text":"Patrón Opcional"},{"type":"paragraph","inlineContent":[{"type":"text","text":"An "},{"type":"emphasis","inlineContent":[{"type":"text","text":"optional pattern"}]},{"type":"text","text":" matches values wrapped in a "},{"code":"some(Wrapped)","type":"codeVoice"},{"text":" case","type":"text"},{"type":"text","text":" "},{"type":"text","text":"of an "},{"code":"Optional<Wrapped>","type":"codeVoice"},{"text":" enumeration.","type":"text"},{"text":" ","type":"text"},{"text":"Optional patterns consist of an identifier pattern followed immediately by a question mark","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"and appear in the same places as enumeration case patterns."}]},{"type":"paragraph","inlineContent":[{"text":"Because optional patterns are syntactic sugar for ","type":"text"},{"type":"codeVoice","code":"Optional"},{"type":"text","text":" "},{"type":"text","text":"enumeration case patterns,"},{"type":"text","text":" "},{"text":"the following are equivalent:","type":"text"}]},{"type":"codeListing","syntax":"swift","code":["let someOptional: Int? = 42","\/\/ Match using an enumeration case pattern.","if case .some(let x) = someOptional {","    print(x)","}","","\/\/ Match using an optional pattern.","if case let x? = someOptional {","    print(x)","}"]},{"inlineContent":[{"type":"text","text":"The optional pattern provides a convenient way to"},{"type":"text","text":" "},{"type":"text","text":"iterate over an array of optional values in a "},{"code":"for","type":"codeVoice"},{"text":"-","type":"text"},{"code":"in","type":"codeVoice"},{"type":"text","text":" statement,"},{"text":" ","type":"text"},{"text":"executing the body of the loop only for non-","type":"text"},{"type":"codeVoice","code":"nil"},{"type":"text","text":" elements."}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["let arrayOfOptionalInts: [Int?] = [nil, 2, 3, nil, 5]","\/\/ Match only non-nil values.","for case let number? in arrayOfOptionalInts {","    print(\"Found a \\(number)\")","}","\/\/ Found a 2","\/\/ Found a 3","\/\/ Found a 5"]},{"name":"Grammar of an optional pattern","style":"note","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":""}]},{"type":"paragraph","inlineContent":[{"type":"emphasis","inlineContent":[{"type":"text","text":"optional-pattern"}]},{"text":" → ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"identifier-pattern","type":"text"}]},{"type":"text","text":" "},{"inlineContent":[{"type":"codeVoice","code":"?"}],"type":"strong"}]}],"type":"aside"},{"type":"heading","anchor":"Patrones-de-Conversi%C3%B3n-de-Tipos","level":2,"text":"Patrones de Conversión de Tipos"},{"inlineContent":[{"text":"There are two type-casting patterns, the ","type":"text"},{"code":"is","type":"codeVoice"},{"text":" pattern and the ","type":"text"},{"type":"codeVoice","code":"as"},{"text":" pattern.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"The "},{"type":"codeVoice","code":"is"},{"type":"text","text":" pattern appears only in "},{"type":"codeVoice","code":"switch"},{"type":"text","text":" statement"},{"type":"text","text":" "},{"text":"case labels. The ","type":"text"},{"type":"codeVoice","code":"is"},{"type":"text","text":" and "},{"type":"codeVoice","code":"as"},{"text":" patterns have the following form:","type":"text"}],"type":"paragraph"},{"type":"codeListing","code":["is <#type#>","<#pattern#> as <#type#>"],"syntax":"swift"},{"type":"paragraph","inlineContent":[{"text":"The ","type":"text"},{"type":"codeVoice","code":"is"},{"text":" pattern matches a value if the type of that value at runtime is the same as","type":"text"},{"type":"text","text":" "},{"text":"the type specified in the right-hand side of the ","type":"text"},{"type":"codeVoice","code":"is"},{"type":"text","text":" pattern — or a subclass of that type."},{"text":" ","type":"text"},{"type":"text","text":"The "},{"type":"codeVoice","code":"is"},{"text":" pattern behaves like the ","type":"text"},{"code":"is","type":"codeVoice"},{"text":" operator in that they both perform a type cast","type":"text"},{"type":"text","text":" "},{"type":"text","text":"but discard the returned type."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"code":"as","type":"codeVoice"},{"type":"text","text":" pattern matches a value if the type of that value at runtime is the same as"},{"text":" ","type":"text"},{"type":"text","text":"the type specified in the right-hand side of the "},{"code":"as","type":"codeVoice"},{"type":"text","text":" pattern — or a subclass of that type."},{"text":" ","type":"text"},{"text":"If the match succeeds,","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"the type of the matched value is cast to the "},{"inlineContent":[{"text":"pattern","type":"text"}],"type":"emphasis"},{"type":"text","text":" specified in the right-hand side"},{"text":" ","type":"text"},{"type":"text","text":"of the "},{"type":"codeVoice","code":"as"},{"type":"text","text":" pattern."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"For an example that uses a "},{"type":"codeVoice","code":"switch"},{"type":"text","text":" statement"},{"type":"text","text":" "},{"text":"to match values with ","type":"text"},{"type":"codeVoice","code":"is"},{"type":"text","text":" and "},{"type":"codeVoice","code":"as"},{"type":"text","text":" patterns,"},{"text":" ","type":"text"},{"text":"see ","type":"text"},{"text":"doc:TypeCasting#Conversión-de-Tipos-Para-Any-y-AnyObject","type":"text"},{"text":".","type":"text"}]},{"style":"note","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":""}]},{"inlineContent":[{"type":"emphasis","inlineContent":[{"type":"text","text":"type-casting-pattern"}]},{"text":" → ","type":"text"},{"inlineContent":[{"type":"text","text":"is-pattern"}],"type":"emphasis"},{"type":"text","text":" | "},{"type":"emphasis","inlineContent":[{"type":"text","text":"as-pattern"}]}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"inlineContent":[{"text":"is-pattern","type":"text"}],"type":"emphasis"},{"type":"text","text":" → "},{"type":"strong","inlineContent":[{"type":"codeVoice","code":"is"}]},{"type":"text","text":" "},{"type":"emphasis","inlineContent":[{"type":"text","text":"type"}]}]},{"type":"paragraph","inlineContent":[{"type":"emphasis","inlineContent":[{"type":"text","text":"as-pattern"}]},{"text":" → ","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"pattern"}]},{"type":"text","text":" "},{"inlineContent":[{"type":"codeVoice","code":"as"}],"type":"strong"},{"type":"text","text":" "},{"inlineContent":[{"type":"text","text":"type"}],"type":"emphasis"}]}],"type":"aside","name":"Grammar of a type casting pattern"},{"type":"heading","text":"Patrones Expresión","level":2,"anchor":"Patrones-Expresi%C3%B3n"},{"type":"paragraph","inlineContent":[{"type":"text","text":"An "},{"type":"emphasis","inlineContent":[{"type":"text","text":"expression pattern"}]},{"text":" represents the value of an expression.","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"Expression patterns appear only in "},{"code":"switch","type":"codeVoice"},{"text":" statement","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"case labels."}]},{"inlineContent":[{"text":"The expression represented by the expression pattern","type":"text"},{"type":"text","text":" "},{"text":"is compared with the value of an input expression","type":"text"},{"text":" ","type":"text"},{"text":"using the Swift standard library ","type":"text"},{"code":"~=","type":"codeVoice"},{"type":"text","text":" operator."},{"type":"text","text":" "},{"type":"text","text":"The matches succeeds"},{"type":"text","text":" "},{"type":"text","text":"if the "},{"code":"~=","type":"codeVoice"},{"text":" operator returns ","type":"text"},{"code":"true","type":"codeVoice"},{"text":". By default, the ","type":"text"},{"type":"codeVoice","code":"~="},{"text":" operator compares","type":"text"},{"type":"text","text":" "},{"type":"text","text":"two values of the same type using the "},{"type":"codeVoice","code":"=="},{"text":" operator.","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"It can also match a value with a range of values,"},{"type":"text","text":" "},{"type":"text","text":"by checking whether the value is contained within the range,"},{"type":"text","text":" "},{"type":"text","text":"as the following example shows."}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["let point = (1, 2)","switch point {","case (0, 0):","    print(\"(0, 0) is at the origin.\")","case (-2...2, -2...2):","    print(\"(\\(point.0), \\(point.1)) is near the origin.\")","default:","    print(\"The point is at (\\(point.0), \\(point.1)).\")","}","\/\/ Prints \"(1, 2) is near the origin.\""]},{"inlineContent":[{"text":"You can overload the ","type":"text"},{"code":"~=","type":"codeVoice"},{"type":"text","text":" operator to provide custom expression matching behavior."},{"type":"text","text":" "},{"type":"text","text":"For example, you can rewrite the above example to compare the "},{"code":"point","type":"codeVoice"},{"type":"text","text":" expression"},{"type":"text","text":" "},{"text":"with a string representations of points.","type":"text"}],"type":"paragraph"},{"code":["\/\/ Overload the ~= operator to match a string with an integer.","func ~= (pattern: String, value: Int) -> Bool {","    return pattern == \"\\(value)\"","}","switch point {","case (\"0\", \"0\"):","    print(\"(0, 0) is at the origin.\")","default:","    print(\"The point is at (\\(point.0), \\(point.1)).\")","}","\/\/ Prints \"The point is at (1, 2).\""],"syntax":"swift","type":"codeListing"},{"style":"note","content":[{"inlineContent":[{"type":"text","text":""}],"type":"paragraph"},{"inlineContent":[{"inlineContent":[{"type":"text","text":"expression-pattern"}],"type":"emphasis"},{"type":"text","text":" → "},{"inlineContent":[{"type":"text","text":"expression"}],"type":"emphasis"}],"type":"paragraph"}],"name":"Grammar of an expression pattern","type":"aside"},{"content":[{"inlineContent":[{"text":"","type":"text"}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"text":"Esta documentación contiene información preliminar sobre una API o tecnología en desarrollo. Esta información está sujeta a cambios, y todo software implementado en conformidad con esta documentación debe ser testeado con el software final del sistema operativo.","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Conoce más acerca del uso del "},{"identifier":"https:\/\/developer.apple.com\/es\/support\/beta-software\/","type":"reference","isActive":true},{"text":".","type":"text"}]}],"style":"note","name":"Software Beta","type":"aside"}]}],"references":{"doc://org.swift.tspl/documentation/The-Swift-Programming-Language":{"kind":"article","role":"collection","url":"\/documentation\/the-swift-programming-language","abstract":[],"title":"The Swift Programming Language (6)","type":"topic","identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language"},"https://developer.apple.com/es/support/beta-software/":{"type":"link","url":"https:\/\/developer.apple.com\/es\/support\/beta-software\/","identifier":"https:\/\/developer.apple.com\/es\/support\/beta-software\/","titleInlineContent":[{"text":"software beta de Apple","type":"text"}],"title":"software beta de Apple"}}}
=======
{"metadata":{"title":"Patrones"},"primaryContentSections":[{"content":[{"inlineContent":[{"type":"text","text":"A "},{"type":"emphasis","inlineContent":[{"type":"text","text":"pattern"}]},{"text":" represents the structure of a single value","type":"text"},{"text":" ","type":"text"},{"text":"or a composite value.","type":"text"},{"text":" ","type":"text"},{"text":"For example, the structure of a tuple ","type":"text"},{"code":"(1, 2)","type":"codeVoice"},{"text":" is a comma-separated list of two","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"elements. Because patterns represent the structure of a value rather than any"},{"type":"text","text":" "},{"type":"text","text":"one particular value, you can match them with a variety of values."},{"text":" ","type":"text"},{"type":"text","text":"For instance, the pattern "},{"type":"codeVoice","code":"(x, y)"},{"text":" matches the tuple ","type":"text"},{"code":"(1, 2)","type":"codeVoice"},{"type":"text","text":" and any other"},{"text":" ","type":"text"},{"type":"text","text":"two-element tuple. In addition to matching a pattern with a value,"},{"type":"text","text":" "},{"type":"text","text":"you can extract part or all of a composite value and bind each part"},{"text":" ","type":"text"},{"text":"to a constant or variable name.","type":"text"}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"text":"In Swift, there are two basic kinds of patterns:","type":"text"},{"type":"text","text":" "},{"type":"text","text":"those that successfully match any kind of value,"},{"type":"text","text":" "},{"text":"and those that may fail to match a specified value at runtime.","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"The first kind of pattern is used for destructuring values","type":"text"},{"type":"text","text":" "},{"type":"text","text":"in simple variable, constant, and optional bindings."},{"text":" ","type":"text"},{"type":"text","text":"These include wildcard patterns, identifier patterns,"},{"text":" ","type":"text"},{"type":"text","text":"and any value binding or tuple patterns containing"},{"type":"text","text":" "},{"type":"text","text":"them. You can specify a type annotation for these patterns"},{"text":" ","type":"text"},{"text":"to constrain them to match only values of a certain type.","type":"text"}]},{"inlineContent":[{"type":"text","text":"The second kind of pattern is used for full pattern matching,"},{"text":" ","type":"text"},{"type":"text","text":"where the values you’re trying to match against may not be there at runtime."},{"text":" ","type":"text"},{"text":"These include enumeration case patterns, optional patterns, expression patterns,","type":"text"},{"type":"text","text":" "},{"type":"text","text":"and type-casting patterns. You use these patterns in a case label of a "},{"code":"switch","type":"codeVoice"},{"text":" ","type":"text"},{"text":"statement, a ","type":"text"},{"type":"codeVoice","code":"catch"},{"type":"text","text":" clause of a "},{"code":"do","type":"codeVoice"},{"type":"text","text":" statement,"},{"type":"text","text":" "},{"text":"or in the case condition of an ","type":"text"},{"type":"codeVoice","code":"if"},{"type":"text","text":", "},{"code":"while","type":"codeVoice"},{"text":",","type":"text"},{"type":"text","text":" "},{"type":"codeVoice","code":"guard"},{"text":", or ","type":"text"},{"type":"codeVoice","code":"for"},{"type":"text","text":"-"},{"type":"codeVoice","code":"in"},{"type":"text","text":" statement."}],"type":"paragraph"},{"content":[{"type":"paragraph","inlineContent":[{"text":"","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"emphasis","inlineContent":[{"text":"pattern","type":"text"}]},{"text":" → ","type":"text"},{"inlineContent":[{"type":"text","text":"wildcard-pattern"}],"type":"emphasis"},{"type":"text","text":" "},{"inlineContent":[{"type":"text","text":"type-annotation"}],"type":"emphasis"},{"inlineContent":[{"type":"text","text":"?"}],"type":"emphasis"}]},{"inlineContent":[{"type":"emphasis","inlineContent":[{"type":"text","text":"pattern"}]},{"text":" → ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"identifier-pattern","type":"text"}]},{"text":" ","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"type-annotation"}]},{"type":"emphasis","inlineContent":[{"type":"text","text":"?"}]}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"inlineContent":[{"type":"text","text":"pattern"}],"type":"emphasis"},{"type":"text","text":" → "},{"inlineContent":[{"type":"text","text":"value-binding-pattern"}],"type":"emphasis"}]},{"type":"paragraph","inlineContent":[{"inlineContent":[{"type":"text","text":"pattern"}],"type":"emphasis"},{"type":"text","text":" → "},{"inlineContent":[{"type":"text","text":"tuple-pattern"}],"type":"emphasis"},{"text":" ","type":"text"},{"inlineContent":[{"type":"text","text":"type-annotation"}],"type":"emphasis"},{"type":"emphasis","inlineContent":[{"text":"?","type":"text"}]}]},{"inlineContent":[{"type":"emphasis","inlineContent":[{"type":"text","text":"pattern"}]},{"text":" → ","type":"text"},{"inlineContent":[{"type":"text","text":"enum-case-pattern"}],"type":"emphasis"}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"emphasis","inlineContent":[{"text":"pattern","type":"text"}]},{"text":" → ","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"optional-pattern"}]}]},{"type":"paragraph","inlineContent":[{"type":"emphasis","inlineContent":[{"type":"text","text":"pattern"}]},{"type":"text","text":" → "},{"inlineContent":[{"type":"text","text":"type-casting-pattern"}],"type":"emphasis"}]},{"type":"paragraph","inlineContent":[{"type":"emphasis","inlineContent":[{"text":"pattern","type":"text"}]},{"type":"text","text":" → "},{"type":"emphasis","inlineContent":[{"type":"text","text":"expression-pattern"}]}]}],"type":"aside","style":"note","name":"Grammar of a pattern"},{"text":"Patrón Comodín","level":2,"type":"heading","anchor":"Patr%C3%B3n-Comod%C3%ADn"},{"type":"paragraph","inlineContent":[{"text":"A ","type":"text"},{"inlineContent":[{"type":"text","text":"wildcard pattern"}],"type":"emphasis"},{"type":"text","text":" matches and ignores any value and consists of an underscore"},{"text":" ","type":"text"},{"type":"text","text":"("},{"type":"codeVoice","code":"_"},{"text":"). Use a wildcard pattern when you don’t care about the values being","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"matched against. For example, the following code iterates through the closed range "},{"type":"codeVoice","code":"1...3"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"ignoring the current value of the range on each iteration of the loop:"}]},{"type":"codeListing","syntax":"swift","code":["for _ in 1...3 {","    \/\/ Do something three times.","}"]},{"style":"note","type":"aside","content":[{"inlineContent":[{"text":"","type":"text"}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"inlineContent":[{"text":"wildcard-pattern","type":"text"}],"type":"emphasis"},{"type":"text","text":" → "},{"type":"strong","inlineContent":[{"code":"_","type":"codeVoice"}]}]}],"name":"Grammar of a wildcard pattern"},{"level":2,"text":"Patrón Identificador","anchor":"Patr%C3%B3n-Identificador","type":"heading"},{"inlineContent":[{"text":"An ","type":"text"},{"inlineContent":[{"type":"text","text":"identifier pattern"}],"type":"emphasis"},{"type":"text","text":" matches any value and binds the matched value to a"},{"type":"text","text":" "},{"type":"text","text":"variable or constant name."},{"text":" ","type":"text"},{"text":"For example, in the following constant declaration, ","type":"text"},{"type":"codeVoice","code":"someValue"},{"text":" is an identifier pattern","type":"text"},{"type":"text","text":" "},{"type":"text","text":"that matches the value "},{"code":"42","type":"codeVoice"},{"type":"text","text":" of type "},{"type":"codeVoice","code":"Int"},{"text":":","type":"text"}],"type":"paragraph"},{"type":"codeListing","code":["let someValue = 42"],"syntax":"swift"},{"type":"paragraph","inlineContent":[{"text":"When the match succeeds, the value ","type":"text"},{"type":"codeVoice","code":"42"},{"text":" is bound (assigned)","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"to the constant name "},{"code":"someValue","type":"codeVoice"},{"type":"text","text":"."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"When the pattern on the left-hand side of a variable or constant declaration"},{"text":" ","type":"text"},{"text":"is an identifier pattern,","type":"text"},{"text":" ","type":"text"},{"text":"the identifier pattern is implicitly a subpattern of a value-binding pattern.","type":"text"}]},{"style":"note","name":"Grammar of an identifier pattern","type":"aside","content":[{"inlineContent":[{"type":"text","text":""}],"type":"paragraph"},{"inlineContent":[{"type":"emphasis","inlineContent":[{"type":"text","text":"identifier-pattern"}]},{"type":"text","text":" → "},{"inlineContent":[{"type":"text","text":"identifier"}],"type":"emphasis"}],"type":"paragraph"}]},{"anchor":"Patr%C3%B3n-de-Vinculaci%C3%B3n-de-Valores","level":2,"text":"Patrón de Vinculación de Valores","type":"heading"},{"type":"paragraph","inlineContent":[{"type":"text","text":"A "},{"inlineContent":[{"text":"value-binding pattern","type":"text"}],"type":"emphasis"},{"type":"text","text":" binds matched values to variable or constant names."},{"type":"text","text":" "},{"type":"text","text":"Value-binding patterns that bind a matched value to the name of a constant"},{"text":" ","type":"text"},{"type":"text","text":"begin with the "},{"code":"let","type":"codeVoice"},{"type":"text","text":" keyword; those that bind to the name of variable"},{"text":" ","type":"text"},{"type":"text","text":"begin with the "},{"code":"var","type":"codeVoice"},{"type":"text","text":" keyword."}]},{"inlineContent":[{"text":"Identifiers patterns within a value-binding pattern","type":"text"},{"type":"text","text":" "},{"type":"text","text":"bind new named variables or constants to their matching values. For example,"},{"text":" ","type":"text"},{"text":"you can decompose the elements of a tuple and bind the value of each element to a","type":"text"},{"type":"text","text":" "},{"text":"corresponding identifier pattern.","type":"text"}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["let point = (3, 2)","switch point {","\/\/ Bind x and y to the elements of point.","case let (x, y):","    print(\"The point is at (\\(x), \\(y)).\")","}","\/\/ Prints \"The point is at (3, 2).\""]},{"type":"paragraph","inlineContent":[{"type":"text","text":"In the example above, "},{"type":"codeVoice","code":"let"},{"text":" distributes to each identifier pattern in the","type":"text"},{"type":"text","text":" "},{"type":"text","text":"tuple pattern "},{"code":"(x, y)","type":"codeVoice"},{"text":". Because of this behavior, the ","type":"text"},{"type":"codeVoice","code":"switch"},{"type":"text","text":" cases"},{"text":" ","type":"text"},{"type":"codeVoice","code":"case let (x, y):"},{"type":"text","text":" and "},{"code":"case (let x, let y):","type":"codeVoice"},{"type":"text","text":" match the same values."}]},{"style":"note","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":""}]},{"type":"paragraph","inlineContent":[{"inlineContent":[{"text":"value-binding-pattern","type":"text"}],"type":"emphasis"},{"type":"text","text":" → "},{"inlineContent":[{"code":"var","type":"codeVoice"}],"type":"strong"},{"text":" ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"pattern","type":"text"}]},{"type":"text","text":" | "},{"type":"strong","inlineContent":[{"type":"codeVoice","code":"let"}]},{"text":" ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"pattern","type":"text"}]}]}],"type":"aside","name":"Grammar of a value-binding pattern"},{"type":"heading","level":2,"text":"Patrones Tupla","anchor":"Patrones-Tupla"},{"inlineContent":[{"type":"text","text":"A "},{"type":"emphasis","inlineContent":[{"type":"text","text":"tuple pattern"}]},{"type":"text","text":" is a comma-separated list of zero or more patterns, enclosed in"},{"type":"text","text":" "},{"text":"parentheses. Tuple patterns match values of corresponding tuple types.","type":"text"}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"You can constrain a tuple pattern to match certain kinds of tuple types"},{"type":"text","text":" "},{"type":"text","text":"by using type annotations."},{"type":"text","text":" "},{"text":"For example, the tuple pattern ","type":"text"},{"type":"codeVoice","code":"(x, y): (Int, Int)"},{"text":" in the constant declaration","type":"text"},{"type":"text","text":" "},{"type":"codeVoice","code":"let (x, y): (Int, Int) = (1, 2)"},{"text":" matches only tuple types in which","type":"text"},{"type":"text","text":" "},{"type":"text","text":"both elements are of type "},{"code":"Int","type":"codeVoice"},{"text":".","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"When a tuple pattern is used as the pattern in a ","type":"text"},{"type":"codeVoice","code":"for"},{"type":"text","text":"-"},{"type":"codeVoice","code":"in"},{"type":"text","text":" statement"},{"type":"text","text":" "},{"type":"text","text":"or in a variable or constant declaration, it can contain only wildcard patterns,"},{"text":" ","type":"text"},{"type":"text","text":"identifier patterns, optional patterns, or other tuple patterns that contain those."},{"text":" ","type":"text"},{"type":"text","text":"For example,"},{"type":"text","text":" "},{"text":"the following code isn’t valid because the element ","type":"text"},{"code":"0","type":"codeVoice"},{"type":"text","text":" in the tuple pattern "},{"code":"(x, 0)","type":"codeVoice"},{"text":" is","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"an expression pattern:"}]},{"code":["let points = [(0, 0), (1, 0), (1, 1), (2, 0), (2, 1)]","\/\/ This code isn't valid.","for (x, 0) in points {","    \/* ... *\/","}"],"syntax":"swift","type":"codeListing"},{"inlineContent":[{"type":"text","text":"The parentheses around a tuple pattern that contains a single element have no effect."},{"type":"text","text":" "},{"text":"The pattern matches values of that single element’s type. For example, the following are","type":"text"},{"text":" ","type":"text"},{"text":"equivalent:","type":"text"}],"type":"paragraph"},{"code":["let a = 2        \/\/ a: Int = 2","let (a) = 2      \/\/ a: Int = 2","let (a): Int = 2 \/\/ a: Int = 2"],"type":"codeListing","syntax":"swift"},{"type":"aside","style":"note","name":"Grammar of a tuple pattern","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":""}]},{"inlineContent":[{"inlineContent":[{"text":"tuple-pattern","type":"text"}],"type":"emphasis"},{"type":"text","text":" → "},{"type":"strong","inlineContent":[{"type":"codeVoice","code":"("}]},{"text":" ","type":"text"},{"inlineContent":[{"text":"tuple-pattern-element-list","type":"text"}],"type":"emphasis"},{"type":"emphasis","inlineContent":[{"type":"text","text":"?"}]},{"text":" ","type":"text"},{"type":"strong","inlineContent":[{"code":")","type":"codeVoice"}]}],"type":"paragraph"},{"inlineContent":[{"type":"emphasis","inlineContent":[{"type":"text","text":"tuple-pattern-element-list"}]},{"type":"text","text":" → "},{"type":"emphasis","inlineContent":[{"type":"text","text":"tuple-pattern-element"}]},{"text":" | ","type":"text"},{"inlineContent":[{"type":"text","text":"tuple-pattern-element"}],"type":"emphasis"},{"text":" ","type":"text"},{"inlineContent":[{"type":"codeVoice","code":","}],"type":"strong"},{"text":" ","type":"text"},{"inlineContent":[{"type":"text","text":"tuple-pattern-element-list"}],"type":"emphasis"}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"emphasis","inlineContent":[{"type":"text","text":"tuple-pattern-element"}]},{"type":"text","text":" → "},{"type":"emphasis","inlineContent":[{"type":"text","text":"pattern"}]},{"type":"text","text":" | "},{"type":"emphasis","inlineContent":[{"type":"text","text":"identifier"}]},{"type":"text","text":" "},{"inlineContent":[{"code":":","type":"codeVoice"}],"type":"strong"},{"type":"text","text":" "},{"type":"emphasis","inlineContent":[{"text":"pattern","type":"text"}]}]}]},{"level":2,"anchor":"Patrones-de-Casos-de-Enumeraci%C3%B3n","type":"heading","text":"Patrones de Casos de Enumeración"},{"type":"paragraph","inlineContent":[{"type":"text","text":"An "},{"inlineContent":[{"type":"text","text":"enumeration case pattern"}],"type":"emphasis"},{"type":"text","text":" matches a case of an existing enumeration type."},{"type":"text","text":" "},{"type":"text","text":"Enumeration case patterns appear in "},{"code":"switch","type":"codeVoice"},{"type":"text","text":" statement"},{"text":" ","type":"text"},{"type":"text","text":"case labels and in the case conditions of "},{"code":"if","type":"codeVoice"},{"text":", ","type":"text"},{"code":"while","type":"codeVoice"},{"text":", ","type":"text"},{"code":"guard","type":"codeVoice"},{"text":", and ","type":"text"},{"type":"codeVoice","code":"for"},{"type":"text","text":"-"},{"type":"codeVoice","code":"in"},{"type":"text","text":" "},{"type":"text","text":"statements."}]},{"type":"paragraph","inlineContent":[{"text":"If the enumeration case you’re trying to match has any associated values,","type":"text"},{"type":"text","text":" "},{"type":"text","text":"the corresponding enumeration case pattern must specify a tuple pattern that contains"},{"text":" ","type":"text"},{"type":"text","text":"one element for each associated value. For an example that uses a "},{"type":"codeVoice","code":"switch"},{"type":"text","text":" statement"},{"type":"text","text":" "},{"type":"text","text":"to match enumeration cases containing associated values,"},{"type":"text","text":" "},{"text":"see ","type":"text"},{"text":"doc:Enumerations#Valores-Asociados","type":"text"},{"type":"text","text":"."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"An enumeration case pattern also matches"},{"type":"text","text":" "},{"text":"values of that case wrapped in an optional.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"This simplified syntax lets you omit an optional pattern."},{"type":"text","text":" "},{"type":"text","text":"Note that,"},{"type":"text","text":" "},{"text":"because ","type":"text"},{"code":"Optional","type":"codeVoice"},{"type":"text","text":" is implemented as an enumeration,"},{"text":" ","type":"text"},{"code":".none","type":"codeVoice"},{"text":" and ","type":"text"},{"code":".some","type":"codeVoice"},{"type":"text","text":" can appear"},{"type":"text","text":" "},{"type":"text","text":"in the same switch as the cases of the enumeration type."}]},{"code":["enum SomeEnum { case left, right }","let x: SomeEnum? = .left","switch x {","case .left:","    print(\"Turn left\")","case .right:","    print(\"Turn right\")","case nil:","    print(\"Keep going straight\")","}","\/\/ Prints \"Turn left\""],"syntax":"swift","type":"codeListing"},{"style":"note","type":"aside","name":"Grammar of an enumeration case pattern","content":[{"inlineContent":[{"type":"text","text":""}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"emphasis","inlineContent":[{"text":"enum-case-pattern","type":"text"}]},{"type":"text","text":" → "},{"inlineContent":[{"type":"text","text":"type-identifier"}],"type":"emphasis"},{"inlineContent":[{"type":"text","text":"?"}],"type":"emphasis"},{"type":"text","text":" "},{"type":"strong","inlineContent":[{"type":"codeVoice","code":"."}]},{"text":" ","type":"text"},{"inlineContent":[{"text":"enum-case-name","type":"text"}],"type":"emphasis"},{"text":" ","type":"text"},{"inlineContent":[{"text":"tuple-pattern","type":"text"}],"type":"emphasis"},{"inlineContent":[{"type":"text","text":"?"}],"type":"emphasis"}]}]},{"type":"heading","text":"Patrón Opcional","anchor":"Patr%C3%B3n-Opcional","level":2},{"type":"paragraph","inlineContent":[{"type":"text","text":"An "},{"inlineContent":[{"type":"text","text":"optional pattern"}],"type":"emphasis"},{"text":" matches values wrapped in a ","type":"text"},{"type":"codeVoice","code":"some(Wrapped)"},{"type":"text","text":" case"},{"text":" ","type":"text"},{"type":"text","text":"of an "},{"code":"Optional<Wrapped>","type":"codeVoice"},{"text":" enumeration.","type":"text"},{"text":" ","type":"text"},{"text":"Optional patterns consist of an identifier pattern followed immediately by a question mark","type":"text"},{"type":"text","text":" "},{"text":"and appear in the same places as enumeration case patterns.","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"Because optional patterns are syntactic sugar for ","type":"text"},{"code":"Optional","type":"codeVoice"},{"type":"text","text":" "},{"text":"enumeration case patterns,","type":"text"},{"text":" ","type":"text"},{"text":"the following are equivalent:","type":"text"}]},{"syntax":"swift","type":"codeListing","code":["let someOptional: Int? = 42","\/\/ Match using an enumeration case pattern.","if case .some(let x) = someOptional {","    print(x)","}","","\/\/ Match using an optional pattern.","if case let x? = someOptional {","    print(x)","}"]},{"type":"paragraph","inlineContent":[{"text":"The optional pattern provides a convenient way to","type":"text"},{"text":" ","type":"text"},{"text":"iterate over an array of optional values in a ","type":"text"},{"code":"for","type":"codeVoice"},{"type":"text","text":"-"},{"type":"codeVoice","code":"in"},{"text":" statement,","type":"text"},{"type":"text","text":" "},{"type":"text","text":"executing the body of the loop only for non-"},{"code":"nil","type":"codeVoice"},{"type":"text","text":" elements."}]},{"code":["let arrayOfOptionalInts: [Int?] = [nil, 2, 3, nil, 5]","\/\/ Match only non-nil values.","for case let number? in arrayOfOptionalInts {","    print(\"Found a \\(number)\")","}","\/\/ Found a 2","\/\/ Found a 3","\/\/ Found a 5"],"type":"codeListing","syntax":"swift"},{"type":"aside","style":"note","name":"Grammar of an optional pattern","content":[{"inlineContent":[{"text":"","type":"text"}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"inlineContent":[{"text":"optional-pattern","type":"text"}],"type":"emphasis"},{"text":" → ","type":"text"},{"inlineContent":[{"type":"text","text":"identifier-pattern"}],"type":"emphasis"},{"text":" ","type":"text"},{"type":"strong","inlineContent":[{"code":"?","type":"codeVoice"}]}]}]},{"level":2,"text":"Patrones de Conversión de Tipos","type":"heading","anchor":"Patrones-de-Conversi%C3%B3n-de-Tipos"},{"type":"paragraph","inlineContent":[{"text":"There are two type-casting patterns, the ","type":"text"},{"code":"is","type":"codeVoice"},{"text":" pattern and the ","type":"text"},{"code":"as","type":"codeVoice"},{"type":"text","text":" pattern."},{"text":" ","type":"text"},{"type":"text","text":"The "},{"type":"codeVoice","code":"is"},{"type":"text","text":" pattern appears only in "},{"code":"switch","type":"codeVoice"},{"text":" statement","type":"text"},{"type":"text","text":" "},{"type":"text","text":"case labels. The "},{"type":"codeVoice","code":"is"},{"text":" and ","type":"text"},{"code":"as","type":"codeVoice"},{"text":" patterns have the following form:","type":"text"}]},{"type":"codeListing","syntax":"swift","code":["is <#type#>","<#pattern#> as <#type#>"]},{"inlineContent":[{"text":"The ","type":"text"},{"type":"codeVoice","code":"is"},{"type":"text","text":" pattern matches a value if the type of that value at runtime is the same as"},{"text":" ","type":"text"},{"text":"the type specified in the right-hand side of the ","type":"text"},{"type":"codeVoice","code":"is"},{"text":" pattern — or a subclass of that type.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"The "},{"code":"is","type":"codeVoice"},{"type":"text","text":" pattern behaves like the "},{"type":"codeVoice","code":"is"},{"type":"text","text":" operator in that they both perform a type cast"},{"type":"text","text":" "},{"text":"but discard the returned type.","type":"text"}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"text":"The ","type":"text"},{"type":"codeVoice","code":"as"},{"type":"text","text":" pattern matches a value if the type of that value at runtime is the same as"},{"type":"text","text":" "},{"text":"the type specified in the right-hand side of the ","type":"text"},{"code":"as","type":"codeVoice"},{"text":" pattern — or a subclass of that type.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"If the match succeeds,"},{"type":"text","text":" "},{"type":"text","text":"the type of the matched value is cast to the "},{"inlineContent":[{"type":"text","text":"pattern"}],"type":"emphasis"},{"text":" specified in the right-hand side","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"of the "},{"type":"codeVoice","code":"as"},{"text":" pattern.","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"For an example that uses a "},{"code":"switch","type":"codeVoice"},{"type":"text","text":" statement"},{"text":" ","type":"text"},{"text":"to match values with ","type":"text"},{"type":"codeVoice","code":"is"},{"type":"text","text":" and "},{"type":"codeVoice","code":"as"},{"type":"text","text":" patterns,"},{"text":" ","type":"text"},{"type":"text","text":"see "},{"type":"text","text":"doc:TypeCasting#Conversión-de-Tipos-Para-Any-y-AnyObject"},{"type":"text","text":"."}]},{"name":"Grammar of a type casting pattern","type":"aside","content":[{"inlineContent":[{"text":"","type":"text"}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"inlineContent":[{"type":"text","text":"type-casting-pattern"}],"type":"emphasis"},{"text":" → ","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"is-pattern"}]},{"text":" | ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"as-pattern","type":"text"}]}]},{"type":"paragraph","inlineContent":[{"inlineContent":[{"text":"is-pattern","type":"text"}],"type":"emphasis"},{"type":"text","text":" → "},{"type":"strong","inlineContent":[{"type":"codeVoice","code":"is"}]},{"text":" ","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"type"}]}]},{"inlineContent":[{"type":"emphasis","inlineContent":[{"type":"text","text":"as-pattern"}]},{"type":"text","text":" → "},{"inlineContent":[{"type":"text","text":"pattern"}],"type":"emphasis"},{"type":"text","text":" "},{"inlineContent":[{"type":"codeVoice","code":"as"}],"type":"strong"},{"text":" ","type":"text"},{"type":"emphasis","inlineContent":[{"text":"type","type":"text"}]}],"type":"paragraph"}],"style":"note"},{"type":"heading","anchor":"Patrones-Expresi%C3%B3n","text":"Patrones Expresión","level":2},{"type":"paragraph","inlineContent":[{"text":"An ","type":"text"},{"inlineContent":[{"text":"expression pattern","type":"text"}],"type":"emphasis"},{"text":" represents the value of an expression.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"Expression patterns appear only in "},{"type":"codeVoice","code":"switch"},{"type":"text","text":" statement"},{"text":" ","type":"text"},{"type":"text","text":"case labels."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The expression represented by the expression pattern"},{"type":"text","text":" "},{"type":"text","text":"is compared with the value of an input expression"},{"text":" ","type":"text"},{"type":"text","text":"using the Swift standard library "},{"type":"codeVoice","code":"~="},{"text":" operator.","type":"text"},{"type":"text","text":" "},{"type":"text","text":"The matches succeeds"},{"type":"text","text":" "},{"type":"text","text":"if the "},{"type":"codeVoice","code":"~="},{"type":"text","text":" operator returns "},{"code":"true","type":"codeVoice"},{"type":"text","text":". By default, the "},{"code":"~=","type":"codeVoice"},{"type":"text","text":" operator compares"},{"type":"text","text":" "},{"type":"text","text":"two values of the same type using the "},{"code":"==","type":"codeVoice"},{"type":"text","text":" operator."},{"type":"text","text":" "},{"text":"It can also match a value with a range of values,","type":"text"},{"text":" ","type":"text"},{"text":"by checking whether the value is contained within the range,","type":"text"},{"text":" ","type":"text"},{"type":"text","text":"as the following example shows."}]},{"syntax":"swift","type":"codeListing","code":["let point = (1, 2)","switch point {","case (0, 0):","    print(\"(0, 0) is at the origin.\")","case (-2...2, -2...2):","    print(\"(\\(point.0), \\(point.1)) is near the origin.\")","default:","    print(\"The point is at (\\(point.0), \\(point.1)).\")","}","\/\/ Prints \"(1, 2) is near the origin.\""]},{"type":"paragraph","inlineContent":[{"type":"text","text":"You can overload the "},{"type":"codeVoice","code":"~="},{"type":"text","text":" operator to provide custom expression matching behavior."},{"text":" ","type":"text"},{"text":"For example, you can rewrite the above example to compare the ","type":"text"},{"code":"point","type":"codeVoice"},{"text":" expression","type":"text"},{"type":"text","text":" "},{"type":"text","text":"with a string representations of points."}]},{"code":["\/\/ Overload the ~= operator to match a string with an integer.","func ~= (pattern: String, value: Int) -> Bool {","    return pattern == \"\\(value)\"","}","switch point {","case (\"0\", \"0\"):","    print(\"(0, 0) is at the origin.\")","default:","    print(\"The point is at (\\(point.0), \\(point.1)).\")","}","\/\/ Prints \"The point is at (1, 2).\""],"type":"codeListing","syntax":"swift"},{"type":"aside","style":"note","name":"Grammar of an expression pattern","content":[{"inlineContent":[{"text":"","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"emphasis","inlineContent":[{"text":"expression-pattern","type":"text"}]},{"type":"text","text":" → "},{"inlineContent":[{"text":"expression","type":"text"}],"type":"emphasis"}],"type":"paragraph"}]},{"type":"aside","name":"Software Beta","content":[{"inlineContent":[{"text":"","type":"text"}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"text":"Esta documentación contiene información preliminar sobre una API o tecnología en desarrollo. Esta información está sujeta a cambios, y todo software implementado en conformidad con esta documentación debe ser testeado con el software final del sistema operativo.","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Conoce más acerca del uso del "},{"identifier":"https:\/\/developer.apple.com\/es\/support\/beta-software\/","type":"reference","isActive":true},{"type":"text","text":"."}]}],"style":"note"}],"kind":"content"}],"identifier":{"url":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language\/Patterns","interfaceLanguage":"swift"},"hierarchy":{"paths":[["doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language"]]},"schemaVersion":{"patch":0,"minor":3,"major":0},"kind":"article","sections":[],"abstract":[{"type":"text","text":"Match and destructure values."}],"references":{"doc://org.swift.tspl/documentation/The-Swift-Programming-Language":{"role":"collection","type":"topic","url":"\/documentation\/the-swift-programming-language","abstract":[],"title":"The Swift Programming Language (6)","identifier":"doc:\/\/org.swift.tspl\/documentation\/The-Swift-Programming-Language","kind":"article"},"https://developer.apple.com/es/support/beta-software/":{"titleInlineContent":[{"type":"text","text":"software beta de Apple"}],"url":"https:\/\/developer.apple.com\/es\/support\/beta-software\/","title":"software beta de Apple","type":"link","identifier":"https:\/\/developer.apple.com\/es\/support\/beta-software\/"}}}
>>>>>>> 2fa5d86d (yet one more fix attempt)
